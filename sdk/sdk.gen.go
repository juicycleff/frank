// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_key__Scopes                    = "api_key__.Scopes"
	Api_key_header_AuthorizationScopes = "api_key_header_Authorization.Scopes"
	Jwt_header_Scopes                  = "jwt_header_.Scopes"
	Jwt_header_AuthorizationScopes     = "jwt_header_Authorization.Scopes"
	Oauth2__Scopes                     = "oauth2__.Scopes"
	Oauth2_header_AuthorizationScopes  = "oauth2_header_Authorization.Scopes"
)

// Defines values for CreateAPIKeyRequestType.
const (
	CreateAPIKeyRequestTypeClient CreateAPIKeyRequestType = "client"
	CreateAPIKeyRequestTypeServer CreateAPIKeyRequestType = "server"
)

// Defines values for CreateIdentityProviderRequestProviderType.
const (
	Oauth2 CreateIdentityProviderRequestProviderType = "oauth2"
	Oidc   CreateIdentityProviderRequestProviderType = "oidc"
	Saml   CreateIdentityProviderRequestProviderType = "saml"
)

// Defines values for CreateWebhookRequestFormat.
const (
	CreateWebhookRequestFormatForm CreateWebhookRequestFormat = "form"
	CreateWebhookRequestFormatJson CreateWebhookRequestFormat = "json"
)

// Defines values for FormFieldType.
const (
	Checkbox FormFieldType = "checkbox"
	Number   FormFieldType = "number"
	Select   FormFieldType = "select"
	Text     FormFieldType = "text"
)

// Defines values for FormFieldWidth.
const (
	Full  FormFieldWidth = "full"
	Half  FormFieldWidth = "half"
	Third FormFieldWidth = "third"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for HealthStatusStatus.
const (
	HealthStatusStatusHealthy   HealthStatusStatus = "healthy"
	HealthStatusStatusUnhealthy HealthStatusStatus = "unhealthy"
)

// Defines values for MFAEnrollRequestMethod.
const (
	MFAEnrollRequestMethodBackupCodes MFAEnrollRequestMethod = "backup_codes"
	MFAEnrollRequestMethodEmail       MFAEnrollRequestMethod = "email"
	MFAEnrollRequestMethodSms         MFAEnrollRequestMethod = "sms"
	MFAEnrollRequestMethodTotp        MFAEnrollRequestMethod = "totp"
)

// Defines values for MFAUnEnrollRequestMethod.
const (
	MFAUnEnrollRequestMethodAll         MFAUnEnrollRequestMethod = "all"
	MFAUnEnrollRequestMethodBackupCodes MFAUnEnrollRequestMethod = "backup_codes"
	MFAUnEnrollRequestMethodEmail       MFAUnEnrollRequestMethod = "email"
	MFAUnEnrollRequestMethodSms         MFAUnEnrollRequestMethod = "sms"
	MFAUnEnrollRequestMethodTotp        MFAUnEnrollRequestMethod = "totp"
)

// Defines values for MFAVerifyRequestMethod.
const (
	MFAVerifyRequestMethodBackupCodes MFAVerifyRequestMethod = "backup_codes"
	MFAVerifyRequestMethodEmail       MFAVerifyRequestMethod = "email"
	MFAVerifyRequestMethodSms         MFAVerifyRequestMethod = "sms"
	MFAVerifyRequestMethodTotp        MFAVerifyRequestMethod = "totp"
)

// Defines values for OrganizationVerificationConfigMethod.
const (
	OrganizationVerificationConfigMethodEmail OrganizationVerificationConfigMethod = "email"
	OrganizationVerificationConfigMethodPhone OrganizationVerificationConfigMethod = "phone"
	OrganizationVerificationConfigMethodSms   OrganizationVerificationConfigMethod = "sms"
)

// Defines values for PasswordlessVerifyRequestAuthType.
const (
	PasswordlessVerifyRequestAuthTypeEmail PasswordlessVerifyRequestAuthType = "email"
	PasswordlessVerifyRequestAuthTypeSms   PasswordlessVerifyRequestAuthType = "sms"
)

// Defines values for ReadyResponseStatus.
const (
	NotReady ReadyResponseStatus = "not_ready"
	Ready    ReadyResponseStatus = "ready"
)

// Defines values for SendEmailVerificationRequestBodyMethod.
const (
	SendEmailVerificationRequestBodyMethodLink SendEmailVerificationRequestBodyMethod = "link"
	SendEmailVerificationRequestBodyMethodOtp  SendEmailVerificationRequestBodyMethod = "otp"
)

// Defines values for SendMFACodeRequestMethod.
const (
	SendMFACodeRequestMethodEmail SendMFACodeRequestMethod = "email"
	SendMFACodeRequestMethodSms   SendMFACodeRequestMethod = "sms"
)

// Defines values for UpdateWebhookRequestFormat.
const (
	UpdateWebhookRequestFormatForm UpdateWebhookRequestFormat = "form"
	UpdateWebhookRequestFormatJson UpdateWebhookRequestFormat = "json"
)

// Defines values for VerifyEmailRequestMethod.
const (
	VerifyEmailRequestMethodLink VerifyEmailRequestMethod = "link"
	VerifyEmailRequestMethodOtp  VerifyEmailRequestMethod = "otp"
)

// Defines values for ApiKeysListParamsType.
const (
	ApiKeysListParamsTypeClient ApiKeysListParamsType = "client"
	ApiKeysListParamsTypeServer ApiKeysListParamsType = "server"
)

// APIKeyResponse API key information without the actual key
type APIKeyResponse struct {
	// Active Whether API key is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// ExpiresAt Expiry timestamp
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Id API key ID
	Id string `json:"id"`

	// LastUsed Last used timestamp
	LastUsed *string `json:"last_used,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`

	// Type API key type (client/server)
	Type string `json:"type"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UserId User ID who owns the key
	UserId *string `json:"user_id,omitempty"`
}

// APIKeyWithSecretResponse API key information with the actual key
type APIKeyWithSecretResponse struct {
	// Active Whether API key is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// ExpiresAt Expiry timestamp
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Id API key ID
	Id string `json:"id"`

	// Key API key secret
	Key string `json:"key"`

	// LastUsed Last used timestamp
	LastUsed *string `json:"last_used,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`

	// Type API key type (client/server)
	Type string `json:"type"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UserId User ID who owns the key
	UserId *string `json:"user_id,omitempty"`
}

// AddMemberRequestBody defines model for AddMemberRequestBody.
type AddMemberRequestBody struct {
	// Member Add organization member request
	Member AddOrganizationMemberRequest `json:"member"`
}

// AddOrganizationMemberRequest Add organization member request
type AddOrganizationMemberRequest struct {
	// Roles Roles to assign
	Roles []string `json:"roles"`

	// UserId User ID to add
	UserId string `json:"user_id"`
}

// AddRolePermissionRequest Add permission to role request
type AddRolePermissionRequest struct {
	// PermissionId Permission ID
	PermissionId string `json:"permission_id"`
}

// AddRolePermissionRequestBody defines model for AddRolePermissionRequestBody.
type AddRolePermissionRequestBody struct {
	// Permission Add permission to role request
	Permission AddRolePermissionRequest `json:"permission"`
}

// BackupCodesResponse Backup codes response
type BackupCodesResponse struct {
	// BackupCodes List of backup codes
	BackupCodes []string `json:"backup_codes"`
}

// BadRequestError Bad request response
type BadRequestError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// CSRFTokenResponse CSRF token response
type CSRFTokenResponse struct {
	// CsrfToken CSRF token
	CsrfToken string `json:"csrf_token"`
}

// CheckEmailVerificationResponseBody defines model for CheckEmailVerificationResponseBody.
type CheckEmailVerificationResponseBody struct {
	// Verified Whether email is verified
	Verified bool `json:"verified"`
}

// CheckPermissionResponseBody defines model for CheckPermissionResponseBody.
type CheckPermissionResponseBody struct {
	// HasPermission Whether user has the permission
	HasPermission bool `json:"has_permission"`
}

// CheckRoleResponseBody defines model for CheckRoleResponseBody.
type CheckRoleResponseBody struct {
	// HasRole Whether user has the role
	HasRole bool `json:"has_role"`
}

// ConflictError Conflict response
type ConflictError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// ConsentRequest OAuth consent request
type ConsentRequest struct {
	// Approved Whether consent is approved
	Approved *bool `json:"approved,omitempty"`

	// ClientId OAuth client ID
	ClientId string `json:"client_id"`

	// RedirectUri Redirect URI
	RedirectUri string `json:"redirect_uri"`

	// Scope Requested scopes (space-separated)
	Scope string `json:"scope"`

	// State OAuth state parameter
	State *string `json:"state,omitempty"`
}

// ConsentResponseBody defines model for ConsentResponseBody.
type ConsentResponseBody struct {
	// RedirectUri Redirect URI with authorization code
	RedirectUri string `json:"redirect_uri"`
}

// CreateAPIKeyRequest Create API key request
type CreateAPIKeyRequest struct {
	// ExpiresIn Expiry in seconds
	ExpiresIn *int64 `json:"expires_in,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name string `json:"name"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`

	// Type API key type
	Type *CreateAPIKeyRequestType `json:"type,omitempty"`
}

// CreateAPIKeyRequestType API key type
type CreateAPIKeyRequestType string

// CreateEmailTemplateRequest Create email template request
type CreateEmailTemplateRequest struct {
	// Active Whether template is active
	Active *bool `json:"active,omitempty"`

	// HtmlContent HTML content
	HtmlContent string `json:"html_content"`

	// Locale Template locale
	Locale *string `json:"locale,omitempty"`

	// Metadata Template metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Template name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Subject Email subject
	Subject string `json:"subject"`

	// System Whether this is a system template
	System *bool `json:"system,omitempty"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`

	// Type Template type
	Type string `json:"type"`
}

// CreateIdentityProviderRequest Create identity provider request
type CreateIdentityProviderRequest struct {
	// Active Whether provider is active
	Active *bool `json:"active,omitempty"`

	// AttributesMapping Attributes mapping
	AttributesMapping *map[string]string `json:"attributes_mapping,omitempty"`

	// AuthorizationEndpoint OAuth/OIDC authorization endpoint
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// Certificate SAML certificate
	Certificate *string `json:"certificate,omitempty"`

	// ClientId OAuth/OIDC client ID
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret OAuth/OIDC client secret
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domains Allowed email domains
	Domains *[]string `json:"domains,omitempty"`

	// Issuer OIDC issuer URL
	Issuer *string `json:"issuer,omitempty"`

	// JwksUri OIDC JWKS URI
	JwksUri *string `json:"jwks_uri,omitempty"`

	// MetadataUrl SAML metadata URL
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Provider name
	Name string `json:"name"`

	// Primary Whether this is the primary provider
	Primary *bool `json:"primary,omitempty"`

	// PrivateKey SAML private key
	PrivateKey *string `json:"private_key,omitempty"`

	// ProviderType Provider type
	ProviderType CreateIdentityProviderRequestProviderType `json:"provider_type"`

	// RedirectUri OAuth/OIDC redirect URI
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// TokenEndpoint OAuth/OIDC token endpoint
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// UserinfoEndpoint OIDC userinfo endpoint
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
}

// CreateIdentityProviderRequestProviderType Provider type
type CreateIdentityProviderRequestProviderType string

// CreateIdentityProviderRequestBody defines model for CreateIdentityProviderRequestBody.
type CreateIdentityProviderRequestBody struct {
	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// Provider Create identity provider request
	Provider CreateIdentityProviderRequest `json:"provider"`
}

// CreateOAuthClientRequest Create OAuth client request
type CreateOAuthClientRequest struct {
	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes *[]string `json:"allowed_grant_types,omitempty"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientName Client name
	ClientName string `json:"client_name"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public *bool `json:"public,omitempty"`

	// RedirectUris Authorized redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`
}

// CreateOAuthScopeRequest Create OAuth scope request
type CreateOAuthScopeRequest struct {
	// DefaultScope Whether this scope is included by default
	DefaultScope *bool `json:"default_scope,omitempty"`

	// Description Scope description
	Description string `json:"description"`

	// Name Scope name
	Name string `json:"name"`

	// Public Whether this scope can be requested by any client
	Public *bool `json:"public,omitempty"`
}

// CreateOrganizationRequest Create organization request
type CreateOrganizationRequest struct {
	// Domain Organization domain
	Domain *string `json:"domain,omitempty"`

	// Features Features to enable
	Features *[]string `json:"features,omitempty"`

	// LogoUrl Organization logo URL
	LogoUrl *string `json:"logo_url,omitempty"`

	// Metadata Organization metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Organization name
	Name string `json:"name"`

	// Plan Organization plan
	Plan *string `json:"plan,omitempty"`

	// Slug Organization slug
	Slug *string `json:"slug,omitempty"`

	// TrialDays Number of trial days
	TrialDays *int64 `json:"trial_days,omitempty"`
}

// CreatePermissionRequest Create permission request
type CreatePermissionRequest struct {
	// Action Action this permission allows
	Action string `json:"action"`

	// Conditions JSON expression for conditional access
	Conditions *string `json:"conditions,omitempty"`

	// Description Permission description
	Description string `json:"description"`

	// Name Permission name
	Name string `json:"name"`

	// Resource Resource this permission applies to
	Resource string `json:"resource"`
}

// CreatePermissionRequestBody defines model for CreatePermissionRequestBody.
type CreatePermissionRequestBody struct {
	// Permission Create permission request
	Permission CreatePermissionRequest `json:"permission"`
}

// CreateRequestBody defines model for CreateRequestBody.
type CreateRequestBody struct {
	// Key Create API key request
	Key CreateAPIKeyRequest `json:"key"`
}

// CreateRequestBody2 defines model for CreateRequestBody2.
type CreateRequestBody2 struct {
	// Organization Create organization request
	Organization CreateOrganizationRequest `json:"organization"`
}

// CreateRequestBody3 defines model for CreateRequestBody3.
type CreateRequestBody3 struct {
	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// Webhook Create webhook request
	Webhook CreateWebhookRequest `json:"webhook"`
}

// CreateRoleRequest Create role request
type CreateRoleRequest struct {
	// Description Role description
	Description *string `json:"description,omitempty"`

	// IsDefault Whether this is a default role for new users
	IsDefault *bool `json:"is_default,omitempty"`

	// Name Role name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`
}

// CreateRoleRequestBody defines model for CreateRoleRequestBody.
type CreateRoleRequestBody struct {
	// Role Create role request
	Role CreateRoleRequest `json:"role"`
}

// CreateUserRequest Create user request
type CreateUserRequest struct {
	// Email Email address
	Email openapi_types.Email `json:"email"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// Id ID of the entity
	Id *string `json:"id,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Locale User locale
	Locale *string `json:"locale,omitempty"`

	// Metadata User metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID to add user to
	OrganizationId *string `json:"organization_id,omitempty"`

	// Password User password
	Password *string `json:"password,omitempty"`

	// PhoneNumber User phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// ProfileImageUrl URL to user's profile image
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`
}

// CreateWebhookRequest Create webhook request
type CreateWebhookRequest struct {
	// EventTypes Event types to subscribe to
	EventTypes []string `json:"event_types"`

	// Format Payload format
	Format *CreateWebhookRequestFormat `json:"format,omitempty"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name string `json:"name"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// Url Webhook URL
	Url string `json:"url"`
}

// CreateWebhookRequestFormat Payload format
type CreateWebhookRequestFormat string

// EmailResponseBody defines model for EmailResponseBody.
type EmailResponseBody struct {
	// Message Success message
	Message string `json:"message"`

	// VerificationId Verification ID
	VerificationId string `json:"verification_id"`
}

// EmailTemplateResponse Email template information
type EmailTemplateResponse struct {
	// Active Whether template is active
	Active bool `json:"active"`

	// CreatedAt Created At
	CreatedAt time.Time `json:"created_at"`

	// HtmlContent HTML content
	HtmlContent string `json:"html_content"`

	// Id ID of the entity
	Id string `json:"id"`

	// Locale Template locale
	Locale string `json:"locale"`

	// Metadata Template metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Template name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Subject Email subject
	Subject string `json:"subject"`

	// System Whether this is a system template
	System bool `json:"system"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`

	// Type Template type
	Type string `json:"type"`

	// UpdatedAt Updated At
	UpdatedAt time.Time `json:"updated_at"`
}

// EnableFeatureRequest Enable feature request
type EnableFeatureRequest struct {
	// FeatureKey Feature key to enable
	FeatureKey string `json:"feature_key"`

	// Settings Feature settings
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// EnableFeatureRequestBody defines model for EnableFeatureRequestBody.
type EnableFeatureRequestBody struct {
	// Feature Enable feature request
	Feature EnableFeatureRequest `json:"feature"`
}

// EnrollRequestBody defines model for EnrollRequestBody.
type EnrollRequestBody struct {
	// Request MFA enrollment request
	Request MFAEnrollRequest `json:"request"`
}

// EnrollResponseBody defines model for EnrollResponseBody.
type EnrollResponseBody struct {
	// BackupCodes Backup codes response
	BackupCodes *BackupCodesResponse `json:"backup_codes,omitempty"`

	// Message Success message for SMS/Email enrollment
	Message *string `json:"message,omitempty"`

	// Totp TOTP enrollment response
	Totp *TOTPEnrollResponse `json:"totp,omitempty"`
}

// ForbiddenError Forbidden response
type ForbiddenError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// ForgotPasswordRequest Forgot password request
type ForgotPasswordRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`
}

// FormField Represents a form field configuration
type FormField struct {
	// IsEmail Indicates if field represents an email
	IsEmail *bool `json:"isEmail,omitempty"`

	// IsFirstName Indicates if field represents a first name
	IsFirstName *bool `json:"isFirstName,omitempty"`

	// IsLastName Indicates if field represents a last name
	IsLastName *bool `json:"isLastName,omitempty"`

	// Label Display label for the field
	Label string `json:"label"`

	// Name Field identifier name
	Name string `json:"name"`

	// Options Options for select fields
	Options *[]FormFieldSelectOption `json:"options,omitempty"`

	// Placeholder Placeholder text
	Placeholder *string `json:"placeholder,omitempty"`

	// Required Whether the field is required
	Required *bool `json:"required,omitempty"`

	// Row Row position identifier (string or number)
	Row *interface{} `json:"row,omitempty"`

	// Type Type of form field
	Type FormFieldType `json:"type"`

	// Validation Validation rules for form fields
	Validation *FormFieldValidationRules `json:"validation,omitempty"`

	// Width Width of the field
	Width *FormFieldWidth `json:"width,omitempty"`
}

// FormFieldType Type of form field
type FormFieldType string

// FormFieldWidth Width of the field
type FormFieldWidth string

// FormFieldSelectOption Option for select fields
type FormFieldSelectOption struct {
	// Label Option display label
	Label string `json:"label"`

	// Value Option value
	Value string `json:"value"`
}

// FormFieldValidationRules Validation rules for form fields
type FormFieldValidationRules struct {
	// Max Maximum value
	Max *float32 `json:"max,omitempty"`

	// MaxLength Maximum length
	MaxLength *int64 `json:"maxLength,omitempty"`

	// Min Minimum value
	Min *float32 `json:"min,omitempty"`

	// MinLength Minimum length
	MinLength *int64 `json:"minLength,omitempty"`

	// Pattern Regex pattern for validation
	Pattern *string `json:"pattern,omitempty"`
}

// GetOrganizationsResponseBody defines model for GetOrganizationsResponseBody.
type GetOrganizationsResponseBody struct {
	Organizations []Organization `json:"organizations"`
}

// GetUserSessionResponse Get user session response
type GetUserSessionResponse struct {
	// Data User sessions
	Data []Session `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// HealthResponse Health check response
type HealthResponse struct {
	// Services Status of individual services
	Services *[]HealthStatus `json:"services,omitempty"`

	// Status Overall health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Timestamp of health check
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponseStatus Overall health status
type HealthResponseStatus string

// HealthStatus Service health status
type HealthStatus struct {
	// Message Additional message
	Message *string `json:"message,omitempty"`

	// Service Service name
	Service string `json:"service"`

	// Status Service status
	Status HealthStatusStatus `json:"status"`
}

// HealthStatusStatus Service status
type HealthStatusStatus string

// IdentityProviderResponse Identity provider information
type IdentityProviderResponse struct {
	// Active Whether provider is active
	Active bool `json:"active"`

	// AttributesMapping Attributes mapping
	AttributesMapping *map[string]string `json:"attributes_mapping,omitempty"`

	// AuthorizationEndpoint OAuth/OIDC authorization endpoint
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// ClientId OAuth/OIDC client ID
	ClientId *string `json:"client_id,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Domains Allowed email domains
	Domains *[]string `json:"domains,omitempty"`

	// Id Provider ID
	Id string `json:"id"`

	// Issuer OIDC issuer URL
	Issuer *string `json:"issuer,omitempty"`

	// JwksUri OIDC JWKS URI
	JwksUri *string `json:"jwks_uri,omitempty"`

	// MetadataUrl SAML metadata URL
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Provider name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// Primary Whether this is the primary provider
	Primary *bool `json:"primary,omitempty"`

	// ProviderType Provider type (oauth2, oidc, saml)
	ProviderType string `json:"provider_type"`

	// RedirectUri OAuth/OIDC redirect URI
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// TokenEndpoint OAuth/OIDC token endpoint
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UserinfoEndpoint OIDC userinfo endpoint
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
}

// InternalServerError Internal server error response
type InternalServerError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// IntrospectResponseBody defines model for IntrospectResponseBody.
type IntrospectResponseBody struct {
	// Active Whether token is active
	Active bool `json:"active"`

	// Aud Audience
	Aud *string `json:"aud,omitempty"`

	// ClientId Client ID
	ClientId *string `json:"client_id,omitempty"`

	// Exp Expiry timestamp
	Exp *int64 `json:"exp,omitempty"`

	// Iat Issued at timestamp
	Iat *int64 `json:"iat,omitempty"`

	// Iss Issuer
	Iss *string `json:"iss,omitempty"`

	// Jti JWTAuth ID
	Jti *string `json:"jti,omitempty"`

	// Nbf Not before timestamp
	Nbf *int64 `json:"nbf,omitempty"`

	// Scope Token scopes
	Scope *string `json:"scope,omitempty"`

	// Sub Subject (user ID)
	Sub *string `json:"sub,omitempty"`

	// TokenType Token type
	TokenType *string `json:"token_type,omitempty"`

	// Username Resource owner username
	Username *string `json:"username,omitempty"`
}

// JwksResponseBody defines model for JwksResponseBody.
type JwksResponseBody struct {
	Keys []interface{} `json:"keys"`
}

// ListClientsResponseBody defines model for ListClientsResponseBody.
type ListClientsResponseBody struct {
	Data []OAuthClientResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListEventsResponseBody defines model for ListEventsResponseBody.
type ListEventsResponseBody struct {
	Data []WebhookEventResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListFeaturesResponseBody defines model for ListFeaturesResponseBody.
type ListFeaturesResponseBody struct {
	Features []OrganizationFeatureResponse `json:"features"`
}

// ListIdentityProvidersResponseBody defines model for ListIdentityProvidersResponseBody.
type ListIdentityProvidersResponseBody struct {
	Providers []IdentityProviderResponse `json:"providers"`
}

// ListMembersResponseBody defines model for ListMembersResponseBody.
type ListMembersResponseBody struct {
	Data []OrganizationMemberResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListPermissionsResponse Add permission to role request
type ListPermissionsResponse struct {
	Data []PermissionResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListProvidersResponseBody defines model for ListProvidersResponseBody.
type ListProvidersResponseBody struct {
	Providers []SSOProvider `json:"providers"`
}

// ListResponseBody defines model for ListResponseBody.
type ListResponseBody struct {
	Data []APIKeyResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`

	// Total Total number of keys
	Total int64 `json:"total"`
}

// ListResponseBody2 defines model for ListResponseBody2.
type ListResponseBody2 struct {
	Data []Organization `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListResponseBody3 defines model for ListResponseBody3.
type ListResponseBody3 struct {
	Passkeys []RegisteredPasskey `json:"passkeys"`
}

// ListResponseBody4 defines model for ListResponseBody4.
type ListResponseBody4 struct {
	Data []User `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListResponseBody5 defines model for ListResponseBody5.
type ListResponseBody5 struct {
	Data []WebhookResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListRolePermissionsResponseBody defines model for ListRolePermissionsResponseBody.
type ListRolePermissionsResponseBody struct {
	Permissions []PermissionResponse `json:"permissions"`
}

// ListRolesResponseBody defines model for ListRolesResponseBody.
type ListRolesResponseBody struct {
	Data []RoleResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListScopesResponseBody defines model for ListScopesResponseBody.
type ListScopesResponseBody struct {
	Data []OAuthScopeResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListTemplatesResponseBody defines model for ListTemplatesResponseBody.
type ListTemplatesResponseBody struct {
	Data []EmailTemplateResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// LoginCompleteResponseBody defines model for LoginCompleteResponseBody.
type LoginCompleteResponseBody struct {
	// Authenticated Whether authentication was successful
	Authenticated bool `json:"authenticated"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// LoginRequest Login credentials
type LoginRequest struct {
	// CaptchaResponse CAPTCHA response for protected login
	CaptchaResponse *string `json:"captcha_response,omitempty"`

	// Email User email
	Email openapi_types.Email `json:"email"`

	// OrganizationId Organization ID if logging into a specific organization
	OrganizationId *string `json:"organization_id,omitempty"`

	// Password User password
	Password string `json:"password"`

	// RememberMe Whether to remember the user
	RememberMe *bool `json:"remember_me,omitempty"`
}

// LoginResponse2 defines model for LoginResponse2.
type LoginResponse2 struct {
	// CsrfToken CSRF token
	CsrfToken string `json:"csrf_token"`

	// EmailVerified Whether email is verified
	EmailVerified *bool `json:"emailVerified,omitempty"`

	// ExpiresAt Token expiry timestamp
	ExpiresAt int64 `json:"expires_at"`

	// Message Login message
	Message *string `json:"message,omitempty"`

	// MfaRequired Whether MFA is required to complete authentication
	MfaRequired bool `json:"mfa_required"`

	// MfaTypes Available MFA methods when MFA is required
	MfaTypes *[]string `json:"mfa_types,omitempty"`

	// RefreshToken JWTAuth refresh token
	RefreshToken string `json:"refresh_token"`

	// RequiresVerification Whether email verification is required
	RequiresVerification *bool `json:"requiresVerification,omitempty"`

	// Token JWTAuth access token
	Token string `json:"token"`

	// User User information
	User User `json:"user"`

	// VerificationId Verification ID for email verification
	VerificationId *string `json:"verificationId,omitempty"`

	// VerificationMethod Verification method for email verification
	VerificationMethod *string `json:"verificationMethod,omitempty"`

	// VerificationRequired Whether email verification is required
	VerificationRequired *bool `json:"verificationRequired,omitempty"`
}

// LoginResponse3 defines model for LoginResponse3.
type LoginResponse3 struct {
	// CsrfToken CSRF token
	CsrfToken string `json:"csrf_token"`

	// EmailVerified Whether email is verified
	EmailVerified *bool `json:"emailVerified,omitempty"`

	// ExpiresAt Token expiry timestamp
	ExpiresAt int64 `json:"expires_at"`

	// Message Login message
	Message *string `json:"message,omitempty"`

	// MfaRequired Whether MFA is required to complete authentication
	MfaRequired bool `json:"mfa_required"`

	// MfaTypes Available MFA methods when MFA is required
	MfaTypes *[]string `json:"mfa_types,omitempty"`

	// RefreshToken JWTAuth refresh token
	RefreshToken string `json:"refresh_token"`

	// RequiresVerification Whether email verification is required
	RequiresVerification *bool `json:"requiresVerification,omitempty"`

	// Token JWTAuth access token
	Token string `json:"token"`

	// User User information
	User User `json:"user"`

	// VerificationId Verification ID for email verification
	VerificationId *string `json:"verificationId,omitempty"`

	// VerificationMethod Verification method for email verification
	VerificationMethod *string `json:"verificationMethod,omitempty"`

	// VerificationRequired Whether email verification is required
	VerificationRequired *bool `json:"verificationRequired,omitempty"`
}

// MFAEnrollRequest MFA enrollment request
type MFAEnrollRequest struct {
	// Email Email for email verification
	Email *openapi_types.Email `json:"email,omitempty"`

	// Method MFA method to enroll
	Method MFAEnrollRequestMethod `json:"method"`

	// PhoneNumber Phone number for SMS verification
	PhoneNumber *string `json:"phone_number,omitempty"`
}

// MFAEnrollRequestMethod MFA method to enroll
type MFAEnrollRequestMethod string

// MFAUnEnrollRequest MFA unenrollment request
type MFAUnEnrollRequest struct {
	// Method MFA method to unenroll
	Method MFAUnEnrollRequestMethod `json:"method"`
}

// MFAUnEnrollRequestMethod MFA method to unenroll
type MFAUnEnrollRequestMethod string

// MFAVerifyRequest MFA verification request
type MFAVerifyRequest struct {
	// Code Verification code
	Code string `json:"code"`

	// Method MFA method to verify
	Method MFAVerifyRequestMethod `json:"method"`

	// PhoneNumber Phone number for SMS verification
	PhoneNumber *string `json:"phone_number,omitempty"`
}

// MFAVerifyRequestMethod MFA method to verify
type MFAVerifyRequestMethod string

// MagicLinkRequest Magic link generation request
type MagicLinkRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// ExpiresIn Link expiry in seconds
	ExpiresIn *int64 `json:"expires_in,omitempty"`

	// RedirectUrl URL to redirect after authentication
	RedirectUrl string `json:"redirect_url"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// MagicLinkResponseBody defines model for MagicLinkResponseBody.
type MagicLinkResponseBody struct {
	// ExpiresIn Expiry in seconds
	ExpiresIn int64 `json:"expires_in"`

	// MagicLink Generated magic link
	MagicLink string `json:"magic_link"`
}

// MethodsResponseBody defines model for MethodsResponseBody.
type MethodsResponseBody struct {
	// Methods Enabled MFA methods
	Methods []string `json:"methods"`
}

// MethodsResponseBody2 defines model for MethodsResponseBody2.
type MethodsResponseBody2 struct {
	// Enabled Whether passwordless auth is enabled
	Enabled bool `json:"enabled"`

	// Methods Available methods
	Methods []string `json:"methods"`
}

// MetricsResponseBody defines model for MetricsResponseBody.
type MetricsResponseBody struct {
	// Errors Total error count
	Errors *int64 `json:"errors,omitempty"`

	// Goroutines Number of goroutines
	Goroutines int64 `json:"goroutines"`

	// MemoryUsage Memory usage in bytes
	MemoryUsage int64 `json:"memory_usage"`

	// RequestRate Requests per second
	RequestRate *float32 `json:"request_rate,omitempty"`

	// Requests Total request count
	Requests *int64 `json:"requests,omitempty"`

	// Uptime System uptime in seconds
	Uptime int64 `json:"uptime"`
}

// NotFoundError Not found response
type NotFoundError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// OAuthClientResponse OAuth client information
type OAuthClientResponse struct {
	// Active Whether client is active
	Active bool `json:"active"`

	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes []string `json:"allowed_grant_types"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientId OAuth client ID
	ClientId string `json:"client_id"`

	// ClientName Client name
	ClientName string `json:"client_name"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"created_at,omitempty"`

	// Id Client ID
	Id string `json:"id"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public bool `json:"public"`

	// RedirectUris Authorized redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// OAuthClientWithSecretResponse OAuth client information with client secret
type OAuthClientWithSecretResponse struct {
	// Active Whether client is active
	Active bool `json:"active"`

	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes []string `json:"allowed_grant_types"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientId OAuth client ID
	ClientId string `json:"client_id"`

	// ClientName Client name
	ClientName string `json:"client_name"`

	// ClientSecret OAuth client secret
	ClientSecret string `json:"client_secret"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"created_at,omitempty"`

	// Id Client ID
	Id string `json:"id"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public bool `json:"public"`

	// RedirectUris Authorized redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// OAuthScopeResponse OAuth scope information
type OAuthScopeResponse struct {
	// DefaultScope Whether this scope is included by default
	DefaultScope bool `json:"default_scope"`

	// Description Scope description
	Description string `json:"description"`

	// Id Scope ID
	Id string `json:"id"`

	// Name Scope name
	Name string `json:"name"`

	// Public Whether this scope can be requested by any client
	Public bool `json:"public"`
}

// OidcConfigurationResponseBody defines model for OidcConfigurationResponseBody.
type OidcConfigurationResponseBody struct {
	AuthorizationEndpoint             string    `json:"authorization_endpoint"`
	ClaimsSupported                   *[]string `json:"claims_supported,omitempty"`
	GrantTypesSupported               *[]string `json:"grant_types_supported,omitempty"`
	IdTokenSigningAlgValuesSupported  *[]string `json:"id_token_signing_alg_values_supported,omitempty"`
	Issuer                            string    `json:"issuer"`
	JwksUri                           string    `json:"jwks_uri"`
	RegistrationEndpoint              *string   `json:"registration_endpoint,omitempty"`
	ResponseModesSupported            *[]string `json:"response_modes_supported,omitempty"`
	ResponseTypesSupported            *[]string `json:"response_types_supported,omitempty"`
	ScopesSupported                   *[]string `json:"scopes_supported,omitempty"`
	SubjectTypesSupported             *[]string `json:"subject_types_supported,omitempty"`
	TokenEndpoint                     string    `json:"token_endpoint"`
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
	UserinfoEndpoint                  string    `json:"userinfo_endpoint"`
}

// Organization Organization information
type Organization struct {
	// Active Whether organization is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Domain Organization domain
	Domain *string `json:"domain,omitempty"`

	// Id Organization ID
	Id string `json:"id"`

	// LogoUrl Organization logo URL
	LogoUrl *string `json:"logo_url,omitempty"`

	// Metadata Organization metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Organization name
	Name string `json:"name"`

	// Plan Organization plan
	Plan *string `json:"plan,omitempty"`

	// Settings Organization information
	Settings *OrganizationSettings `json:"settings,omitempty"`

	// Slug Organization slug
	Slug string `json:"slug"`

	// TrialEndsAt Trial end date
	TrialEndsAt *string `json:"trial_ends_at,omitempty"`

	// TrialUsed Whether trial has been used
	TrialUsed *bool `json:"trial_used,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt string `json:"updated_at"`
}

// OrganizationFeatureResponse Organization feature information
type OrganizationFeatureResponse struct {
	// Component Feature component category
	Component *string `json:"component,omitempty"`

	// Description Feature description
	Description *string `json:"description,omitempty"`

	// Enabled Whether feature is enabled
	Enabled bool `json:"enabled"`

	// Id Feature ID
	Id string `json:"id"`

	// IsPremium Whether feature is premium
	IsPremium *bool `json:"is_premium,omitempty"`

	// Key Feature key
	Key string `json:"key"`

	// Name Feature name
	Name string `json:"name"`

	// Settings Feature settings
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// OrganizationMemberResponse Organization member information
type OrganizationMemberResponse struct {
	// Email User email
	Email string `json:"email"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// Id User ID
	Id string `json:"id"`

	// JoinedAt When user joined the organization
	JoinedAt string `json:"joined_at"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Roles User roles in organization
	Roles []string `json:"roles"`
}

// OrganizationSettings Organization information
type OrganizationSettings struct {
	// SignupFields Signup fields
	SignupFields *[]FormField `json:"signupFields,omitempty"`

	// Verification Signup fields
	Verification *[]OrganizationVerificationConfig `json:"verification,omitempty"`
}

// OrganizationVerificationConfig Configuration for organization verification
type OrganizationVerificationConfig struct {
	// CodeLength Length of verification code
	CodeLength *int64 `json:"code_length,omitempty"`

	// Method Method used for verification
	Method *OrganizationVerificationConfigMethod `json:"method,omitempty"`
}

// OrganizationVerificationConfigMethod Method used for verification
type OrganizationVerificationConfigMethod string

// Pagination Pagination parameters
type Pagination struct {
	// CurrentPage Current page number
	CurrentPage int64 `json:"current_page"`

	// HasNext Has next page
	HasNext bool `json:"has_next"`

	// HasPrevious Has previous page
	HasPrevious bool `json:"has_previous"`

	// Limit Limit
	Limit int64 `json:"limit"`

	// Offset Offset
	Offset int64 `json:"offset"`

	// Total Total number of items
	Total int64 `json:"total"`

	// TotalPages Total number of pages
	TotalPages int64 `json:"total_pages"`
}

// PasskeyLoginCompleteRequest Complete passkey authentication request
type PasskeyLoginCompleteRequest struct {
	// Response WebAuthn assertion response
	Response interface{} `json:"response"`

	// SessionId Authentication session ID
	SessionId string `json:"session_id"`
}

// PasskeyRegisterBeginRequest Begin passkey registration request
type PasskeyRegisterBeginRequest struct {
	// DeviceName Name of the device
	DeviceName *string `json:"device_name,omitempty"`

	// DeviceType Type of the device
	DeviceType *string `json:"device_type,omitempty"`
}

// PasskeyRegisterCompleteRequest Complete passkey registration request
type PasskeyRegisterCompleteRequest struct {
	// DeviceName Name of the device
	DeviceName *string `json:"device_name,omitempty"`

	// DeviceType Type of the device
	DeviceType *string `json:"device_type,omitempty"`

	// Response WebAuthn credential creation response
	Response interface{} `json:"response"`

	// SessionId Registration session ID
	SessionId string `json:"session_id"`
}

// PasswordlessEmailRequest Passwordless email login request
type PasswordlessEmailRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// RedirectUrl URL to redirect after successful authentication
	RedirectUrl *string `json:"redirect_url,omitempty"`
}

// PasswordlessSMSRequest Passwordless SMS login request
type PasswordlessSMSRequest struct {
	// PhoneNumber User phone number
	PhoneNumber string `json:"phone_number"`

	// RedirectUrl URL to redirect after successful authentication
	RedirectUrl *string `json:"redirect_url,omitempty"`
}

// PasswordlessVerifyRequest Passwordless verification request
type PasswordlessVerifyRequest struct {
	// AuthType Authentication type
	AuthType PasswordlessVerifyRequestAuthType `json:"auth_type"`

	// Code Verification code for SMS authentication
	Code *string `json:"code,omitempty"`

	// PhoneNumber Phone number for SMS authentication
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Token Verification token for email authentication
	Token *string `json:"token,omitempty"`
}

// PasswordlessVerifyRequestAuthType Authentication type
type PasswordlessVerifyRequestAuthType string

// PermissionResponse Permission information
type PermissionResponse struct {
	// Action Action this permission allows
	Action string `json:"action"`

	// Conditions JSON expression for conditional access
	Conditions *string `json:"conditions,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Description Permission description
	Description string `json:"description"`

	// Id Permission ID
	Id string `json:"id"`

	// Name Permission name
	Name string `json:"name"`

	// Resource Resource this permission applies to
	Resource string `json:"resource"`

	// System Whether this is a system permission
	System bool `json:"system"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// ProviderCallbackResponseBody defines model for ProviderCallbackResponseBody.
type ProviderCallbackResponseBody struct {
	// Authenticated Whether authentication was successful
	Authenticated bool `json:"authenticated"`

	// Message Success or error message
	Message string `json:"message"`

	// User User information
	User *User `json:"user,omitempty"`
}

// ReadyResponse Readiness check response
type ReadyResponse struct {
	// Status Readiness status
	Status ReadyResponseStatus `json:"status"`

	// Timestamp Timestamp of health check
	Timestamp time.Time `json:"timestamp"`
}

// ReadyResponseStatus Readiness status
type ReadyResponseStatus string

// RefreshTokenRequest Refresh token request
type RefreshTokenRequest struct {
	// RefreshToken JWTAuth refresh token
	RefreshToken string `json:"refresh_token"`
}

// RefreshTokenResponse Refresh token response
type RefreshTokenResponse struct {
	// ExpiresAt Token expiry timestamp
	ExpiresAt int64 `json:"expires_at"`

	// RefreshToken New refresh token
	RefreshToken string `json:"refresh_token"`

	// Token New JWTAuth access token
	Token string `json:"token"`
}

// RegisterBeginResponseBody defines model for RegisterBeginResponseBody.
type RegisterBeginResponseBody struct {
	// Options WebAuthn credential creation options
	Options interface{} `json:"options"`

	// SessionId Registration session ID
	SessionId string `json:"session_id"`
}

// RegisterRequest User registration data
type RegisterRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Metadata Additional user metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID if creating a user for a specific organization
	OrganizationId *string `json:"organization_id,omitempty"`

	// Password User password
	Password string `json:"password"`
}

// RegisteredPasskey Registered passkey information
type RegisteredPasskey struct {
	// DeviceType Device type
	DeviceType string `json:"device_type"`

	// Id Passkey ID
	Id string `json:"id"`

	// LastUsed Last usage timestamp
	LastUsed *string `json:"last_used,omitempty"`

	// Name Passkey name
	Name string `json:"name"`

	// RegisteredAt Registration timestamp
	RegisteredAt string `json:"registered_at"`
}

// ResetPasswordRequest Reset password request
type ResetPasswordRequest struct {
	// NewPassword New password
	NewPassword string `json:"new_password"`

	// Token Password reset token
	Token string `json:"token"`
}

// RoleResponse Role information
type RoleResponse struct {
	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Description Role description
	Description *string `json:"description,omitempty"`

	// Id Role ID
	Id string `json:"id"`

	// IsDefault Whether this is a default role for new users
	IsDefault bool `json:"is_default"`

	// Name Role name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Permissions Permissions assigned to this role
	Permissions *[]PermissionResponse `json:"permissions,omitempty"`

	// System Whether this is a system role
	System bool `json:"system"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// RotateClientSecretResponseBody defines model for RotateClientSecretResponseBody.
type RotateClientSecretResponseBody struct {
	ClientId     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
}

// SSOProvider SSO Provider information
type SSOProvider struct {
	// IconUrl Provider icon URL
	IconUrl *string `json:"icon_url,omitempty"`

	// Id Provider ID
	Id string `json:"id"`

	// Name Provider name
	Name string `json:"name"`

	// Type Provider type (oauth2, oidc, saml)
	Type string `json:"type"`
}

// SamlMetadataResponseBody defines model for SamlMetadataResponseBody.
type SamlMetadataResponseBody struct {
	// Metadata SAML metadata XML
	Metadata string `json:"metadata"`
}

// SendCodeRequestBody defines model for SendCodeRequestBody.
type SendCodeRequestBody struct {
	// Request Send MFA code request
	Request SendMFACodeRequest `json:"request"`
}

// SendEmailRequest Send email request
type SendEmailRequest struct {
	// Bcc BCC recipients
	Bcc *[]string `json:"bcc,omitempty"`

	// Cc CC recipients
	Cc *[]string `json:"cc,omitempty"`

	// From Sender email
	From *string `json:"from,omitempty"`

	// Headers Custom headers
	Headers *map[string]string `json:"headers,omitempty"`

	// HtmlContent HTML content
	HtmlContent *string `json:"html_content,omitempty"`

	// Metadata Email metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ReplyTo Reply-to address
	ReplyTo *string `json:"reply_to,omitempty"`

	// Subject Email subject
	Subject string `json:"subject"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`

	// To Recipients
	To []string `json:"to"`
}

// SendEmailVerificationRequestBody defines model for SendEmailVerificationRequestBody.
type SendEmailVerificationRequestBody struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// Method Verification method (link or otp)
	Method *SendEmailVerificationRequestBodyMethod `json:"method,omitempty"`
}

// SendEmailVerificationRequestBodyMethod Verification method (link or otp)
type SendEmailVerificationRequestBodyMethod string

// SendEmailVerificationResponseBody defines model for SendEmailVerificationResponseBody.
type SendEmailVerificationResponseBody struct {
	// ExpiresAt When the verification code/link expires
	ExpiresAt int64 `json:"expires_at"`

	// Message Success message
	Message string `json:"message"`
}

// SendMFACodeRequest Send MFA code request
type SendMFACodeRequest struct {
	// Method MFA method
	Method SendMFACodeRequestMethod `json:"method"`
}

// SendMFACodeRequestMethod MFA method
type SendMFACodeRequestMethod string

// SendResponseBody defines model for SendResponseBody.
type SendResponseBody struct {
	// Message Success message
	Message string `json:"message"`
}

// SendTemplateEmailRequest Send template email request
type SendTemplateEmailRequest struct {
	// Bcc BCC recipients
	Bcc *[]string `json:"bcc,omitempty"`

	// Cc CC recipients
	Cc *[]string `json:"cc,omitempty"`

	// From Sender email
	From *string `json:"from,omitempty"`

	// Headers Custom headers
	Headers *map[string]string `json:"headers,omitempty"`

	// Locale Template locale
	Locale *string `json:"locale,omitempty"`

	// Metadata Email metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// ReplyTo Reply-to address
	ReplyTo *string `json:"reply_to,omitempty"`

	// Subject Custom subject (overrides template subject)
	Subject *string `json:"subject,omitempty"`

	// TemplateData Template data
	TemplateData map[string]interface{} `json:"template_data"`

	// TemplateType Template type
	TemplateType string `json:"template_type"`

	// To Recipients
	To []string `json:"to"`
}

// Session User session information
type Session struct {
	// CreatedAt Created At
	CreatedAt time.Time `json:"created_at"`

	// DeviceId Device ID
	DeviceId *string `json:"device_id,omitempty"`

	// ExpiresAt Expiry timestamp
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID of the entity
	Id string `json:"id"`

	// IpAddress IP address
	IpAddress *string `json:"ip_address,omitempty"`

	// IsActive Session is active
	IsActive *bool `json:"is_active,omitempty"`

	// LastActiveAt Last activity timestamp
	LastActiveAt *time.Time `json:"last_active_at,omitempty"`

	// Location Location
	Location *string `json:"location,omitempty"`

	// Metadata Session metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Token Session token
	Token *string `json:"token,omitempty"`

	// UpdatedAt Updated At
	UpdatedAt time.Time `json:"updated_at"`

	// UserAgent User agent string
	UserAgent *string `json:"user_agent,omitempty"`

	// UserId User ID
	UserId *string `json:"user_id,omitempty"`
}

// TOTPEnrollResponse TOTP enrollment response
type TOTPEnrollResponse struct {
	// QrCodeData TOTP QR code as base64 image
	QrCodeData string `json:"qr_code_data"`

	// Secret TOTP secret key
	Secret string `json:"secret"`

	// Uri TOTP URI for QR code generation
	Uri string `json:"uri"`
}

// TokenResponseBody defines model for TokenResponseBody.
type TokenResponseBody struct {
	// AccessToken Access token
	AccessToken string `json:"access_token"`

	// ExpiresIn Token expiry in seconds
	ExpiresIn int64 `json:"expires_in"`

	// RefreshToken Refresh token
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope Granted scopes
	Scope *string `json:"scope,omitempty"`

	// TokenType Token type
	TokenType string `json:"token_type"`
}

// TriggerEventRequest Trigger webhook event request
type TriggerEventRequest struct {
	// EventType Event type
	EventType string `json:"event_type"`

	// Headers Custom headers
	Headers *map[string]string `json:"headers,omitempty"`

	// Payload Event payload
	Payload interface{} `json:"payload"`
}

// TriggerEventRequestBody defines model for TriggerEventRequestBody.
type TriggerEventRequestBody struct {
	// Event Trigger webhook event request
	Event TriggerEventRequest `json:"event"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`
}

// UnauthorizedError Unauthorized response
type UnauthorizedError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// UnenrollRequestBody defines model for UnenrollRequestBody.
type UnenrollRequestBody struct {
	// Request MFA unenrollment request
	Request MFAUnEnrollRequest `json:"request"`
}

// UpdateAPIKeyRequest Update API key request
type UpdateAPIKeyRequest struct {
	// Active Whether API key is active
	Active *bool `json:"active,omitempty"`

	// ExpiresAt Expiry timestamp
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name *string `json:"name,omitempty"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`
}

// UpdateClientRequestBody defines model for UpdateClientRequestBody.
type UpdateClientRequestBody struct {
	// Client Update OAuth client request
	Client UpdateOAuthClientRequest `json:"client"`
}

// UpdateEmailTemplateRequest Update email template request
type UpdateEmailTemplateRequest struct {
	// Active Whether template is active
	Active *bool `json:"active,omitempty"`

	// HtmlContent HTML content
	HtmlContent *string `json:"html_content,omitempty"`

	// Locale Template locale
	Locale *string `json:"locale,omitempty"`

	// Metadata Template metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Template name
	Name *string `json:"name,omitempty"`

	// Subject Email subject
	Subject *string `json:"subject,omitempty"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`
}

// UpdateIdentityProviderRequest Update identity provider request
type UpdateIdentityProviderRequest struct {
	// Active Whether provider is active
	Active *bool `json:"active,omitempty"`

	// AttributesMapping Attributes mapping
	AttributesMapping *map[string]string `json:"attributes_mapping,omitempty"`

	// AuthorizationEndpoint OAuth/OIDC authorization endpoint
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// Certificate SAML certificate
	Certificate *string `json:"certificate,omitempty"`

	// ClientId OAuth/OIDC client ID
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret OAuth/OIDC client secret
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domains Allowed email domains
	Domains *[]string `json:"domains,omitempty"`

	// Issuer OIDC issuer URL
	Issuer *string `json:"issuer,omitempty"`

	// JwksUri OIDC JWKS URI
	JwksUri *string `json:"jwks_uri,omitempty"`

	// MetadataUrl SAML metadata URL
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Provider name
	Name *string `json:"name,omitempty"`

	// Primary Whether this is the primary provider
	Primary *bool `json:"primary,omitempty"`

	// PrivateKey SAML private key
	PrivateKey *string `json:"private_key,omitempty"`

	// RedirectUri OAuth/OIDC redirect URI
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// TokenEndpoint OAuth/OIDC token endpoint
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// UserinfoEndpoint OIDC userinfo endpoint
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
}

// UpdateIdentityProviderRequestBody defines model for UpdateIdentityProviderRequestBody.
type UpdateIdentityProviderRequestBody struct {
	// Provider Update identity provider request
	Provider UpdateIdentityProviderRequest `json:"provider"`
}

// UpdateMemberRequestBody defines model for UpdateMemberRequestBody.
type UpdateMemberRequestBody struct {
	// Member Update organization member request
	Member UpdateOrganizationMemberRequest `json:"member"`
}

// UpdateOAuthClientRequest Update OAuth client request
type UpdateOAuthClientRequest struct {
	// Active Whether client is active
	Active *bool `json:"active,omitempty"`

	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes *[]string `json:"allowed_grant_types,omitempty"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientName Client name
	ClientName *string `json:"client_name,omitempty"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public *bool `json:"public,omitempty"`

	// RedirectUris Authorized redirect URIs
	RedirectUris *[]string `json:"redirect_uris,omitempty"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`
}

// UpdateOrganizationMemberRequest Update organization member request
type UpdateOrganizationMemberRequest struct {
	// Roles Roles to assign
	Roles []string `json:"roles"`
}

// UpdateOrganizationRequest Update organization request
type UpdateOrganizationRequest struct {
	// Active Whether organization is active
	Active *bool `json:"active,omitempty"`

	// Domain Organization domain
	Domain *string `json:"domain,omitempty"`

	// LogoUrl Organization logo URL
	LogoUrl *string `json:"logo_url,omitempty"`

	// Metadata Organization metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Organization name
	Name *string `json:"name,omitempty"`

	// Plan Organization plan
	Plan *string `json:"plan,omitempty"`
}

// UpdatePasskeyRequest Update passkey request
type UpdatePasskeyRequest struct {
	// Name New passkey name
	Name string `json:"name"`
}

// UpdatePasswordRequest Update password request
type UpdatePasswordRequest struct {
	// CurrentPassword Current password
	CurrentPassword string `json:"current_password"`

	// NewPassword New password
	NewPassword string `json:"new_password"`
}

// UpdatePermissionRequest Update permission request
type UpdatePermissionRequest struct {
	// Conditions JSON expression for conditional access
	Conditions *string `json:"conditions,omitempty"`

	// Description Permission description
	Description *string `json:"description,omitempty"`

	// Name Permission name
	Name *string `json:"name,omitempty"`
}

// UpdatePermissionRequestBody defines model for UpdatePermissionRequestBody.
type UpdatePermissionRequestBody struct {
	// Permission Update permission request
	Permission UpdatePermissionRequest `json:"permission"`
}

// UpdateRequestBody defines model for UpdateRequestBody.
type UpdateRequestBody struct {
	// Key Update API key request
	Key UpdateAPIKeyRequest `json:"key"`
}

// UpdateRequestBody2 defines model for UpdateRequestBody2.
type UpdateRequestBody2 struct {
	// Organization Update organization request
	Organization UpdateOrganizationRequest `json:"organization"`
}

// UpdateRequestBody3 defines model for UpdateRequestBody3.
type UpdateRequestBody3 struct {
	// Request Update passkey request
	Request UpdatePasskeyRequest `json:"request"`
}

// UpdateRequestBody4 defines model for UpdateRequestBody4.
type UpdateRequestBody4 struct {
	// User Update user request
	User UpdateUserRequest `json:"user"`
}

// UpdateRequestBody5 defines model for UpdateRequestBody5.
type UpdateRequestBody5 struct {
	// Webhook Update webhook request
	Webhook UpdateWebhookRequest `json:"webhook"`
}

// UpdateRoleRequest Update role request
type UpdateRoleRequest struct {
	// Description Role description
	Description *string `json:"description,omitempty"`

	// IsDefault Whether this is a default role for new users
	IsDefault *bool `json:"is_default,omitempty"`

	// Name Role name
	Name *string `json:"name,omitempty"`
}

// UpdateRoleRequestBody defines model for UpdateRoleRequestBody.
type UpdateRoleRequestBody struct {
	// Role Update role request
	Role UpdateRoleRequest `json:"role"`
}

// UpdateScopeRequestBody defines model for UpdateScopeRequestBody.
type UpdateScopeRequestBody struct {
	// DefaultScope Whether this scope is included by default
	DefaultScope *bool `json:"default_scope,omitempty"`

	// Description Scope description
	Description *string `json:"description,omitempty"`

	// Public Whether this scope can be requested by any client
	Public *bool `json:"public,omitempty"`
}

// UpdateTemplateRequestBody defines model for UpdateTemplateRequestBody.
type UpdateTemplateRequestBody struct {
	// Template Update email template request
	Template UpdateEmailTemplateRequest `json:"template"`
}

// UpdateUserRequest Update user request
type UpdateUserRequest struct {
	// Active Whether user is active
	Active *bool `json:"active,omitempty"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Locale User locale
	Locale *string `json:"locale,omitempty"`

	// Metadata User metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PhoneNumber User phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PrimaryOrganizationId Primary organization ID
	PrimaryOrganizationId *string `json:"primary_organization_id,omitempty"`

	// ProfileImageUrl Profile image URL
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`
}

// UpdateWebhookRequest Update webhook request
type UpdateWebhookRequest struct {
	// Active Whether webhook is active
	Active *bool `json:"active,omitempty"`

	// EventTypes Event types to subscribe to
	EventTypes *[]string `json:"event_types,omitempty"`

	// Format Payload format
	Format *UpdateWebhookRequestFormat `json:"format,omitempty"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name *string `json:"name,omitempty"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// Url Webhook URL
	Url *string `json:"url,omitempty"`
}

// UpdateWebhookRequestFormat Payload format
type UpdateWebhookRequestFormat string

// User User information
type User struct {
	// Active Whether account is active
	Active bool `json:"active"`

	// Email Email address
	Email openapi_types.Email `json:"email"`

	// EmailVerified Whether email is verified
	EmailVerified bool `json:"email_verified"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// Id ID of the entity
	Id string `json:"id"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Locale User locale
	Locale *string `json:"locale,omitempty"`

	// Metadata User metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PhoneNumber User phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PhoneVerified Whether phone is verified
	PhoneVerified *bool `json:"phone_verified,omitempty"`

	// ProfileImageUrl URL to user's profile image
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`
}

// UserinfoResponseBody defines model for UserinfoResponseBody.
type UserinfoResponseBody struct {
	// Birthdate Birth date
	Birthdate *string `json:"birthdate,omitempty"`

	// Email Email address
	Email *string `json:"email,omitempty"`

	// EmailVerified Whether email is verified
	EmailVerified *bool `json:"email_verified,omitempty"`

	// FamilyName Last name
	FamilyName *string `json:"family_name,omitempty"`

	// Gender Gender
	Gender *string `json:"gender,omitempty"`

	// GivenName First name
	GivenName *string `json:"given_name,omitempty"`

	// Locale Locale
	Locale *string `json:"locale,omitempty"`

	// MiddleName Middle name
	MiddleName *string `json:"middle_name,omitempty"`

	// Name Full name
	Name *string `json:"name,omitempty"`

	// Nickname Nickname
	Nickname *string `json:"nickname,omitempty"`

	// PhoneNumber Phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PhoneNumberVerified Whether phone number is verified
	PhoneNumberVerified *bool `json:"phone_number_verified,omitempty"`

	// Picture Picture URL
	Picture *string `json:"picture,omitempty"`

	// PreferredUsername Preferred username
	PreferredUsername *string `json:"preferred_username,omitempty"`

	// Profile Profile URL
	Profile *string `json:"profile,omitempty"`

	// Sub Subject (user ID)
	Sub string `json:"sub"`

	// UpdatedAt Last update timestamp
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// Website Website URL
	Website *string `json:"website,omitempty"`

	// Zoneinfo Time zone
	Zoneinfo *string `json:"zoneinfo,omitempty"`
}

// ValidateResponseBody defines model for ValidateResponseBody.
type ValidateResponseBody struct {
	// Key API key information without the actual key
	Key *APIKeyResponse `json:"key,omitempty"`

	// Valid Whether key is valid
	Valid bool `json:"valid"`
}

// VerifyEmailRequest Email verification request
type VerifyEmailRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// Method Verification method (link or otp)
	Method VerifyEmailRequestMethod `json:"method"`

	// Otp One-time password for OTP verification
	Otp *string `json:"otp,omitempty"`

	// Token Email verification token for link verification
	Token *string `json:"token,omitempty"`
}

// VerifyEmailRequestMethod Verification method (link or otp)
type VerifyEmailRequestMethod string

// VerifyRequestBody defines model for VerifyRequestBody.
type VerifyRequestBody struct {
	// Request MFA verification request
	Request MFAVerifyRequest `json:"request"`
}

// VerifyResponseBody defines model for VerifyResponseBody.
type VerifyResponseBody struct {
	// Authenticated Whether authentication was successful
	Authenticated bool `json:"authenticated"`

	// Email User email
	Email *string `json:"email,omitempty"`

	// User User information
	User *User `json:"user,omitempty"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// VersionResponseBody defines model for VersionResponseBody.
type VersionResponseBody struct {
	// BuildDate Build date
	BuildDate time.Time `json:"build_date"`

	// GitCommit Git commit hash
	GitCommit *string `json:"git_commit,omitempty"`

	// GoVersion Go version
	GoVersion *string `json:"go_version,omitempty"`

	// Version System version
	Version string `json:"version"`
}

// WebhookEventResponse Webhook event information
type WebhookEventResponse struct {
	// Attempts Number of delivery attempts
	Attempts int64 `json:"attempts"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Delivered Whether event was delivered
	Delivered bool `json:"delivered"`

	// DeliveredAt Delivery timestamp
	DeliveredAt *string `json:"delivered_at,omitempty"`

	// Error Error from last attempt
	Error *string `json:"error,omitempty"`

	// EventType Event type
	EventType string `json:"event_type"`

	// Headers Event headers
	Headers *map[string]string `json:"headers,omitempty"`

	// Id Event ID
	Id string `json:"id"`

	// NextRetry Next retry timestamp
	NextRetry *string `json:"next_retry,omitempty"`

	// Payload Event payload
	Payload *interface{} `json:"payload,omitempty"`

	// ResponseBody Response from last attempt
	ResponseBody *string `json:"response_body,omitempty"`

	// StatusCode HTTP status code from last attempt
	StatusCode *int64 `json:"status_code,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// WebhookId Webhook ID
	WebhookId string `json:"webhook_id"`
}

// WebhookResponse Webhook information
type WebhookResponse struct {
	// Active Whether webhook is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// EventTypes Event types webhook subscribes to
	EventTypes []string `json:"event_types"`

	// Format Payload format (json/form)
	Format *string `json:"format,omitempty"`

	// Id Webhook ID
	Id string `json:"id"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Url Webhook URL
	Url string `json:"url"`

	// Version Webhook version
	Version *string `json:"version,omitempty"`
}

// WebhookSecretResponse Webhook creation response with secret
type WebhookSecretResponse struct {
	// Active Whether webhook is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// EventTypes Event types webhook subscribes to
	EventTypes []string `json:"event_types"`

	// Format Payload format (json/form)
	Format *string `json:"format,omitempty"`

	// Id Webhook ID
	Id string `json:"id"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// Secret Webhook secret for signature verification
	Secret string `json:"secret"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Url Webhook URL
	Url string `json:"url"`

	// Version Webhook version
	Version *string `json:"version,omitempty"`
}

// RbacCheckPermissionParams defines parameters for RbacCheckPermission.
type RbacCheckPermissionParams struct {
	// Resource Resource to check
	Resource string `form:"resource" json:"resource"`

	// Action Action to check
	Action string `form:"action" json:"action"`
}

// RbacCheckRoleParams defines parameters for RbacCheckRole.
type RbacCheckRoleParams struct {
	// Role Role name to check
	Role string `form:"role" json:"role"`

	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// ApiKeysListParams defines parameters for ApiKeysList.
type ApiKeysListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Type Filter by key type
	Type *ApiKeysListParamsType `form:"type,omitempty" json:"type,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// ApiKeysListParamsType defines parameters for ApiKeysList.
type ApiKeysListParamsType string

// ApiKeysValidateParams defines parameters for ApiKeysValidate.
type ApiKeysValidateParams struct {
	// ApiKey API key to validate
	ApiKey string `form:"api_key" json:"api_key"`
}

// AuthCheckEmailVerificationParams defines parameters for AuthCheckEmailVerification.
type AuthCheckEmailVerificationParams struct {
	// Email User email
	Email    openapi_types.Email `form:"email" json:"email"`
	FrankSid *string             `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthCsrfParams defines parameters for AuthCsrf.
type AuthCsrfParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthForgotPasswordParams defines parameters for AuthForgotPassword.
type AuthForgotPasswordParams struct {
	// RedirectUrl URL to redirect after password reset
	RedirectUrl *string `form:"redirect_url,omitempty" json:"redirect_url,omitempty"`
	FrankSid    *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthLoginParams defines parameters for AuthLogin.
type AuthLoginParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthLogoutParams defines parameters for AuthLogout.
type AuthLogoutParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthMeParams defines parameters for AuthMe.
type AuthMeParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// OauthClientProviderCallbackParams defines parameters for OauthClientProviderCallback.
type OauthClientProviderCallbackParams struct {
	// Code Authorization code
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// State State parameter
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// OauthClientProviderAuthParams defines parameters for OauthClientProviderAuth.
type OauthClientProviderAuthParams struct {
	// RedirectUri Redirect URI after authentication
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
}

// AuthRefreshTokenParams defines parameters for AuthRefreshToken.
type AuthRefreshTokenParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthRegisterParams defines parameters for AuthRegister.
type AuthRegisterParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthResetPasswordParams defines parameters for AuthResetPassword.
type AuthResetPasswordParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthSendEmailVerificationParams defines parameters for AuthSendEmailVerification.
type AuthSendEmailVerificationParams struct {
	// RedirectUrl URL to redirect after verification (for link verification)
	RedirectUrl *string `form:"redirect_url,omitempty" json:"redirect_url,omitempty"`
	FrankSid    *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// SsoProviderCallbackParams defines parameters for SsoProviderCallback.
type SsoProviderCallbackParams struct {
	// Code Authorization code
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// State State parameter
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// SAMLResponse SAML response
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`

	// RelayState SAML relay state
	RelayState *string `form:"RelayState,omitempty" json:"RelayState,omitempty"`
}

// SsoListIdentityProvidersParams defines parameters for SsoListIdentityProviders.
type SsoListIdentityProvidersParams struct {
	// OrganizationId Organization ID
	OrganizationId string `form:"organization_id" json:"organization_id"`
}

// SsoListProvidersParams defines parameters for SsoListProviders.
type SsoListProvidersParams struct {
	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// SsoProviderAuthParams defines parameters for SsoProviderAuth.
type SsoProviderAuthParams struct {
	// RedirectUri Redirect URI after authentication
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
}

// AuthVerifyEmailParams defines parameters for AuthVerifyEmail.
type AuthVerifyEmailParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// EmailListTemplatesParams defines parameters for EmailListTemplates.
type EmailListTemplatesParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Type Filter by template type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Locale Filter by locale
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// EmailGetTemplateByTypeParams defines parameters for EmailGetTemplateByType.
type EmailGetTemplateByTypeParams struct {
	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Locale Template locale
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// OauthProviderAuthorizeParams defines parameters for OauthProviderAuthorize.
type OauthProviderAuthorizeParams struct {
	// ClientId OAuth client identifier
	ClientId string `form:"client_id" json:"client_id"`

	// ResponseType OAuth response type
	ResponseType string `form:"response_type" json:"response_type"`

	// RedirectUri Redirect URI after authorization
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// Scope Requested scopes (space-separated)
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// State OAuth state parameter
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// CodeChallenge PKCE code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod PKCE code challenge method
	CodeChallengeMethod *string `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`
}

// OauthProviderListClientsParams defines parameters for OauthProviderListClients.
type OauthProviderListClientsParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// OauthProviderIntrospectParams defines parameters for OauthProviderIntrospect.
type OauthProviderIntrospectParams struct {
	// Token Token to introspect
	Token string `form:"token" json:"token"`

	// TokenTypeHint Token type hint
	TokenTypeHint *string `form:"token_type_hint,omitempty" json:"token_type_hint,omitempty"`
}

// OauthProviderRevokeParams defines parameters for OauthProviderRevoke.
type OauthProviderRevokeParams struct {
	// Token Token to revoke
	Token string `form:"token" json:"token"`

	// TokenTypeHint Token type hint
	TokenTypeHint *string `form:"token_type_hint,omitempty" json:"token_type_hint,omitempty"`

	// ClientId Client ID
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// ClientSecret Client secret
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty"`
}

// OauthProviderListScopesParams defines parameters for OauthProviderListScopes.
type OauthProviderListScopesParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// OauthProviderTokenParams defines parameters for OauthProviderToken.
type OauthProviderTokenParams struct {
	// GrantType Grant type
	GrantType string `form:"grant_type" json:"grant_type"`

	// Code Authorization code (for authorization_code grant)
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// RedirectUri Redirect URI (for authorization_code grant)
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// ClientId Client ID
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// ClientSecret Client secret
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty"`

	// RefreshToken Refresh token (for refresh_token grant)
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`

	// CodeVerifier PKCE code verifier (for authorization_code grant)
	CodeVerifier *string `form:"code_verifier,omitempty" json:"code_verifier,omitempty"`

	// Username Resource owner username (for password grant)
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Password Resource owner password (for password grant)
	Password *string `form:"password,omitempty" json:"password,omitempty"`

	// Scope Requested scopes (space-separated)
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`
}

// OrganizationsListParams defines parameters for OrganizationsList.
type OrganizationsListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// OrganizationsListMembersParams defines parameters for OrganizationsListMembers.
type OrganizationsListMembersParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// RbacListPermissionsParams defines parameters for RbacListPermissions.
type RbacListPermissionsParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Resource Filter by resource
	Resource *string `form:"resource,omitempty" json:"resource,omitempty"`

	// Action Filter by action
	Action *string `form:"action,omitempty" json:"action,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// RbacListRolesParams defines parameters for RbacListRoles.
type RbacListRolesParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// UsersListParams defines parameters for UsersList.
type UsersListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// WebhooksListParams defines parameters for WebhooksList.
type WebhooksListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// EventTypes Filter by event types
	EventTypes *[]string `form:"event_types,omitempty" json:"event_types,omitempty"`
}

// WebhooksListEventsParams defines parameters for WebhooksListEvents.
type WebhooksListEventsParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventType Filter by event type
	EventType *string `form:"event_type,omitempty" json:"event_type,omitempty"`

	// Delivered Filter by delivery status
	Delivered *bool `form:"delivered,omitempty" json:"delivered,omitempty"`
}

// ApiKeysCreateJSONRequestBody defines body for ApiKeysCreate for application/json ContentType.
type ApiKeysCreateJSONRequestBody = CreateRequestBody

// ApiKeysUpdateJSONRequestBody defines body for ApiKeysUpdate for application/json ContentType.
type ApiKeysUpdateJSONRequestBody = UpdateRequestBody

// AuthForgotPasswordJSONRequestBody defines body for AuthForgotPassword for application/json ContentType.
type AuthForgotPasswordJSONRequestBody = ForgotPasswordRequest

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody = LoginRequest

// MfaEnrollJSONRequestBody defines body for MfaEnroll for application/json ContentType.
type MfaEnrollJSONRequestBody = EnrollRequestBody

// MfaSendCodeJSONRequestBody defines body for MfaSendCode for application/json ContentType.
type MfaSendCodeJSONRequestBody = SendCodeRequestBody

// MfaUnenrollJSONRequestBody defines body for MfaUnenroll for application/json ContentType.
type MfaUnenrollJSONRequestBody = UnenrollRequestBody

// MfaVerifyJSONRequestBody defines body for MfaVerify for application/json ContentType.
type MfaVerifyJSONRequestBody = VerifyRequestBody

// PasskeysLoginCompleteJSONRequestBody defines body for PasskeysLoginComplete for application/json ContentType.
type PasskeysLoginCompleteJSONRequestBody = PasskeyLoginCompleteRequest

// PasskeysRegisterBeginJSONRequestBody defines body for PasskeysRegisterBegin for application/json ContentType.
type PasskeysRegisterBeginJSONRequestBody = PasskeyRegisterBeginRequest

// PasskeysRegisterCompleteJSONRequestBody defines body for PasskeysRegisterComplete for application/json ContentType.
type PasskeysRegisterCompleteJSONRequestBody = PasskeyRegisterCompleteRequest

// PasskeysUpdateJSONRequestBody defines body for PasskeysUpdate for application/json ContentType.
type PasskeysUpdateJSONRequestBody = UpdateRequestBody3

// PasswordlessEmailJSONRequestBody defines body for PasswordlessEmail for application/json ContentType.
type PasswordlessEmailJSONRequestBody = PasswordlessEmailRequest

// PasswordlessMagicLinkJSONRequestBody defines body for PasswordlessMagicLink for application/json ContentType.
type PasswordlessMagicLinkJSONRequestBody = MagicLinkRequest

// PasswordlessSmsJSONRequestBody defines body for PasswordlessSms for application/json ContentType.
type PasswordlessSmsJSONRequestBody = PasswordlessSMSRequest

// PasswordlessVerifyJSONRequestBody defines body for PasswordlessVerify for application/json ContentType.
type PasswordlessVerifyJSONRequestBody = PasswordlessVerifyRequest

// AuthRefreshTokenJSONRequestBody defines body for AuthRefreshToken for application/json ContentType.
type AuthRefreshTokenJSONRequestBody = RefreshTokenRequest

// AuthRegisterJSONRequestBody defines body for AuthRegister for application/json ContentType.
type AuthRegisterJSONRequestBody = RegisterRequest

// AuthResetPasswordJSONRequestBody defines body for AuthResetPassword for application/json ContentType.
type AuthResetPasswordJSONRequestBody = ResetPasswordRequest

// AuthSendEmailVerificationJSONRequestBody defines body for AuthSendEmailVerification for application/json ContentType.
type AuthSendEmailVerificationJSONRequestBody = SendEmailVerificationRequestBody

// SsoCreateIdentityProviderJSONRequestBody defines body for SsoCreateIdentityProvider for application/json ContentType.
type SsoCreateIdentityProviderJSONRequestBody = CreateIdentityProviderRequestBody

// SsoUpdateIdentityProviderJSONRequestBody defines body for SsoUpdateIdentityProvider for application/json ContentType.
type SsoUpdateIdentityProviderJSONRequestBody = UpdateIdentityProviderRequestBody

// AuthVerifyEmailJSONRequestBody defines body for AuthVerifyEmail for application/json ContentType.
type AuthVerifyEmailJSONRequestBody = VerifyEmailRequest

// EmailSendJSONRequestBody defines body for EmailSend for application/json ContentType.
type EmailSendJSONRequestBody = SendEmailRequest

// EmailSendTemplateJSONRequestBody defines body for EmailSendTemplate for application/json ContentType.
type EmailSendTemplateJSONRequestBody = SendTemplateEmailRequest

// EmailCreateTemplateJSONRequestBody defines body for EmailCreateTemplate for application/json ContentType.
type EmailCreateTemplateJSONRequestBody = CreateEmailTemplateRequest

// EmailUpdateTemplateJSONRequestBody defines body for EmailUpdateTemplate for application/json ContentType.
type EmailUpdateTemplateJSONRequestBody = UpdateTemplateRequestBody

// OauthProviderCreateClientJSONRequestBody defines body for OauthProviderCreateClient for application/json ContentType.
type OauthProviderCreateClientJSONRequestBody = CreateOAuthClientRequest

// OauthProviderUpdateClientJSONRequestBody defines body for OauthProviderUpdateClient for application/json ContentType.
type OauthProviderUpdateClientJSONRequestBody = UpdateClientRequestBody

// OauthProviderConsentJSONRequestBody defines body for OauthProviderConsent for application/json ContentType.
type OauthProviderConsentJSONRequestBody = ConsentRequest

// OauthProviderCreateScopeJSONRequestBody defines body for OauthProviderCreateScope for application/json ContentType.
type OauthProviderCreateScopeJSONRequestBody = CreateOAuthScopeRequest

// OauthProviderUpdateScopeJSONRequestBody defines body for OauthProviderUpdateScope for application/json ContentType.
type OauthProviderUpdateScopeJSONRequestBody = UpdateScopeRequestBody

// OrganizationsCreateJSONRequestBody defines body for OrganizationsCreate for application/json ContentType.
type OrganizationsCreateJSONRequestBody = CreateRequestBody2

// OrganizationsUpdateJSONRequestBody defines body for OrganizationsUpdate for application/json ContentType.
type OrganizationsUpdateJSONRequestBody = UpdateRequestBody2

// OrganizationsEnableFeatureJSONRequestBody defines body for OrganizationsEnableFeature for application/json ContentType.
type OrganizationsEnableFeatureJSONRequestBody = EnableFeatureRequestBody

// OrganizationsAddMemberJSONRequestBody defines body for OrganizationsAddMember for application/json ContentType.
type OrganizationsAddMemberJSONRequestBody = AddMemberRequestBody

// OrganizationsUpdateMemberJSONRequestBody defines body for OrganizationsUpdateMember for application/json ContentType.
type OrganizationsUpdateMemberJSONRequestBody = UpdateMemberRequestBody

// RbacCreatePermissionJSONRequestBody defines body for RbacCreatePermission for application/json ContentType.
type RbacCreatePermissionJSONRequestBody = CreatePermissionRequestBody

// RbacUpdatePermissionJSONRequestBody defines body for RbacUpdatePermission for application/json ContentType.
type RbacUpdatePermissionJSONRequestBody = UpdatePermissionRequestBody

// RbacCreateRoleJSONRequestBody defines body for RbacCreateRole for application/json ContentType.
type RbacCreateRoleJSONRequestBody = CreateRoleRequestBody

// RbacUpdateRoleJSONRequestBody defines body for RbacUpdateRole for application/json ContentType.
type RbacUpdateRoleJSONRequestBody = UpdateRoleRequestBody

// RbacAddRolePermissionJSONRequestBody defines body for RbacAddRolePermission for application/json ContentType.
type RbacAddRolePermissionJSONRequestBody = AddRolePermissionRequestBody

// UsersCreateJSONRequestBody defines body for UsersCreate for application/json ContentType.
type UsersCreateJSONRequestBody = CreateUserRequest

// UsersUpdateMeJSONRequestBody defines body for UsersUpdateMe for application/json ContentType.
type UsersUpdateMeJSONRequestBody = UpdateUserRequest

// UsersUpdatePasswordJSONRequestBody defines body for UsersUpdatePassword for application/json ContentType.
type UsersUpdatePasswordJSONRequestBody = UpdatePasswordRequest

// UsersUpdateJSONRequestBody defines body for UsersUpdate for application/json ContentType.
type UsersUpdateJSONRequestBody = UpdateRequestBody4

// WebhooksCreateJSONRequestBody defines body for WebhooksCreate for application/json ContentType.
type WebhooksCreateJSONRequestBody = CreateRequestBody3

// WebhooksTriggerEventJSONRequestBody defines body for WebhooksTriggerEvent for application/json ContentType.
type WebhooksTriggerEventJSONRequestBody = TriggerEventRequestBody

// WebhooksUpdateJSONRequestBody defines body for WebhooksUpdate for application/json ContentType.
type WebhooksUpdateJSONRequestBody = UpdateRequestBody5

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthDebug request
	HealthDebug(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthMetrics request
	HealthMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthReady request
	HealthReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthVersion request
	HealthVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCheckPermission request
	RbacCheckPermission(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCheckRole request
	RbacCheckRole(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysList request
	ApiKeysList(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysCreateWithBody request with any body
	ApiKeysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiKeysCreate(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysValidate request
	ApiKeysValidate(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysDelete request
	ApiKeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysGet request
	ApiKeysGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysUpdateWithBody request with any body
	ApiKeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiKeysUpdate(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthCheckEmailVerification request
	AuthCheckEmailVerification(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthCsrf request
	AuthCsrf(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthForgotPasswordWithBody request with any body
	AuthForgotPasswordWithBody(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthForgotPassword(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLoginWithBody request with any body
	AuthLoginWithBody(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLogin(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogout request
	AuthLogout(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthMe request
	AuthMe(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaEnrollWithBody request with any body
	MfaEnrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaEnroll(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaMethods request
	MfaMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaSendCodeWithBody request with any body
	MfaSendCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaSendCode(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaUnenrollWithBody request with any body
	MfaUnenrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaUnenroll(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaVerifyWithBody request with any body
	MfaVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaVerify(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthClientProviderCallback request
	OauthClientProviderCallback(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthClientListProviders request
	OauthClientListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthClientProviderAuth request
	OauthClientProviderAuth(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysList request
	PasskeysList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysLoginBegin request
	PasskeysLoginBegin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysLoginCompleteWithBody request with any body
	PasskeysLoginCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysLoginComplete(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysRegisterBeginWithBody request with any body
	PasskeysRegisterBeginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysRegisterBegin(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysRegisterCompleteWithBody request with any body
	PasskeysRegisterCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysRegisterComplete(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysDelete request
	PasskeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysUpdateWithBody request with any body
	PasskeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysUpdate(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessEmailWithBody request with any body
	PasswordlessEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessEmail(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessMagicLinkWithBody request with any body
	PasswordlessMagicLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessMagicLink(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessMethods request
	PasswordlessMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessSmsWithBody request with any body
	PasswordlessSmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessSms(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessVerifyWithBody request with any body
	PasswordlessVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessVerify(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRefreshTokenWithBody request with any body
	AuthRefreshTokenWithBody(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthRefreshToken(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRegisterWithBody request with any body
	AuthRegisterWithBody(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthRegister(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthResetPasswordWithBody request with any body
	AuthResetPasswordWithBody(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthResetPassword(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthSendEmailVerificationWithBody request with any body
	AuthSendEmailVerificationWithBody(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthSendEmailVerification(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoProviderCallback request
	SsoProviderCallback(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoListIdentityProviders request
	SsoListIdentityProviders(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoCreateIdentityProviderWithBody request with any body
	SsoCreateIdentityProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SsoCreateIdentityProvider(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoDeleteIdentityProvider request
	SsoDeleteIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoGetIdentityProvider request
	SsoGetIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoUpdateIdentityProviderWithBody request with any body
	SsoUpdateIdentityProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SsoUpdateIdentityProvider(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoListProviders request
	SsoListProviders(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoProviderAuth request
	SsoProviderAuth(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoSamlAcs request
	SsoSamlAcs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoSamlMetadata request
	SsoSamlMetadata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthVerifyEmailWithBody request with any body
	AuthVerifyEmailWithBody(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthVerifyEmail(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailSendWithBody request with any body
	EmailSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailSend(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailSendTemplateWithBody request with any body
	EmailSendTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailSendTemplate(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailListTemplates request
	EmailListTemplates(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailCreateTemplateWithBody request with any body
	EmailCreateTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailCreateTemplate(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailGetTemplateByType request
	EmailGetTemplateByType(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailDeleteTemplate request
	EmailDeleteTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailGetTemplate request
	EmailGetTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailUpdateTemplateWithBody request with any body
	EmailUpdateTemplateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailUpdateTemplate(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderJwks request
	OauthProviderJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderOidcConfiguration request
	OauthProviderOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderAuthorize request
	OauthProviderAuthorize(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderListClients request
	OauthProviderListClients(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderCreateClientWithBody request with any body
	OauthProviderCreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderCreateClient(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderDeleteClient request
	OauthProviderDeleteClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderGetClient request
	OauthProviderGetClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderUpdateClientWithBody request with any body
	OauthProviderUpdateClientWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderUpdateClient(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderRotateClientSecret request
	OauthProviderRotateClientSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderConsentWithBody request with any body
	OauthProviderConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderConsent(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderIntrospect request
	OauthProviderIntrospect(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderRevoke request
	OauthProviderRevoke(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderListScopes request
	OauthProviderListScopes(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderCreateScopeWithBody request with any body
	OauthProviderCreateScopeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderCreateScope(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderDeleteScope request
	OauthProviderDeleteScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderGetScope request
	OauthProviderGetScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderUpdateScopeWithBody request with any body
	OauthProviderUpdateScopeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderUpdateScope(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderToken request
	OauthProviderToken(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderUserinfo request
	OauthProviderUserinfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsList request
	OrganizationsList(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsCreateWithBody request with any body
	OrganizationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsCreate(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsDelete request
	OrganizationsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsGet request
	OrganizationsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsUpdateWithBody request with any body
	OrganizationsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsUpdate(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsListFeatures request
	OrganizationsListFeatures(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsEnableFeatureWithBody request with any body
	OrganizationsEnableFeatureWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsEnableFeature(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsDisableFeature request
	OrganizationsDisableFeature(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsListMembers request
	OrganizationsListMembers(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsAddMemberWithBody request with any body
	OrganizationsAddMemberWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsAddMember(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsRemoveMember request
	OrganizationsRemoveMember(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsUpdateMemberWithBody request with any body
	OrganizationsUpdateMemberWithBody(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsUpdateMember(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacListPermissions request
	RbacListPermissions(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCreatePermissionWithBody request with any body
	RbacCreatePermissionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacCreatePermission(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacDeletePermission request
	RbacDeletePermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacGetPermission request
	RbacGetPermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacUpdatePermissionWithBody request with any body
	RbacUpdatePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacUpdatePermission(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacListRoles request
	RbacListRoles(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCreateRoleWithBody request with any body
	RbacCreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacCreateRole(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacDeleteRole request
	RbacDeleteRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacGetRole request
	RbacGetRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacUpdateRoleWithBody request with any body
	RbacUpdateRoleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacUpdateRole(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacListRolePermissions request
	RbacListRolePermissions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacAddRolePermissionWithBody request with any body
	RbacAddRolePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacAddRolePermission(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacRemoveRolePermission request
	RbacRemoveRolePermission(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersList request
	UsersList(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersCreateWithBody request with any body
	UsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersCreate(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdateMeWithBody request with any body
	UsersUpdateMeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdateMe(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdatePasswordWithBody request with any body
	UsersUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdatePassword(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersGetSessions request
	UsersGetSessions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDeleteSession request
	UsersDeleteSession(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDelete request
	UsersDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersGet request
	UsersGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdateWithBody request with any body
	UsersUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdate(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersGetOrganizations request
	UsersGetOrganizations(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksList request
	WebhooksList(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksCreateWithBody request with any body
	WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksReceive request
	WebhooksReceive(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksTriggerEventWithBody request with any body
	WebhooksTriggerEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksTriggerEvent(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksDelete request
	WebhooksDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksGet request
	WebhooksGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksUpdateWithBody request with any body
	WebhooksUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksUpdate(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksListEvents request
	WebhooksListEvents(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksReplayEvent request
	WebhooksReplayEvent(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthDebug(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthDebugRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCheckPermission(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCheckPermissionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCheckRole(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCheckRoleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysList(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysCreate(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysValidate(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysValidateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysUpdate(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthCheckEmailVerification(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthCheckEmailVerificationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthCsrf(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthCsrfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthForgotPasswordWithBody(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthForgotPasswordRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthForgotPassword(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthForgotPasswordRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginWithBody(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogin(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogout(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthMe(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthMeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaEnrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaEnrollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaEnroll(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaEnrollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaMethodsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaSendCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaSendCodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaSendCode(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaSendCodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaUnenrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaUnenrollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaUnenroll(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaUnenrollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaVerifyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaVerify(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaVerifyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthClientProviderCallback(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthClientProviderCallbackRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthClientListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthClientListProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthClientProviderAuth(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthClientProviderAuthRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysLoginBegin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysLoginBeginRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysLoginCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysLoginCompleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysLoginComplete(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysLoginCompleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterBeginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterBeginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterBegin(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterBeginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterCompleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterComplete(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterCompleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysUpdate(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessEmail(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessMagicLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessMagicLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessMagicLink(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessMagicLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessMethodsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessSmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessSmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessSms(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessSmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessVerifyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessVerify(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessVerifyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRefreshTokenWithBody(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRefreshTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRefreshToken(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRefreshTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegisterWithBody(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegisterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegister(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegisterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthResetPasswordWithBody(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthResetPasswordRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthResetPassword(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthResetPasswordRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthSendEmailVerificationWithBody(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthSendEmailVerificationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthSendEmailVerification(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthSendEmailVerificationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoProviderCallback(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoProviderCallbackRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoListIdentityProviders(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoListIdentityProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoCreateIdentityProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoCreateIdentityProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoCreateIdentityProvider(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoCreateIdentityProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoDeleteIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoDeleteIdentityProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoGetIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoGetIdentityProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoUpdateIdentityProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoUpdateIdentityProviderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoUpdateIdentityProvider(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoUpdateIdentityProviderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoListProviders(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoListProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoProviderAuth(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoProviderAuthRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoSamlAcs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoSamlAcsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoSamlMetadata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoSamlMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthVerifyEmailWithBody(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthVerifyEmailRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthVerifyEmail(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthVerifyEmailRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSend(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSendTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSendTemplate(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailListTemplates(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailListTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailCreateTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailCreateTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailCreateTemplate(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailCreateTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailGetTemplateByType(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailGetTemplateByTypeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailDeleteTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailDeleteTemplateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailGetTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailGetTemplateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailUpdateTemplateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailUpdateTemplateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailUpdateTemplate(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailUpdateTemplateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderJwksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderOidcConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderAuthorize(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderListClients(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderListClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateClient(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderDeleteClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderDeleteClientRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderGetClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderGetClientRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateClientWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateClientRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateClient(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateClientRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderRotateClientSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderRotateClientSecretRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderConsent(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderIntrospect(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderIntrospectRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderRevoke(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderRevokeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderListScopes(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderListScopesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateScopeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateScopeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateScope(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateScopeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderDeleteScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderDeleteScopeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderGetScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderGetScopeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateScopeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateScopeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateScope(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateScopeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderToken(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUserinfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUserinfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsList(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsCreate(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdate(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsListFeatures(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsListFeaturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsEnableFeatureWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsEnableFeatureRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsEnableFeature(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsEnableFeatureRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsDisableFeature(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsDisableFeatureRequest(c.Server, id, featureKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsListMembers(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsListMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsAddMemberWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsAddMemberRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsAddMember(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsAddMemberRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsRemoveMember(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsRemoveMemberRequest(c.Server, id, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdateMemberWithBody(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateMemberRequestWithBody(c.Server, id, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdateMember(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateMemberRequest(c.Server, id, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacListPermissions(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacListPermissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreatePermissionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreatePermissionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreatePermission(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreatePermissionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacDeletePermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacDeletePermissionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacGetPermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacGetPermissionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdatePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdatePermissionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdatePermission(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdatePermissionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacListRoles(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacListRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreateRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreateRole(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreateRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacDeleteRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacDeleteRoleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacGetRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacGetRoleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdateRoleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdateRoleRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdateRole(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdateRoleRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacListRolePermissions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacListRolePermissionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacAddRolePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacAddRolePermissionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacAddRolePermission(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacAddRolePermissionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacRemoveRolePermission(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacRemoveRolePermissionRequest(c.Server, id, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersList(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreate(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateMeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateMeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateMe(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateMeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePassword(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGetSessions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersGetSessionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDeleteSession(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDeleteSessionRequest(c.Server, sessionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdate(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGetOrganizations(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersGetOrganizationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksList(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksReceive(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksReceiveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksTriggerEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksTriggerEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksTriggerEvent(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksTriggerEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdate(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksListEvents(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksReplayEvent(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksReplayEventRequest(c.Server, id, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthDebugRequest generates requests for HealthDebug
func NewHealthDebugRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__debug")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthMetricsRequest generates requests for HealthMetrics
func NewHealthMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthReadyRequest generates requests for HealthReady
func NewHealthReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthVersionRequest generates requests for HealthVersion
func NewHealthVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCheckPermissionRequest generates requests for RbacCheckPermission
func NewRbacCheckPermissionRequest(server string, params *RbacCheckPermissionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/access/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCheckRoleRequest generates requests for RbacCheckRole
func NewRbacCheckRoleRequest(server string, params *RbacCheckRoleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/access/check-role")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysListRequest generates requests for ApiKeysList
func NewApiKeysListRequest(server string, params *ApiKeysListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysCreateRequest calls the generic ApiKeysCreate builder with application/json body
func NewApiKeysCreateRequest(server string, body ApiKeysCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiKeysCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewApiKeysCreateRequestWithBody generates requests for ApiKeysCreate with any type of body
func NewApiKeysCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApiKeysValidateRequest generates requests for ApiKeysValidate
func NewApiKeysValidateRequest(server string, params *ApiKeysValidateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "api_key", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysDeleteRequest generates requests for ApiKeysDelete
func NewApiKeysDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysGetRequest generates requests for ApiKeysGet
func NewApiKeysGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysUpdateRequest calls the generic ApiKeysUpdate builder with application/json body
func NewApiKeysUpdateRequest(server string, id string, body ApiKeysUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiKeysUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewApiKeysUpdateRequestWithBody generates requests for ApiKeysUpdate with any type of body
func NewApiKeysUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthCheckEmailVerificationRequest generates requests for AuthCheckEmailVerification
func NewAuthCheckEmailVerificationRequest(server string, params *AuthCheckEmailVerificationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/check-verification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthCsrfRequest generates requests for AuthCsrf
func NewAuthCsrfRequest(server string, params *AuthCsrfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/csrf-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthForgotPasswordRequest calls the generic AuthForgotPassword builder with application/json body
func NewAuthForgotPasswordRequest(server string, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthForgotPasswordRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthForgotPasswordRequestWithBody generates requests for AuthForgotPassword with any type of body
func NewAuthForgotPasswordRequestWithBody(server string, params *AuthForgotPasswordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/forgot-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_url", runtime.ParamLocationQuery, *params.RedirectUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthLoginRequest calls the generic AuthLogin builder with application/json body
func NewAuthLoginRequest(server string, params *AuthLoginParams, body AuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthLoginRequestWithBody generates requests for AuthLogin with any type of body
func NewAuthLoginRequestWithBody(server string, params *AuthLoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthLogoutRequest generates requests for AuthLogout
func NewAuthLogoutRequest(server string, params *AuthLogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthMeRequest generates requests for AuthMe
func NewAuthMeRequest(server string, params *AuthMeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewMfaEnrollRequest calls the generic MfaEnroll builder with application/json body
func NewMfaEnrollRequest(server string, body MfaEnrollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaEnrollRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaEnrollRequestWithBody generates requests for MfaEnroll with any type of body
func NewMfaEnrollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/enroll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMfaMethodsRequest generates requests for MfaMethods
func NewMfaMethodsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMfaSendCodeRequest calls the generic MfaSendCode builder with application/json body
func NewMfaSendCodeRequest(server string, body MfaSendCodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaSendCodeRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaSendCodeRequestWithBody generates requests for MfaSendCode with any type of body
func NewMfaSendCodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/send-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMfaUnenrollRequest calls the generic MfaUnenroll builder with application/json body
func NewMfaUnenrollRequest(server string, body MfaUnenrollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaUnenrollRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaUnenrollRequestWithBody generates requests for MfaUnenroll with any type of body
func NewMfaUnenrollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/unenroll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMfaVerifyRequest calls the generic MfaVerify builder with application/json body
func NewMfaVerifyRequest(server string, body MfaVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaVerifyRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaVerifyRequestWithBody generates requests for MfaVerify with any type of body
func NewMfaVerifyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthClientProviderCallbackRequest generates requests for OauthClientProviderCallback
func NewOauthClientProviderCallbackRequest(server string, provider string, params *OauthClientProviderCallbackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/oauth/callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthClientListProvidersRequest generates requests for OauthClientListProviders
func NewOauthClientListProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/oauth/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthClientProviderAuthRequest generates requests for OauthClientProviderAuth
func NewOauthClientProviderAuthRequest(server string, provider string, params *OauthClientProviderAuthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/oauth/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysListRequest generates requests for PasskeysList
func NewPasskeysListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysLoginBeginRequest generates requests for PasskeysLoginBegin
func NewPasskeysLoginBeginRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/login/begin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysLoginCompleteRequest calls the generic PasskeysLoginComplete builder with application/json body
func NewPasskeysLoginCompleteRequest(server string, body PasskeysLoginCompleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysLoginCompleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeysLoginCompleteRequestWithBody generates requests for PasskeysLoginComplete with any type of body
func NewPasskeysLoginCompleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/login/complete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeysRegisterBeginRequest calls the generic PasskeysRegisterBegin builder with application/json body
func NewPasskeysRegisterBeginRequest(server string, body PasskeysRegisterBeginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysRegisterBeginRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeysRegisterBeginRequestWithBody generates requests for PasskeysRegisterBegin with any type of body
func NewPasskeysRegisterBeginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/register/begin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeysRegisterCompleteRequest calls the generic PasskeysRegisterComplete builder with application/json body
func NewPasskeysRegisterCompleteRequest(server string, body PasskeysRegisterCompleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysRegisterCompleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeysRegisterCompleteRequestWithBody generates requests for PasskeysRegisterComplete with any type of body
func NewPasskeysRegisterCompleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/register/complete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeysDeleteRequest generates requests for PasskeysDelete
func NewPasskeysDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysUpdateRequest calls the generic PasskeysUpdate builder with application/json body
func NewPasskeysUpdateRequest(server string, id string, body PasskeysUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPasskeysUpdateRequestWithBody generates requests for PasskeysUpdate with any type of body
func NewPasskeysUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessEmailRequest calls the generic PasswordlessEmail builder with application/json body
func NewPasswordlessEmailRequest(server string, body PasswordlessEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessEmailRequestWithBody generates requests for PasswordlessEmail with any type of body
func NewPasswordlessEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessMagicLinkRequest calls the generic PasswordlessMagicLink builder with application/json body
func NewPasswordlessMagicLinkRequest(server string, body PasswordlessMagicLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessMagicLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessMagicLinkRequestWithBody generates requests for PasswordlessMagicLink with any type of body
func NewPasswordlessMagicLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/magic-link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessMethodsRequest generates requests for PasswordlessMethods
func NewPasswordlessMethodsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasswordlessSmsRequest calls the generic PasswordlessSms builder with application/json body
func NewPasswordlessSmsRequest(server string, body PasswordlessSmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessSmsRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessSmsRequestWithBody generates requests for PasswordlessSms with any type of body
func NewPasswordlessSmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/sms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessVerifyRequest calls the generic PasswordlessVerify builder with application/json body
func NewPasswordlessVerifyRequest(server string, body PasswordlessVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessVerifyRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessVerifyRequestWithBody generates requests for PasswordlessVerify with any type of body
func NewPasswordlessVerifyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthRefreshTokenRequest calls the generic AuthRefreshToken builder with application/json body
func NewAuthRefreshTokenRequest(server string, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthRefreshTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthRefreshTokenRequestWithBody generates requests for AuthRefreshToken with any type of body
func NewAuthRefreshTokenRequestWithBody(server string, params *AuthRefreshTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthRegisterRequest calls the generic AuthRegister builder with application/json body
func NewAuthRegisterRequest(server string, params *AuthRegisterParams, body AuthRegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthRegisterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthRegisterRequestWithBody generates requests for AuthRegister with any type of body
func NewAuthRegisterRequestWithBody(server string, params *AuthRegisterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthResetPasswordRequest calls the generic AuthResetPassword builder with application/json body
func NewAuthResetPasswordRequest(server string, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthResetPasswordRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthResetPasswordRequestWithBody generates requests for AuthResetPassword with any type of body
func NewAuthResetPasswordRequestWithBody(server string, params *AuthResetPasswordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthSendEmailVerificationRequest calls the generic AuthSendEmailVerification builder with application/json body
func NewAuthSendEmailVerificationRequest(server string, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthSendEmailVerificationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthSendEmailVerificationRequestWithBody generates requests for AuthSendEmailVerification with any type of body
func NewAuthSendEmailVerificationRequestWithBody(server string, params *AuthSendEmailVerificationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/send-verification-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_url", runtime.ParamLocationQuery, *params.RedirectUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewSsoProviderCallbackRequest generates requests for SsoProviderCallback
func NewSsoProviderCallbackRequest(server string, provider string, params *SsoProviderCallbackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SAMLResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SAMLResponse", runtime.ParamLocationQuery, *params.SAMLResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelayState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "RelayState", runtime.ParamLocationQuery, *params.RelayState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoListIdentityProvidersRequest generates requests for SsoListIdentityProviders
func NewSsoListIdentityProvidersRequest(server string, params *SsoListIdentityProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, params.OrganizationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoCreateIdentityProviderRequest calls the generic SsoCreateIdentityProvider builder with application/json body
func NewSsoCreateIdentityProviderRequest(server string, body SsoCreateIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSsoCreateIdentityProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewSsoCreateIdentityProviderRequestWithBody generates requests for SsoCreateIdentityProvider with any type of body
func NewSsoCreateIdentityProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSsoDeleteIdentityProviderRequest generates requests for SsoDeleteIdentityProvider
func NewSsoDeleteIdentityProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoGetIdentityProviderRequest generates requests for SsoGetIdentityProvider
func NewSsoGetIdentityProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoUpdateIdentityProviderRequest calls the generic SsoUpdateIdentityProvider builder with application/json body
func NewSsoUpdateIdentityProviderRequest(server string, id string, body SsoUpdateIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSsoUpdateIdentityProviderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSsoUpdateIdentityProviderRequestWithBody generates requests for SsoUpdateIdentityProvider with any type of body
func NewSsoUpdateIdentityProviderRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSsoListProvidersRequest generates requests for SsoListProviders
func NewSsoListProvidersRequest(server string, params *SsoListProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoProviderAuthRequest generates requests for SsoProviderAuth
func NewSsoProviderAuthRequest(server string, provider string, params *SsoProviderAuthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoSamlAcsRequest generates requests for SsoSamlAcs
func NewSsoSamlAcsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/saml/%s/acs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoSamlMetadataRequest generates requests for SsoSamlMetadata
func NewSsoSamlMetadataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/saml/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthVerifyEmailRequest calls the generic AuthVerifyEmail builder with application/json body
func NewAuthVerifyEmailRequest(server string, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthVerifyEmailRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthVerifyEmailRequestWithBody generates requests for AuthVerifyEmail with any type of body
func NewAuthVerifyEmailRequestWithBody(server string, params *AuthVerifyEmailParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewEmailSendRequest calls the generic EmailSend builder with application/json body
func NewEmailSendRequest(server string, body EmailSendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailSendRequestWithBody(server, "application/json", bodyReader)
}

// NewEmailSendRequestWithBody generates requests for EmailSend with any type of body
func NewEmailSendRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmailSendTemplateRequest calls the generic EmailSendTemplate builder with application/json body
func NewEmailSendTemplateRequest(server string, body EmailSendTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailSendTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewEmailSendTemplateRequestWithBody generates requests for EmailSendTemplate with any type of body
func NewEmailSendTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/send-template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmailListTemplatesRequest generates requests for EmailListTemplates
func NewEmailListTemplatesRequest(server string, params *EmailListTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailCreateTemplateRequest calls the generic EmailCreateTemplate builder with application/json body
func NewEmailCreateTemplateRequest(server string, body EmailCreateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailCreateTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewEmailCreateTemplateRequestWithBody generates requests for EmailCreateTemplate with any type of body
func NewEmailCreateTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmailGetTemplateByTypeRequest generates requests for EmailGetTemplateByType
func NewEmailGetTemplateByTypeRequest(server string, pType string, params *EmailGetTemplateByTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/by-type/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailDeleteTemplateRequest generates requests for EmailDeleteTemplate
func NewEmailDeleteTemplateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailGetTemplateRequest generates requests for EmailGetTemplate
func NewEmailGetTemplateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailUpdateTemplateRequest calls the generic EmailUpdateTemplate builder with application/json body
func NewEmailUpdateTemplateRequest(server string, id string, body EmailUpdateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailUpdateTemplateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEmailUpdateTemplateRequestWithBody generates requests for EmailUpdateTemplate with any type of body
func NewEmailUpdateTemplateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderJwksRequest generates requests for OauthProviderJwks
func NewOauthProviderJwksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/.well-known/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderOidcConfigurationRequest generates requests for OauthProviderOidcConfiguration
func NewOauthProviderOidcConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderAuthorizeRequest generates requests for OauthProviderAuthorize
func NewOauthProviderAuthorizeRequest(server string, params *OauthProviderAuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderListClientsRequest generates requests for OauthProviderListClients
func NewOauthProviderListClientsRequest(server string, params *OauthProviderListClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderCreateClientRequest calls the generic OauthProviderCreateClient builder with application/json body
func NewOauthProviderCreateClientRequest(server string, body OauthProviderCreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderCreateClientRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthProviderCreateClientRequestWithBody generates requests for OauthProviderCreateClient with any type of body
func NewOauthProviderCreateClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderDeleteClientRequest generates requests for OauthProviderDeleteClient
func NewOauthProviderDeleteClientRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderGetClientRequest generates requests for OauthProviderGetClient
func NewOauthProviderGetClientRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderUpdateClientRequest calls the generic OauthProviderUpdateClient builder with application/json body
func NewOauthProviderUpdateClientRequest(server string, id string, body OauthProviderUpdateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderUpdateClientRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOauthProviderUpdateClientRequestWithBody generates requests for OauthProviderUpdateClient with any type of body
func NewOauthProviderUpdateClientRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderRotateClientSecretRequest generates requests for OauthProviderRotateClientSecret
func NewOauthProviderRotateClientSecretRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s/rotate-secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderConsentRequest calls the generic OauthProviderConsent builder with application/json body
func NewOauthProviderConsentRequest(server string, body OauthProviderConsentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthProviderConsentRequestWithBody generates requests for OauthProviderConsent with any type of body
func NewOauthProviderConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderIntrospectRequest generates requests for OauthProviderIntrospect
func NewOauthProviderIntrospectRequest(server string, params *OauthProviderIntrospectParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TokenTypeHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token_type_hint", runtime.ParamLocationQuery, *params.TokenTypeHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderRevokeRequest generates requests for OauthProviderRevoke
func NewOauthProviderRevokeRequest(server string, params *OauthProviderRevokeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TokenTypeHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token_type_hint", runtime.ParamLocationQuery, *params.TokenTypeHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientSecret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, *params.ClientSecret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderListScopesRequest generates requests for OauthProviderListScopes
func NewOauthProviderListScopesRequest(server string, params *OauthProviderListScopesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderCreateScopeRequest calls the generic OauthProviderCreateScope builder with application/json body
func NewOauthProviderCreateScopeRequest(server string, body OauthProviderCreateScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderCreateScopeRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthProviderCreateScopeRequestWithBody generates requests for OauthProviderCreateScope with any type of body
func NewOauthProviderCreateScopeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderDeleteScopeRequest generates requests for OauthProviderDeleteScope
func NewOauthProviderDeleteScopeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderGetScopeRequest generates requests for OauthProviderGetScope
func NewOauthProviderGetScopeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderUpdateScopeRequest calls the generic OauthProviderUpdateScope builder with application/json body
func NewOauthProviderUpdateScopeRequest(server string, id string, body OauthProviderUpdateScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderUpdateScopeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOauthProviderUpdateScopeRequestWithBody generates requests for OauthProviderUpdateScope with any type of body
func NewOauthProviderUpdateScopeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderTokenRequest generates requests for OauthProviderToken
func NewOauthProviderTokenRequest(server string, params *OauthProviderTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grant_type", runtime.ParamLocationQuery, params.GrantType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientSecret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, *params.ClientSecret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefreshToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh_token", runtime.ParamLocationQuery, *params.RefreshToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeVerifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_verifier", runtime.ParamLocationQuery, *params.CodeVerifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderUserinfoRequest generates requests for OauthProviderUserinfo
func NewOauthProviderUserinfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/userinfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsListRequest generates requests for OrganizationsList
func NewOrganizationsListRequest(server string, params *OrganizationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsCreateRequest calls the generic OrganizationsCreate builder with application/json body
func NewOrganizationsCreateRequest(server string, body OrganizationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrganizationsCreateRequestWithBody generates requests for OrganizationsCreate with any type of body
func NewOrganizationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsDeleteRequest generates requests for OrganizationsDelete
func NewOrganizationsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsGetRequest generates requests for OrganizationsGet
func NewOrganizationsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsUpdateRequest calls the generic OrganizationsUpdate builder with application/json body
func NewOrganizationsUpdateRequest(server string, id string, body OrganizationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOrganizationsUpdateRequestWithBody generates requests for OrganizationsUpdate with any type of body
func NewOrganizationsUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsListFeaturesRequest generates requests for OrganizationsListFeatures
func NewOrganizationsListFeaturesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/features", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsEnableFeatureRequest calls the generic OrganizationsEnableFeature builder with application/json body
func NewOrganizationsEnableFeatureRequest(server string, id string, body OrganizationsEnableFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsEnableFeatureRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOrganizationsEnableFeatureRequestWithBody generates requests for OrganizationsEnableFeature with any type of body
func NewOrganizationsEnableFeatureRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/features", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsDisableFeatureRequest generates requests for OrganizationsDisableFeature
func NewOrganizationsDisableFeatureRequest(server string, id string, featureKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature_key", runtime.ParamLocationPath, featureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/features/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsListMembersRequest generates requests for OrganizationsListMembers
func NewOrganizationsListMembersRequest(server string, id string, params *OrganizationsListMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsAddMemberRequest calls the generic OrganizationsAddMember builder with application/json body
func NewOrganizationsAddMemberRequest(server string, id string, body OrganizationsAddMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsAddMemberRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOrganizationsAddMemberRequestWithBody generates requests for OrganizationsAddMember with any type of body
func NewOrganizationsAddMemberRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsRemoveMemberRequest generates requests for OrganizationsRemoveMember
func NewOrganizationsRemoveMemberRequest(server string, id string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsUpdateMemberRequest calls the generic OrganizationsUpdateMember builder with application/json body
func NewOrganizationsUpdateMemberRequest(server string, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsUpdateMemberRequestWithBody(server, id, userId, "application/json", bodyReader)
}

// NewOrganizationsUpdateMemberRequestWithBody generates requests for OrganizationsUpdateMember with any type of body
func NewOrganizationsUpdateMemberRequestWithBody(server string, id string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacListPermissionsRequest generates requests for RbacListPermissions
func NewRbacListPermissionsRequest(server string, params *RbacListPermissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCreatePermissionRequest calls the generic RbacCreatePermission builder with application/json body
func NewRbacCreatePermissionRequest(server string, body RbacCreatePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacCreatePermissionRequestWithBody(server, "application/json", bodyReader)
}

// NewRbacCreatePermissionRequestWithBody generates requests for RbacCreatePermission with any type of body
func NewRbacCreatePermissionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacDeletePermissionRequest generates requests for RbacDeletePermission
func NewRbacDeletePermissionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacGetPermissionRequest generates requests for RbacGetPermission
func NewRbacGetPermissionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacUpdatePermissionRequest calls the generic RbacUpdatePermission builder with application/json body
func NewRbacUpdatePermissionRequest(server string, id string, body RbacUpdatePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacUpdatePermissionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRbacUpdatePermissionRequestWithBody generates requests for RbacUpdatePermission with any type of body
func NewRbacUpdatePermissionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacListRolesRequest generates requests for RbacListRoles
func NewRbacListRolesRequest(server string, params *RbacListRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCreateRoleRequest calls the generic RbacCreateRole builder with application/json body
func NewRbacCreateRoleRequest(server string, body RbacCreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacCreateRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewRbacCreateRoleRequestWithBody generates requests for RbacCreateRole with any type of body
func NewRbacCreateRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacDeleteRoleRequest generates requests for RbacDeleteRole
func NewRbacDeleteRoleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacGetRoleRequest generates requests for RbacGetRole
func NewRbacGetRoleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacUpdateRoleRequest calls the generic RbacUpdateRole builder with application/json body
func NewRbacUpdateRoleRequest(server string, id string, body RbacUpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacUpdateRoleRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRbacUpdateRoleRequestWithBody generates requests for RbacUpdateRole with any type of body
func NewRbacUpdateRoleRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacListRolePermissionsRequest generates requests for RbacListRolePermissions
func NewRbacListRolePermissionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacAddRolePermissionRequest calls the generic RbacAddRolePermission builder with application/json body
func NewRbacAddRolePermissionRequest(server string, id string, body RbacAddRolePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacAddRolePermissionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRbacAddRolePermissionRequestWithBody generates requests for RbacAddRolePermission with any type of body
func NewRbacAddRolePermissionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacRemoveRolePermissionRequest generates requests for RbacRemoveRolePermission
func NewRbacRemoveRolePermissionRequest(server string, id string, permissionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersListRequest generates requests for UsersList
func NewUsersListRequest(server string, params *UsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersCreateRequest calls the generic UsersCreate builder with application/json body
func NewUsersCreateRequest(server string, body UsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersCreateRequestWithBody generates requests for UsersCreate with any type of body
func NewUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersUpdateMeRequest calls the generic UsersUpdateMe builder with application/json body
func NewUsersUpdateMeRequest(server string, body UsersUpdateMeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdateMeRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersUpdateMeRequestWithBody generates requests for UsersUpdateMe with any type of body
func NewUsersUpdateMeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersUpdatePasswordRequest calls the generic UsersUpdatePassword builder with application/json body
func NewUsersUpdatePasswordRequest(server string, body UsersUpdatePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdatePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersUpdatePasswordRequestWithBody generates requests for UsersUpdatePassword with any type of body
func NewUsersUpdatePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersGetSessionsRequest generates requests for UsersGetSessions
func NewUsersGetSessionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersDeleteSessionRequest generates requests for UsersDeleteSession
func NewUsersDeleteSessionRequest(server string, sessionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersDeleteRequest generates requests for UsersDelete
func NewUsersDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersGetRequest generates requests for UsersGet
func NewUsersGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersUpdateRequest calls the generic UsersUpdate builder with application/json body
func NewUsersUpdateRequest(server string, id string, body UsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersUpdateRequestWithBody generates requests for UsersUpdate with any type of body
func NewUsersUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersGetOrganizationsRequest generates requests for UsersGetOrganizations
func NewUsersGetOrganizationsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s/organizations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksListRequest generates requests for WebhooksList
func NewWebhooksListRequest(server string, params *WebhooksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_types", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksCreateRequest calls the generic WebhooksCreate builder with application/json body
func NewWebhooksCreateRequest(server string, body WebhooksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksCreateRequestWithBody generates requests for WebhooksCreate with any type of body
func NewWebhooksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksReceiveRequest generates requests for WebhooksReceive
func NewWebhooksReceiveRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/external/receive/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksTriggerEventRequest calls the generic WebhooksTriggerEvent builder with application/json body
func NewWebhooksTriggerEventRequest(server string, body WebhooksTriggerEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksTriggerEventRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksTriggerEventRequestWithBody generates requests for WebhooksTriggerEvent with any type of body
func NewWebhooksTriggerEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/trigger")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksDeleteRequest generates requests for WebhooksDelete
func NewWebhooksDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksGetRequest generates requests for WebhooksGet
func NewWebhooksGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksUpdateRequest calls the generic WebhooksUpdate builder with application/json body
func NewWebhooksUpdateRequest(server string, id string, body WebhooksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewWebhooksUpdateRequestWithBody generates requests for WebhooksUpdate with any type of body
func NewWebhooksUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksListEventsRequest generates requests for WebhooksListEvents
func NewWebhooksListEventsRequest(server string, id string, params *WebhooksListEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Delivered != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delivered", runtime.ParamLocationQuery, *params.Delivered); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksReplayEventRequest generates requests for WebhooksReplayEvent
func NewWebhooksReplayEventRequest(server string, id string, eventId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/events/%s/replay", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthDebugWithResponse request
	HealthDebugWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthDebugResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// HealthMetricsWithResponse request
	HealthMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthMetricsResponse, error)

	// HealthReadyWithResponse request
	HealthReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthReadyResponse, error)

	// HealthVersionWithResponse request
	HealthVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthVersionResponse, error)

	// RbacCheckPermissionWithResponse request
	RbacCheckPermissionWithResponse(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*RbacCheckPermissionResponse, error)

	// RbacCheckRoleWithResponse request
	RbacCheckRoleWithResponse(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*RbacCheckRoleResponse, error)

	// ApiKeysListWithResponse request
	ApiKeysListWithResponse(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*ApiKeysListResponse, error)

	// ApiKeysCreateWithBodyWithResponse request with any body
	ApiKeysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error)

	ApiKeysCreateWithResponse(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error)

	// ApiKeysValidateWithResponse request
	ApiKeysValidateWithResponse(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*ApiKeysValidateResponse, error)

	// ApiKeysDeleteWithResponse request
	ApiKeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysDeleteResponse, error)

	// ApiKeysGetWithResponse request
	ApiKeysGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysGetResponse, error)

	// ApiKeysUpdateWithBodyWithResponse request with any body
	ApiKeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error)

	ApiKeysUpdateWithResponse(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error)

	// AuthCheckEmailVerificationWithResponse request
	AuthCheckEmailVerificationWithResponse(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*AuthCheckEmailVerificationResponse, error)

	// AuthCsrfWithResponse request
	AuthCsrfWithResponse(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*AuthCsrfResponse, error)

	// AuthForgotPasswordWithBodyWithResponse request with any body
	AuthForgotPasswordWithBodyWithResponse(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error)

	AuthForgotPasswordWithResponse(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error)

	// AuthLoginWithBodyWithResponse request with any body
	AuthLoginWithBodyWithResponse(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	AuthLoginWithResponse(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	// AuthLogoutWithResponse request
	AuthLogoutWithResponse(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error)

	// AuthMeWithResponse request
	AuthMeWithResponse(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*AuthMeResponse, error)

	// MfaEnrollWithBodyWithResponse request with any body
	MfaEnrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error)

	MfaEnrollWithResponse(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error)

	// MfaMethodsWithResponse request
	MfaMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MfaMethodsResponse, error)

	// MfaSendCodeWithBodyWithResponse request with any body
	MfaSendCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error)

	MfaSendCodeWithResponse(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error)

	// MfaUnenrollWithBodyWithResponse request with any body
	MfaUnenrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error)

	MfaUnenrollWithResponse(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error)

	// MfaVerifyWithBodyWithResponse request with any body
	MfaVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error)

	MfaVerifyWithResponse(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error)

	// OauthClientProviderCallbackWithResponse request
	OauthClientProviderCallbackWithResponse(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*OauthClientProviderCallbackResponse, error)

	// OauthClientListProvidersWithResponse request
	OauthClientListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthClientListProvidersResponse, error)

	// OauthClientProviderAuthWithResponse request
	OauthClientProviderAuthWithResponse(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*OauthClientProviderAuthResponse, error)

	// PasskeysListWithResponse request
	PasskeysListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysListResponse, error)

	// PasskeysLoginBeginWithResponse request
	PasskeysLoginBeginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysLoginBeginResponse, error)

	// PasskeysLoginCompleteWithBodyWithResponse request with any body
	PasskeysLoginCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error)

	PasskeysLoginCompleteWithResponse(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error)

	// PasskeysRegisterBeginWithBodyWithResponse request with any body
	PasskeysRegisterBeginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error)

	PasskeysRegisterBeginWithResponse(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error)

	// PasskeysRegisterCompleteWithBodyWithResponse request with any body
	PasskeysRegisterCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error)

	PasskeysRegisterCompleteWithResponse(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error)

	// PasskeysDeleteWithResponse request
	PasskeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PasskeysDeleteResponse, error)

	// PasskeysUpdateWithBodyWithResponse request with any body
	PasskeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error)

	PasskeysUpdateWithResponse(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error)

	// PasswordlessEmailWithBodyWithResponse request with any body
	PasswordlessEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error)

	PasswordlessEmailWithResponse(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error)

	// PasswordlessMagicLinkWithBodyWithResponse request with any body
	PasswordlessMagicLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error)

	PasswordlessMagicLinkWithResponse(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error)

	// PasswordlessMethodsWithResponse request
	PasswordlessMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasswordlessMethodsResponse, error)

	// PasswordlessSmsWithBodyWithResponse request with any body
	PasswordlessSmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error)

	PasswordlessSmsWithResponse(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error)

	// PasswordlessVerifyWithBodyWithResponse request with any body
	PasswordlessVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error)

	PasswordlessVerifyWithResponse(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error)

	// AuthRefreshTokenWithBodyWithResponse request with any body
	AuthRefreshTokenWithBodyWithResponse(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error)

	AuthRefreshTokenWithResponse(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error)

	// AuthRegisterWithBodyWithResponse request with any body
	AuthRegisterWithBodyWithResponse(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error)

	AuthRegisterWithResponse(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error)

	// AuthResetPasswordWithBodyWithResponse request with any body
	AuthResetPasswordWithBodyWithResponse(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error)

	AuthResetPasswordWithResponse(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error)

	// AuthSendEmailVerificationWithBodyWithResponse request with any body
	AuthSendEmailVerificationWithBodyWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error)

	AuthSendEmailVerificationWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error)

	// SsoProviderCallbackWithResponse request
	SsoProviderCallbackWithResponse(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*SsoProviderCallbackResponse, error)

	// SsoListIdentityProvidersWithResponse request
	SsoListIdentityProvidersWithResponse(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*SsoListIdentityProvidersResponse, error)

	// SsoCreateIdentityProviderWithBodyWithResponse request with any body
	SsoCreateIdentityProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error)

	SsoCreateIdentityProviderWithResponse(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error)

	// SsoDeleteIdentityProviderWithResponse request
	SsoDeleteIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoDeleteIdentityProviderResponse, error)

	// SsoGetIdentityProviderWithResponse request
	SsoGetIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoGetIdentityProviderResponse, error)

	// SsoUpdateIdentityProviderWithBodyWithResponse request with any body
	SsoUpdateIdentityProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error)

	SsoUpdateIdentityProviderWithResponse(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error)

	// SsoListProvidersWithResponse request
	SsoListProvidersWithResponse(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*SsoListProvidersResponse, error)

	// SsoProviderAuthWithResponse request
	SsoProviderAuthWithResponse(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*SsoProviderAuthResponse, error)

	// SsoSamlAcsWithResponse request
	SsoSamlAcsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlAcsResponse, error)

	// SsoSamlMetadataWithResponse request
	SsoSamlMetadataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlMetadataResponse, error)

	// AuthVerifyEmailWithBodyWithResponse request with any body
	AuthVerifyEmailWithBodyWithResponse(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error)

	AuthVerifyEmailWithResponse(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error)

	// EmailSendWithBodyWithResponse request with any body
	EmailSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendResponse, error)

	EmailSendWithResponse(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendResponse, error)

	// EmailSendTemplateWithBodyWithResponse request with any body
	EmailSendTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error)

	EmailSendTemplateWithResponse(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error)

	// EmailListTemplatesWithResponse request
	EmailListTemplatesWithResponse(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*EmailListTemplatesResponse, error)

	// EmailCreateTemplateWithBodyWithResponse request with any body
	EmailCreateTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error)

	EmailCreateTemplateWithResponse(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error)

	// EmailGetTemplateByTypeWithResponse request
	EmailGetTemplateByTypeWithResponse(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*EmailGetTemplateByTypeResponse, error)

	// EmailDeleteTemplateWithResponse request
	EmailDeleteTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailDeleteTemplateResponse, error)

	// EmailGetTemplateWithResponse request
	EmailGetTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailGetTemplateResponse, error)

	// EmailUpdateTemplateWithBodyWithResponse request with any body
	EmailUpdateTemplateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error)

	EmailUpdateTemplateWithResponse(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error)

	// OauthProviderJwksWithResponse request
	OauthProviderJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderJwksResponse, error)

	// OauthProviderOidcConfigurationWithResponse request
	OauthProviderOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderOidcConfigurationResponse, error)

	// OauthProviderAuthorizeWithResponse request
	OauthProviderAuthorizeWithResponse(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*OauthProviderAuthorizeResponse, error)

	// OauthProviderListClientsWithResponse request
	OauthProviderListClientsWithResponse(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*OauthProviderListClientsResponse, error)

	// OauthProviderCreateClientWithBodyWithResponse request with any body
	OauthProviderCreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error)

	OauthProviderCreateClientWithResponse(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error)

	// OauthProviderDeleteClientWithResponse request
	OauthProviderDeleteClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteClientResponse, error)

	// OauthProviderGetClientWithResponse request
	OauthProviderGetClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetClientResponse, error)

	// OauthProviderUpdateClientWithBodyWithResponse request with any body
	OauthProviderUpdateClientWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error)

	OauthProviderUpdateClientWithResponse(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error)

	// OauthProviderRotateClientSecretWithResponse request
	OauthProviderRotateClientSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderRotateClientSecretResponse, error)

	// OauthProviderConsentWithBodyWithResponse request with any body
	OauthProviderConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error)

	OauthProviderConsentWithResponse(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error)

	// OauthProviderIntrospectWithResponse request
	OauthProviderIntrospectWithResponse(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*OauthProviderIntrospectResponse, error)

	// OauthProviderRevokeWithResponse request
	OauthProviderRevokeWithResponse(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*OauthProviderRevokeResponse, error)

	// OauthProviderListScopesWithResponse request
	OauthProviderListScopesWithResponse(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*OauthProviderListScopesResponse, error)

	// OauthProviderCreateScopeWithBodyWithResponse request with any body
	OauthProviderCreateScopeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error)

	OauthProviderCreateScopeWithResponse(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error)

	// OauthProviderDeleteScopeWithResponse request
	OauthProviderDeleteScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteScopeResponse, error)

	// OauthProviderGetScopeWithResponse request
	OauthProviderGetScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetScopeResponse, error)

	// OauthProviderUpdateScopeWithBodyWithResponse request with any body
	OauthProviderUpdateScopeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error)

	OauthProviderUpdateScopeWithResponse(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error)

	// OauthProviderTokenWithResponse request
	OauthProviderTokenWithResponse(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*OauthProviderTokenResponse, error)

	// OauthProviderUserinfoWithResponse request
	OauthProviderUserinfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderUserinfoResponse, error)

	// OrganizationsListWithResponse request
	OrganizationsListWithResponse(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*OrganizationsListResponse, error)

	// OrganizationsCreateWithBodyWithResponse request with any body
	OrganizationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error)

	OrganizationsCreateWithResponse(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error)

	// OrganizationsDeleteWithResponse request
	OrganizationsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsDeleteResponse, error)

	// OrganizationsGetWithResponse request
	OrganizationsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsGetResponse, error)

	// OrganizationsUpdateWithBodyWithResponse request with any body
	OrganizationsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error)

	OrganizationsUpdateWithResponse(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error)

	// OrganizationsListFeaturesWithResponse request
	OrganizationsListFeaturesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsListFeaturesResponse, error)

	// OrganizationsEnableFeatureWithBodyWithResponse request with any body
	OrganizationsEnableFeatureWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error)

	OrganizationsEnableFeatureWithResponse(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error)

	// OrganizationsDisableFeatureWithResponse request
	OrganizationsDisableFeatureWithResponse(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*OrganizationsDisableFeatureResponse, error)

	// OrganizationsListMembersWithResponse request
	OrganizationsListMembersWithResponse(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*OrganizationsListMembersResponse, error)

	// OrganizationsAddMemberWithBodyWithResponse request with any body
	OrganizationsAddMemberWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error)

	OrganizationsAddMemberWithResponse(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error)

	// OrganizationsRemoveMemberWithResponse request
	OrganizationsRemoveMemberWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*OrganizationsRemoveMemberResponse, error)

	// OrganizationsUpdateMemberWithBodyWithResponse request with any body
	OrganizationsUpdateMemberWithBodyWithResponse(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error)

	OrganizationsUpdateMemberWithResponse(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error)

	// RbacListPermissionsWithResponse request
	RbacListPermissionsWithResponse(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*RbacListPermissionsResponse, error)

	// RbacCreatePermissionWithBodyWithResponse request with any body
	RbacCreatePermissionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error)

	RbacCreatePermissionWithResponse(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error)

	// RbacDeletePermissionWithResponse request
	RbacDeletePermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeletePermissionResponse, error)

	// RbacGetPermissionWithResponse request
	RbacGetPermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetPermissionResponse, error)

	// RbacUpdatePermissionWithBodyWithResponse request with any body
	RbacUpdatePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error)

	RbacUpdatePermissionWithResponse(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error)

	// RbacListRolesWithResponse request
	RbacListRolesWithResponse(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*RbacListRolesResponse, error)

	// RbacCreateRoleWithBodyWithResponse request with any body
	RbacCreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error)

	RbacCreateRoleWithResponse(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error)

	// RbacDeleteRoleWithResponse request
	RbacDeleteRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeleteRoleResponse, error)

	// RbacGetRoleWithResponse request
	RbacGetRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetRoleResponse, error)

	// RbacUpdateRoleWithBodyWithResponse request with any body
	RbacUpdateRoleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error)

	RbacUpdateRoleWithResponse(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error)

	// RbacListRolePermissionsWithResponse request
	RbacListRolePermissionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacListRolePermissionsResponse, error)

	// RbacAddRolePermissionWithBodyWithResponse request with any body
	RbacAddRolePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error)

	RbacAddRolePermissionWithResponse(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error)

	// RbacRemoveRolePermissionWithResponse request
	RbacRemoveRolePermissionWithResponse(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*RbacRemoveRolePermissionResponse, error)

	// UsersListWithResponse request
	UsersListWithResponse(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*UsersListResponse, error)

	// UsersCreateWithBodyWithResponse request with any body
	UsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	UsersCreateWithResponse(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	// UsersUpdateMeWithBodyWithResponse request with any body
	UsersUpdateMeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error)

	UsersUpdateMeWithResponse(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error)

	// UsersUpdatePasswordWithBodyWithResponse request with any body
	UsersUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error)

	UsersUpdatePasswordWithResponse(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error)

	// UsersGetSessionsWithResponse request
	UsersGetSessionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsersGetSessionsResponse, error)

	// UsersDeleteSessionWithResponse request
	UsersDeleteSessionWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*UsersDeleteSessionResponse, error)

	// UsersDeleteWithResponse request
	UsersDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersDeleteResponse, error)

	// UsersGetWithResponse request
	UsersGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetResponse, error)

	// UsersUpdateWithBodyWithResponse request with any body
	UsersUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error)

	UsersUpdateWithResponse(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error)

	// UsersGetOrganizationsWithResponse request
	UsersGetOrganizationsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetOrganizationsResponse, error)

	// WebhooksListWithResponse request
	WebhooksListWithResponse(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error)

	// WebhooksCreateWithBodyWithResponse request with any body
	WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	// WebhooksReceiveWithResponse request
	WebhooksReceiveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksReceiveResponse, error)

	// WebhooksTriggerEventWithBodyWithResponse request with any body
	WebhooksTriggerEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error)

	WebhooksTriggerEventWithResponse(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error)

	// WebhooksDeleteWithResponse request
	WebhooksDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error)

	// WebhooksGetWithResponse request
	WebhooksGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error)

	// WebhooksUpdateWithBodyWithResponse request with any body
	WebhooksUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	WebhooksUpdateWithResponse(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	// WebhooksListEventsWithResponse request
	WebhooksListEventsWithResponse(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*WebhooksListEventsResponse, error)

	// WebhooksReplayEventWithResponse request
	WebhooksReplayEventWithResponse(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*WebhooksReplayEventResponse, error)
}

type HealthDebugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r HealthDebugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthDebugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
	JSON503      *HealthResponse
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsResponseBody
}

// Status returns HTTPResponse.Status
func (r HealthMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadyResponse
	JSON503      *ReadyResponse
}

// Status returns HTTPResponse.Status
func (r HealthReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionResponseBody
}

// Status returns HTTPResponse.Status
func (r HealthVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCheckPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckPermissionResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCheckPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCheckPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCheckRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckRoleResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCheckRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCheckRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *APIKeyWithSecretResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKeyResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKeyResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthCheckEmailVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthCheckEmailVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthCheckEmailVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthCsrfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CSRFTokenResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthCsrfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthCsrfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthForgotPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthForgotPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthForgotPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse2
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaEnrollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrollResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaEnrollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaEnrollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MethodsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaSendCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaSendCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaSendCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaUnenrollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaUnenrollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaUnenrollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthClientProviderCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProviderCallbackResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthClientProviderCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthClientProviderCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthClientListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProvidersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthClientListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthClientListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthClientProviderAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthClientProviderAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthClientProviderAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody3
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysLoginBeginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisterBeginResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysLoginBeginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysLoginBeginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysLoginCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginCompleteResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysLoginCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysLoginCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysRegisterBeginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisterBeginResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysRegisterBeginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysRegisterBeginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysRegisterCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisteredPasskey
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysRegisterCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysRegisterCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessMagicLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MagicLinkResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessMagicLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessMagicLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MethodsResponseBody2
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessSmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessSmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessSmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshTokenResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthRefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LoginResponse3
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthRegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthSendEmailVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthSendEmailVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthSendEmailVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoProviderCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProviderCallbackResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoProviderCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoProviderCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoListIdentityProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIdentityProvidersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoListIdentityProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoListIdentityProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoCreateIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IdentityProviderResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoCreateIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoCreateIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoDeleteIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoDeleteIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoDeleteIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoGetIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProviderResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoGetIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoGetIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoUpdateIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProviderResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoUpdateIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoUpdateIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProvidersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoProviderAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoProviderAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoProviderAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoSamlAcsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoSamlAcsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoSamlAcsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoSamlMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *SamlMetadataResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoSamlMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoSamlMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthVerifyEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthVerifyEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthVerifyEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailSendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailSendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailSendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailSendTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailSendTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailSendTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTemplatesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailCreateTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailCreateTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailCreateTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailGetTemplateByTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailGetTemplateByTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailGetTemplateByTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailDeleteTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailDeleteTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailDeleteTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailGetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailGetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailGetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailUpdateTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailUpdateTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailUpdateTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JwksResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderOidcConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcConfigurationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderOidcConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderOidcConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderAuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderAuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderAuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderListClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListClientsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderListClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderListClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderCreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OAuthClientWithSecretResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderCreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderCreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderDeleteClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderDeleteClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderDeleteClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderGetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthClientResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderGetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderGetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderUpdateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthClientResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderUpdateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderUpdateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderRotateClientSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RotateClientSecretResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderRotateClientSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderRotateClientSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON307      *ConsentResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderIntrospectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntrospectResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderIntrospectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderIntrospectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderListScopesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListScopesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderListScopesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderListScopesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderCreateScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OAuthScopeResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderCreateScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderCreateScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderDeleteScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderDeleteScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderDeleteScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderGetScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthScopeResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderGetScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderGetScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderUpdateScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthScopeResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderUpdateScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderUpdateScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderUserinfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserinfoResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderUserinfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderUserinfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody2
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Organization
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsListFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFeaturesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsListFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsListFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsEnableFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsEnableFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsEnableFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsDisableFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsDisableFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsDisableFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsListMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMembersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsListMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsListMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsAddMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsAddMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsAddMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsRemoveMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsRemoveMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsRemoveMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsUpdateMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsUpdateMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsUpdateMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacListPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPermissionsResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacListPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacListPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCreatePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PermissionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCreatePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCreatePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacDeletePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacDeletePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacDeletePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacGetPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacGetPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacGetPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacUpdatePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacUpdatePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacUpdatePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRolesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RoleResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacDeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacDeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacDeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacGetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacGetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacGetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacUpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacUpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacUpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacListRolePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRolePermissionsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacListRolePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacListRolePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacAddRolePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacAddRolePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacAddRolePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacRemoveRolePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacRemoveRolePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacRemoveRolePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody4
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdateMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersUpdateMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdateMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdatePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersUpdatePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdatePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserSessionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersGetSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersDeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrganizationsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersGetOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody5
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookSecretResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksReceiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksReceiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksReceiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksTriggerEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEventResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksTriggerEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksTriggerEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEventsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksReplayEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEventResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksReplayEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksReplayEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthDebugWithResponse request returning *HealthDebugResponse
func (c *ClientWithResponses) HealthDebugWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthDebugResponse, error) {
	rsp, err := c.HealthDebug(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthDebugResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// HealthMetricsWithResponse request returning *HealthMetricsResponse
func (c *ClientWithResponses) HealthMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthMetricsResponse, error) {
	rsp, err := c.HealthMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthMetricsResponse(rsp)
}

// HealthReadyWithResponse request returning *HealthReadyResponse
func (c *ClientWithResponses) HealthReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthReadyResponse, error) {
	rsp, err := c.HealthReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthReadyResponse(rsp)
}

// HealthVersionWithResponse request returning *HealthVersionResponse
func (c *ClientWithResponses) HealthVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthVersionResponse, error) {
	rsp, err := c.HealthVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthVersionResponse(rsp)
}

// RbacCheckPermissionWithResponse request returning *RbacCheckPermissionResponse
func (c *ClientWithResponses) RbacCheckPermissionWithResponse(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*RbacCheckPermissionResponse, error) {
	rsp, err := c.RbacCheckPermission(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCheckPermissionResponse(rsp)
}

// RbacCheckRoleWithResponse request returning *RbacCheckRoleResponse
func (c *ClientWithResponses) RbacCheckRoleWithResponse(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*RbacCheckRoleResponse, error) {
	rsp, err := c.RbacCheckRole(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCheckRoleResponse(rsp)
}

// ApiKeysListWithResponse request returning *ApiKeysListResponse
func (c *ClientWithResponses) ApiKeysListWithResponse(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*ApiKeysListResponse, error) {
	rsp, err := c.ApiKeysList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysListResponse(rsp)
}

// ApiKeysCreateWithBodyWithResponse request with arbitrary body returning *ApiKeysCreateResponse
func (c *ClientWithResponses) ApiKeysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error) {
	rsp, err := c.ApiKeysCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysCreateResponse(rsp)
}

func (c *ClientWithResponses) ApiKeysCreateWithResponse(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error) {
	rsp, err := c.ApiKeysCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysCreateResponse(rsp)
}

// ApiKeysValidateWithResponse request returning *ApiKeysValidateResponse
func (c *ClientWithResponses) ApiKeysValidateWithResponse(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*ApiKeysValidateResponse, error) {
	rsp, err := c.ApiKeysValidate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysValidateResponse(rsp)
}

// ApiKeysDeleteWithResponse request returning *ApiKeysDeleteResponse
func (c *ClientWithResponses) ApiKeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysDeleteResponse, error) {
	rsp, err := c.ApiKeysDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysDeleteResponse(rsp)
}

// ApiKeysGetWithResponse request returning *ApiKeysGetResponse
func (c *ClientWithResponses) ApiKeysGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysGetResponse, error) {
	rsp, err := c.ApiKeysGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysGetResponse(rsp)
}

// ApiKeysUpdateWithBodyWithResponse request with arbitrary body returning *ApiKeysUpdateResponse
func (c *ClientWithResponses) ApiKeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error) {
	rsp, err := c.ApiKeysUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysUpdateResponse(rsp)
}

func (c *ClientWithResponses) ApiKeysUpdateWithResponse(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error) {
	rsp, err := c.ApiKeysUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysUpdateResponse(rsp)
}

// AuthCheckEmailVerificationWithResponse request returning *AuthCheckEmailVerificationResponse
func (c *ClientWithResponses) AuthCheckEmailVerificationWithResponse(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*AuthCheckEmailVerificationResponse, error) {
	rsp, err := c.AuthCheckEmailVerification(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthCheckEmailVerificationResponse(rsp)
}

// AuthCsrfWithResponse request returning *AuthCsrfResponse
func (c *ClientWithResponses) AuthCsrfWithResponse(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*AuthCsrfResponse, error) {
	rsp, err := c.AuthCsrf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthCsrfResponse(rsp)
}

// AuthForgotPasswordWithBodyWithResponse request with arbitrary body returning *AuthForgotPasswordResponse
func (c *ClientWithResponses) AuthForgotPasswordWithBodyWithResponse(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error) {
	rsp, err := c.AuthForgotPasswordWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthForgotPasswordResponse(rsp)
}

func (c *ClientWithResponses) AuthForgotPasswordWithResponse(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error) {
	rsp, err := c.AuthForgotPassword(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthForgotPasswordResponse(rsp)
}

// AuthLoginWithBodyWithResponse request with arbitrary body returning *AuthLoginResponse
func (c *ClientWithResponses) AuthLoginWithBodyWithResponse(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) AuthLoginWithResponse(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLogin(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

// AuthLogoutWithResponse request returning *AuthLogoutResponse
func (c *ClientWithResponses) AuthLogoutWithResponse(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error) {
	rsp, err := c.AuthLogout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutResponse(rsp)
}

// AuthMeWithResponse request returning *AuthMeResponse
func (c *ClientWithResponses) AuthMeWithResponse(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*AuthMeResponse, error) {
	rsp, err := c.AuthMe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthMeResponse(rsp)
}

// MfaEnrollWithBodyWithResponse request with arbitrary body returning *MfaEnrollResponse
func (c *ClientWithResponses) MfaEnrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error) {
	rsp, err := c.MfaEnrollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaEnrollResponse(rsp)
}

func (c *ClientWithResponses) MfaEnrollWithResponse(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error) {
	rsp, err := c.MfaEnroll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaEnrollResponse(rsp)
}

// MfaMethodsWithResponse request returning *MfaMethodsResponse
func (c *ClientWithResponses) MfaMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MfaMethodsResponse, error) {
	rsp, err := c.MfaMethods(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaMethodsResponse(rsp)
}

// MfaSendCodeWithBodyWithResponse request with arbitrary body returning *MfaSendCodeResponse
func (c *ClientWithResponses) MfaSendCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error) {
	rsp, err := c.MfaSendCodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaSendCodeResponse(rsp)
}

func (c *ClientWithResponses) MfaSendCodeWithResponse(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error) {
	rsp, err := c.MfaSendCode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaSendCodeResponse(rsp)
}

// MfaUnenrollWithBodyWithResponse request with arbitrary body returning *MfaUnenrollResponse
func (c *ClientWithResponses) MfaUnenrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error) {
	rsp, err := c.MfaUnenrollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaUnenrollResponse(rsp)
}

func (c *ClientWithResponses) MfaUnenrollWithResponse(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error) {
	rsp, err := c.MfaUnenroll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaUnenrollResponse(rsp)
}

// MfaVerifyWithBodyWithResponse request with arbitrary body returning *MfaVerifyResponse
func (c *ClientWithResponses) MfaVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error) {
	rsp, err := c.MfaVerifyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaVerifyResponse(rsp)
}

func (c *ClientWithResponses) MfaVerifyWithResponse(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error) {
	rsp, err := c.MfaVerify(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaVerifyResponse(rsp)
}

// OauthClientProviderCallbackWithResponse request returning *OauthClientProviderCallbackResponse
func (c *ClientWithResponses) OauthClientProviderCallbackWithResponse(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*OauthClientProviderCallbackResponse, error) {
	rsp, err := c.OauthClientProviderCallback(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthClientProviderCallbackResponse(rsp)
}

// OauthClientListProvidersWithResponse request returning *OauthClientListProvidersResponse
func (c *ClientWithResponses) OauthClientListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthClientListProvidersResponse, error) {
	rsp, err := c.OauthClientListProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthClientListProvidersResponse(rsp)
}

// OauthClientProviderAuthWithResponse request returning *OauthClientProviderAuthResponse
func (c *ClientWithResponses) OauthClientProviderAuthWithResponse(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*OauthClientProviderAuthResponse, error) {
	rsp, err := c.OauthClientProviderAuth(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthClientProviderAuthResponse(rsp)
}

// PasskeysListWithResponse request returning *PasskeysListResponse
func (c *ClientWithResponses) PasskeysListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysListResponse, error) {
	rsp, err := c.PasskeysList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysListResponse(rsp)
}

// PasskeysLoginBeginWithResponse request returning *PasskeysLoginBeginResponse
func (c *ClientWithResponses) PasskeysLoginBeginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysLoginBeginResponse, error) {
	rsp, err := c.PasskeysLoginBegin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysLoginBeginResponse(rsp)
}

// PasskeysLoginCompleteWithBodyWithResponse request with arbitrary body returning *PasskeysLoginCompleteResponse
func (c *ClientWithResponses) PasskeysLoginCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error) {
	rsp, err := c.PasskeysLoginCompleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysLoginCompleteResponse(rsp)
}

func (c *ClientWithResponses) PasskeysLoginCompleteWithResponse(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error) {
	rsp, err := c.PasskeysLoginComplete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysLoginCompleteResponse(rsp)
}

// PasskeysRegisterBeginWithBodyWithResponse request with arbitrary body returning *PasskeysRegisterBeginResponse
func (c *ClientWithResponses) PasskeysRegisterBeginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error) {
	rsp, err := c.PasskeysRegisterBeginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterBeginResponse(rsp)
}

func (c *ClientWithResponses) PasskeysRegisterBeginWithResponse(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error) {
	rsp, err := c.PasskeysRegisterBegin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterBeginResponse(rsp)
}

// PasskeysRegisterCompleteWithBodyWithResponse request with arbitrary body returning *PasskeysRegisterCompleteResponse
func (c *ClientWithResponses) PasskeysRegisterCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error) {
	rsp, err := c.PasskeysRegisterCompleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterCompleteResponse(rsp)
}

func (c *ClientWithResponses) PasskeysRegisterCompleteWithResponse(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error) {
	rsp, err := c.PasskeysRegisterComplete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterCompleteResponse(rsp)
}

// PasskeysDeleteWithResponse request returning *PasskeysDeleteResponse
func (c *ClientWithResponses) PasskeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PasskeysDeleteResponse, error) {
	rsp, err := c.PasskeysDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysDeleteResponse(rsp)
}

// PasskeysUpdateWithBodyWithResponse request with arbitrary body returning *PasskeysUpdateResponse
func (c *ClientWithResponses) PasskeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error) {
	rsp, err := c.PasskeysUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysUpdateResponse(rsp)
}

func (c *ClientWithResponses) PasskeysUpdateWithResponse(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error) {
	rsp, err := c.PasskeysUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysUpdateResponse(rsp)
}

// PasswordlessEmailWithBodyWithResponse request with arbitrary body returning *PasswordlessEmailResponse
func (c *ClientWithResponses) PasswordlessEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error) {
	rsp, err := c.PasswordlessEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessEmailResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessEmailWithResponse(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error) {
	rsp, err := c.PasswordlessEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessEmailResponse(rsp)
}

// PasswordlessMagicLinkWithBodyWithResponse request with arbitrary body returning *PasswordlessMagicLinkResponse
func (c *ClientWithResponses) PasswordlessMagicLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error) {
	rsp, err := c.PasswordlessMagicLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessMagicLinkResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessMagicLinkWithResponse(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error) {
	rsp, err := c.PasswordlessMagicLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessMagicLinkResponse(rsp)
}

// PasswordlessMethodsWithResponse request returning *PasswordlessMethodsResponse
func (c *ClientWithResponses) PasswordlessMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasswordlessMethodsResponse, error) {
	rsp, err := c.PasswordlessMethods(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessMethodsResponse(rsp)
}

// PasswordlessSmsWithBodyWithResponse request with arbitrary body returning *PasswordlessSmsResponse
func (c *ClientWithResponses) PasswordlessSmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error) {
	rsp, err := c.PasswordlessSmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessSmsResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessSmsWithResponse(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error) {
	rsp, err := c.PasswordlessSms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessSmsResponse(rsp)
}

// PasswordlessVerifyWithBodyWithResponse request with arbitrary body returning *PasswordlessVerifyResponse
func (c *ClientWithResponses) PasswordlessVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error) {
	rsp, err := c.PasswordlessVerifyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessVerifyResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessVerifyWithResponse(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error) {
	rsp, err := c.PasswordlessVerify(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessVerifyResponse(rsp)
}

// AuthRefreshTokenWithBodyWithResponse request with arbitrary body returning *AuthRefreshTokenResponse
func (c *ClientWithResponses) AuthRefreshTokenWithBodyWithResponse(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error) {
	rsp, err := c.AuthRefreshTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) AuthRefreshTokenWithResponse(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error) {
	rsp, err := c.AuthRefreshToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRefreshTokenResponse(rsp)
}

// AuthRegisterWithBodyWithResponse request with arbitrary body returning *AuthRegisterResponse
func (c *ClientWithResponses) AuthRegisterWithBodyWithResponse(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error) {
	rsp, err := c.AuthRegisterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegisterResponse(rsp)
}

func (c *ClientWithResponses) AuthRegisterWithResponse(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error) {
	rsp, err := c.AuthRegister(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegisterResponse(rsp)
}

// AuthResetPasswordWithBodyWithResponse request with arbitrary body returning *AuthResetPasswordResponse
func (c *ClientWithResponses) AuthResetPasswordWithBodyWithResponse(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error) {
	rsp, err := c.AuthResetPasswordWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) AuthResetPasswordWithResponse(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error) {
	rsp, err := c.AuthResetPassword(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthResetPasswordResponse(rsp)
}

// AuthSendEmailVerificationWithBodyWithResponse request with arbitrary body returning *AuthSendEmailVerificationResponse
func (c *ClientWithResponses) AuthSendEmailVerificationWithBodyWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error) {
	rsp, err := c.AuthSendEmailVerificationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthSendEmailVerificationResponse(rsp)
}

func (c *ClientWithResponses) AuthSendEmailVerificationWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error) {
	rsp, err := c.AuthSendEmailVerification(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthSendEmailVerificationResponse(rsp)
}

// SsoProviderCallbackWithResponse request returning *SsoProviderCallbackResponse
func (c *ClientWithResponses) SsoProviderCallbackWithResponse(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*SsoProviderCallbackResponse, error) {
	rsp, err := c.SsoProviderCallback(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoProviderCallbackResponse(rsp)
}

// SsoListIdentityProvidersWithResponse request returning *SsoListIdentityProvidersResponse
func (c *ClientWithResponses) SsoListIdentityProvidersWithResponse(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*SsoListIdentityProvidersResponse, error) {
	rsp, err := c.SsoListIdentityProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoListIdentityProvidersResponse(rsp)
}

// SsoCreateIdentityProviderWithBodyWithResponse request with arbitrary body returning *SsoCreateIdentityProviderResponse
func (c *ClientWithResponses) SsoCreateIdentityProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error) {
	rsp, err := c.SsoCreateIdentityProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoCreateIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) SsoCreateIdentityProviderWithResponse(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error) {
	rsp, err := c.SsoCreateIdentityProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoCreateIdentityProviderResponse(rsp)
}

// SsoDeleteIdentityProviderWithResponse request returning *SsoDeleteIdentityProviderResponse
func (c *ClientWithResponses) SsoDeleteIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoDeleteIdentityProviderResponse, error) {
	rsp, err := c.SsoDeleteIdentityProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoDeleteIdentityProviderResponse(rsp)
}

// SsoGetIdentityProviderWithResponse request returning *SsoGetIdentityProviderResponse
func (c *ClientWithResponses) SsoGetIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoGetIdentityProviderResponse, error) {
	rsp, err := c.SsoGetIdentityProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoGetIdentityProviderResponse(rsp)
}

// SsoUpdateIdentityProviderWithBodyWithResponse request with arbitrary body returning *SsoUpdateIdentityProviderResponse
func (c *ClientWithResponses) SsoUpdateIdentityProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error) {
	rsp, err := c.SsoUpdateIdentityProviderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoUpdateIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) SsoUpdateIdentityProviderWithResponse(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error) {
	rsp, err := c.SsoUpdateIdentityProvider(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoUpdateIdentityProviderResponse(rsp)
}

// SsoListProvidersWithResponse request returning *SsoListProvidersResponse
func (c *ClientWithResponses) SsoListProvidersWithResponse(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*SsoListProvidersResponse, error) {
	rsp, err := c.SsoListProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoListProvidersResponse(rsp)
}

// SsoProviderAuthWithResponse request returning *SsoProviderAuthResponse
func (c *ClientWithResponses) SsoProviderAuthWithResponse(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*SsoProviderAuthResponse, error) {
	rsp, err := c.SsoProviderAuth(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoProviderAuthResponse(rsp)
}

// SsoSamlAcsWithResponse request returning *SsoSamlAcsResponse
func (c *ClientWithResponses) SsoSamlAcsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlAcsResponse, error) {
	rsp, err := c.SsoSamlAcs(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoSamlAcsResponse(rsp)
}

// SsoSamlMetadataWithResponse request returning *SsoSamlMetadataResponse
func (c *ClientWithResponses) SsoSamlMetadataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlMetadataResponse, error) {
	rsp, err := c.SsoSamlMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoSamlMetadataResponse(rsp)
}

// AuthVerifyEmailWithBodyWithResponse request with arbitrary body returning *AuthVerifyEmailResponse
func (c *ClientWithResponses) AuthVerifyEmailWithBodyWithResponse(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error) {
	rsp, err := c.AuthVerifyEmailWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthVerifyEmailResponse(rsp)
}

func (c *ClientWithResponses) AuthVerifyEmailWithResponse(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error) {
	rsp, err := c.AuthVerifyEmail(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthVerifyEmailResponse(rsp)
}

// EmailSendWithBodyWithResponse request with arbitrary body returning *EmailSendResponse
func (c *ClientWithResponses) EmailSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendResponse, error) {
	rsp, err := c.EmailSendWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendResponse(rsp)
}

func (c *ClientWithResponses) EmailSendWithResponse(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendResponse, error) {
	rsp, err := c.EmailSend(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendResponse(rsp)
}

// EmailSendTemplateWithBodyWithResponse request with arbitrary body returning *EmailSendTemplateResponse
func (c *ClientWithResponses) EmailSendTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error) {
	rsp, err := c.EmailSendTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendTemplateResponse(rsp)
}

func (c *ClientWithResponses) EmailSendTemplateWithResponse(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error) {
	rsp, err := c.EmailSendTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendTemplateResponse(rsp)
}

// EmailListTemplatesWithResponse request returning *EmailListTemplatesResponse
func (c *ClientWithResponses) EmailListTemplatesWithResponse(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*EmailListTemplatesResponse, error) {
	rsp, err := c.EmailListTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailListTemplatesResponse(rsp)
}

// EmailCreateTemplateWithBodyWithResponse request with arbitrary body returning *EmailCreateTemplateResponse
func (c *ClientWithResponses) EmailCreateTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error) {
	rsp, err := c.EmailCreateTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailCreateTemplateResponse(rsp)
}

func (c *ClientWithResponses) EmailCreateTemplateWithResponse(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error) {
	rsp, err := c.EmailCreateTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailCreateTemplateResponse(rsp)
}

// EmailGetTemplateByTypeWithResponse request returning *EmailGetTemplateByTypeResponse
func (c *ClientWithResponses) EmailGetTemplateByTypeWithResponse(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*EmailGetTemplateByTypeResponse, error) {
	rsp, err := c.EmailGetTemplateByType(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailGetTemplateByTypeResponse(rsp)
}

// EmailDeleteTemplateWithResponse request returning *EmailDeleteTemplateResponse
func (c *ClientWithResponses) EmailDeleteTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailDeleteTemplateResponse, error) {
	rsp, err := c.EmailDeleteTemplate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailDeleteTemplateResponse(rsp)
}

// EmailGetTemplateWithResponse request returning *EmailGetTemplateResponse
func (c *ClientWithResponses) EmailGetTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailGetTemplateResponse, error) {
	rsp, err := c.EmailGetTemplate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailGetTemplateResponse(rsp)
}

// EmailUpdateTemplateWithBodyWithResponse request with arbitrary body returning *EmailUpdateTemplateResponse
func (c *ClientWithResponses) EmailUpdateTemplateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error) {
	rsp, err := c.EmailUpdateTemplateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailUpdateTemplateResponse(rsp)
}

func (c *ClientWithResponses) EmailUpdateTemplateWithResponse(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error) {
	rsp, err := c.EmailUpdateTemplate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailUpdateTemplateResponse(rsp)
}

// OauthProviderJwksWithResponse request returning *OauthProviderJwksResponse
func (c *ClientWithResponses) OauthProviderJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderJwksResponse, error) {
	rsp, err := c.OauthProviderJwks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderJwksResponse(rsp)
}

// OauthProviderOidcConfigurationWithResponse request returning *OauthProviderOidcConfigurationResponse
func (c *ClientWithResponses) OauthProviderOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderOidcConfigurationResponse, error) {
	rsp, err := c.OauthProviderOidcConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderOidcConfigurationResponse(rsp)
}

// OauthProviderAuthorizeWithResponse request returning *OauthProviderAuthorizeResponse
func (c *ClientWithResponses) OauthProviderAuthorizeWithResponse(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*OauthProviderAuthorizeResponse, error) {
	rsp, err := c.OauthProviderAuthorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderAuthorizeResponse(rsp)
}

// OauthProviderListClientsWithResponse request returning *OauthProviderListClientsResponse
func (c *ClientWithResponses) OauthProviderListClientsWithResponse(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*OauthProviderListClientsResponse, error) {
	rsp, err := c.OauthProviderListClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderListClientsResponse(rsp)
}

// OauthProviderCreateClientWithBodyWithResponse request with arbitrary body returning *OauthProviderCreateClientResponse
func (c *ClientWithResponses) OauthProviderCreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error) {
	rsp, err := c.OauthProviderCreateClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateClientResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderCreateClientWithResponse(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error) {
	rsp, err := c.OauthProviderCreateClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateClientResponse(rsp)
}

// OauthProviderDeleteClientWithResponse request returning *OauthProviderDeleteClientResponse
func (c *ClientWithResponses) OauthProviderDeleteClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteClientResponse, error) {
	rsp, err := c.OauthProviderDeleteClient(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderDeleteClientResponse(rsp)
}

// OauthProviderGetClientWithResponse request returning *OauthProviderGetClientResponse
func (c *ClientWithResponses) OauthProviderGetClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetClientResponse, error) {
	rsp, err := c.OauthProviderGetClient(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderGetClientResponse(rsp)
}

// OauthProviderUpdateClientWithBodyWithResponse request with arbitrary body returning *OauthProviderUpdateClientResponse
func (c *ClientWithResponses) OauthProviderUpdateClientWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error) {
	rsp, err := c.OauthProviderUpdateClientWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateClientResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderUpdateClientWithResponse(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error) {
	rsp, err := c.OauthProviderUpdateClient(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateClientResponse(rsp)
}

// OauthProviderRotateClientSecretWithResponse request returning *OauthProviderRotateClientSecretResponse
func (c *ClientWithResponses) OauthProviderRotateClientSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderRotateClientSecretResponse, error) {
	rsp, err := c.OauthProviderRotateClientSecret(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderRotateClientSecretResponse(rsp)
}

// OauthProviderConsentWithBodyWithResponse request with arbitrary body returning *OauthProviderConsentResponse
func (c *ClientWithResponses) OauthProviderConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error) {
	rsp, err := c.OauthProviderConsentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderConsentResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderConsentWithResponse(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error) {
	rsp, err := c.OauthProviderConsent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderConsentResponse(rsp)
}

// OauthProviderIntrospectWithResponse request returning *OauthProviderIntrospectResponse
func (c *ClientWithResponses) OauthProviderIntrospectWithResponse(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*OauthProviderIntrospectResponse, error) {
	rsp, err := c.OauthProviderIntrospect(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderIntrospectResponse(rsp)
}

// OauthProviderRevokeWithResponse request returning *OauthProviderRevokeResponse
func (c *ClientWithResponses) OauthProviderRevokeWithResponse(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*OauthProviderRevokeResponse, error) {
	rsp, err := c.OauthProviderRevoke(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderRevokeResponse(rsp)
}

// OauthProviderListScopesWithResponse request returning *OauthProviderListScopesResponse
func (c *ClientWithResponses) OauthProviderListScopesWithResponse(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*OauthProviderListScopesResponse, error) {
	rsp, err := c.OauthProviderListScopes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderListScopesResponse(rsp)
}

// OauthProviderCreateScopeWithBodyWithResponse request with arbitrary body returning *OauthProviderCreateScopeResponse
func (c *ClientWithResponses) OauthProviderCreateScopeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error) {
	rsp, err := c.OauthProviderCreateScopeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateScopeResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderCreateScopeWithResponse(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error) {
	rsp, err := c.OauthProviderCreateScope(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateScopeResponse(rsp)
}

// OauthProviderDeleteScopeWithResponse request returning *OauthProviderDeleteScopeResponse
func (c *ClientWithResponses) OauthProviderDeleteScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteScopeResponse, error) {
	rsp, err := c.OauthProviderDeleteScope(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderDeleteScopeResponse(rsp)
}

// OauthProviderGetScopeWithResponse request returning *OauthProviderGetScopeResponse
func (c *ClientWithResponses) OauthProviderGetScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetScopeResponse, error) {
	rsp, err := c.OauthProviderGetScope(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderGetScopeResponse(rsp)
}

// OauthProviderUpdateScopeWithBodyWithResponse request with arbitrary body returning *OauthProviderUpdateScopeResponse
func (c *ClientWithResponses) OauthProviderUpdateScopeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error) {
	rsp, err := c.OauthProviderUpdateScopeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateScopeResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderUpdateScopeWithResponse(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error) {
	rsp, err := c.OauthProviderUpdateScope(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateScopeResponse(rsp)
}

// OauthProviderTokenWithResponse request returning *OauthProviderTokenResponse
func (c *ClientWithResponses) OauthProviderTokenWithResponse(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*OauthProviderTokenResponse, error) {
	rsp, err := c.OauthProviderToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderTokenResponse(rsp)
}

// OauthProviderUserinfoWithResponse request returning *OauthProviderUserinfoResponse
func (c *ClientWithResponses) OauthProviderUserinfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderUserinfoResponse, error) {
	rsp, err := c.OauthProviderUserinfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUserinfoResponse(rsp)
}

// OrganizationsListWithResponse request returning *OrganizationsListResponse
func (c *ClientWithResponses) OrganizationsListWithResponse(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*OrganizationsListResponse, error) {
	rsp, err := c.OrganizationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsListResponse(rsp)
}

// OrganizationsCreateWithBodyWithResponse request with arbitrary body returning *OrganizationsCreateResponse
func (c *ClientWithResponses) OrganizationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error) {
	rsp, err := c.OrganizationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsCreateResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsCreateWithResponse(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error) {
	rsp, err := c.OrganizationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsCreateResponse(rsp)
}

// OrganizationsDeleteWithResponse request returning *OrganizationsDeleteResponse
func (c *ClientWithResponses) OrganizationsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsDeleteResponse, error) {
	rsp, err := c.OrganizationsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsDeleteResponse(rsp)
}

// OrganizationsGetWithResponse request returning *OrganizationsGetResponse
func (c *ClientWithResponses) OrganizationsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsGetResponse, error) {
	rsp, err := c.OrganizationsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsGetResponse(rsp)
}

// OrganizationsUpdateWithBodyWithResponse request with arbitrary body returning *OrganizationsUpdateResponse
func (c *ClientWithResponses) OrganizationsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error) {
	rsp, err := c.OrganizationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsUpdateWithResponse(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error) {
	rsp, err := c.OrganizationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateResponse(rsp)
}

// OrganizationsListFeaturesWithResponse request returning *OrganizationsListFeaturesResponse
func (c *ClientWithResponses) OrganizationsListFeaturesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsListFeaturesResponse, error) {
	rsp, err := c.OrganizationsListFeatures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsListFeaturesResponse(rsp)
}

// OrganizationsEnableFeatureWithBodyWithResponse request with arbitrary body returning *OrganizationsEnableFeatureResponse
func (c *ClientWithResponses) OrganizationsEnableFeatureWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error) {
	rsp, err := c.OrganizationsEnableFeatureWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsEnableFeatureResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsEnableFeatureWithResponse(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error) {
	rsp, err := c.OrganizationsEnableFeature(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsEnableFeatureResponse(rsp)
}

// OrganizationsDisableFeatureWithResponse request returning *OrganizationsDisableFeatureResponse
func (c *ClientWithResponses) OrganizationsDisableFeatureWithResponse(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*OrganizationsDisableFeatureResponse, error) {
	rsp, err := c.OrganizationsDisableFeature(ctx, id, featureKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsDisableFeatureResponse(rsp)
}

// OrganizationsListMembersWithResponse request returning *OrganizationsListMembersResponse
func (c *ClientWithResponses) OrganizationsListMembersWithResponse(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*OrganizationsListMembersResponse, error) {
	rsp, err := c.OrganizationsListMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsListMembersResponse(rsp)
}

// OrganizationsAddMemberWithBodyWithResponse request with arbitrary body returning *OrganizationsAddMemberResponse
func (c *ClientWithResponses) OrganizationsAddMemberWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error) {
	rsp, err := c.OrganizationsAddMemberWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsAddMemberResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsAddMemberWithResponse(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error) {
	rsp, err := c.OrganizationsAddMember(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsAddMemberResponse(rsp)
}

// OrganizationsRemoveMemberWithResponse request returning *OrganizationsRemoveMemberResponse
func (c *ClientWithResponses) OrganizationsRemoveMemberWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*OrganizationsRemoveMemberResponse, error) {
	rsp, err := c.OrganizationsRemoveMember(ctx, id, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsRemoveMemberResponse(rsp)
}

// OrganizationsUpdateMemberWithBodyWithResponse request with arbitrary body returning *OrganizationsUpdateMemberResponse
func (c *ClientWithResponses) OrganizationsUpdateMemberWithBodyWithResponse(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error) {
	rsp, err := c.OrganizationsUpdateMemberWithBody(ctx, id, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateMemberResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsUpdateMemberWithResponse(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error) {
	rsp, err := c.OrganizationsUpdateMember(ctx, id, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateMemberResponse(rsp)
}

// RbacListPermissionsWithResponse request returning *RbacListPermissionsResponse
func (c *ClientWithResponses) RbacListPermissionsWithResponse(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*RbacListPermissionsResponse, error) {
	rsp, err := c.RbacListPermissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacListPermissionsResponse(rsp)
}

// RbacCreatePermissionWithBodyWithResponse request with arbitrary body returning *RbacCreatePermissionResponse
func (c *ClientWithResponses) RbacCreatePermissionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error) {
	rsp, err := c.RbacCreatePermissionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreatePermissionResponse(rsp)
}

func (c *ClientWithResponses) RbacCreatePermissionWithResponse(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error) {
	rsp, err := c.RbacCreatePermission(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreatePermissionResponse(rsp)
}

// RbacDeletePermissionWithResponse request returning *RbacDeletePermissionResponse
func (c *ClientWithResponses) RbacDeletePermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeletePermissionResponse, error) {
	rsp, err := c.RbacDeletePermission(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacDeletePermissionResponse(rsp)
}

// RbacGetPermissionWithResponse request returning *RbacGetPermissionResponse
func (c *ClientWithResponses) RbacGetPermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetPermissionResponse, error) {
	rsp, err := c.RbacGetPermission(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacGetPermissionResponse(rsp)
}

// RbacUpdatePermissionWithBodyWithResponse request with arbitrary body returning *RbacUpdatePermissionResponse
func (c *ClientWithResponses) RbacUpdatePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error) {
	rsp, err := c.RbacUpdatePermissionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdatePermissionResponse(rsp)
}

func (c *ClientWithResponses) RbacUpdatePermissionWithResponse(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error) {
	rsp, err := c.RbacUpdatePermission(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdatePermissionResponse(rsp)
}

// RbacListRolesWithResponse request returning *RbacListRolesResponse
func (c *ClientWithResponses) RbacListRolesWithResponse(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*RbacListRolesResponse, error) {
	rsp, err := c.RbacListRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacListRolesResponse(rsp)
}

// RbacCreateRoleWithBodyWithResponse request with arbitrary body returning *RbacCreateRoleResponse
func (c *ClientWithResponses) RbacCreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error) {
	rsp, err := c.RbacCreateRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) RbacCreateRoleWithResponse(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error) {
	rsp, err := c.RbacCreateRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreateRoleResponse(rsp)
}

// RbacDeleteRoleWithResponse request returning *RbacDeleteRoleResponse
func (c *ClientWithResponses) RbacDeleteRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeleteRoleResponse, error) {
	rsp, err := c.RbacDeleteRole(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacDeleteRoleResponse(rsp)
}

// RbacGetRoleWithResponse request returning *RbacGetRoleResponse
func (c *ClientWithResponses) RbacGetRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetRoleResponse, error) {
	rsp, err := c.RbacGetRole(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacGetRoleResponse(rsp)
}

// RbacUpdateRoleWithBodyWithResponse request with arbitrary body returning *RbacUpdateRoleResponse
func (c *ClientWithResponses) RbacUpdateRoleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error) {
	rsp, err := c.RbacUpdateRoleWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) RbacUpdateRoleWithResponse(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error) {
	rsp, err := c.RbacUpdateRole(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdateRoleResponse(rsp)
}

// RbacListRolePermissionsWithResponse request returning *RbacListRolePermissionsResponse
func (c *ClientWithResponses) RbacListRolePermissionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacListRolePermissionsResponse, error) {
	rsp, err := c.RbacListRolePermissions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacListRolePermissionsResponse(rsp)
}

// RbacAddRolePermissionWithBodyWithResponse request with arbitrary body returning *RbacAddRolePermissionResponse
func (c *ClientWithResponses) RbacAddRolePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error) {
	rsp, err := c.RbacAddRolePermissionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacAddRolePermissionResponse(rsp)
}

func (c *ClientWithResponses) RbacAddRolePermissionWithResponse(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error) {
	rsp, err := c.RbacAddRolePermission(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacAddRolePermissionResponse(rsp)
}

// RbacRemoveRolePermissionWithResponse request returning *RbacRemoveRolePermissionResponse
func (c *ClientWithResponses) RbacRemoveRolePermissionWithResponse(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*RbacRemoveRolePermissionResponse, error) {
	rsp, err := c.RbacRemoveRolePermission(ctx, id, permissionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacRemoveRolePermissionResponse(rsp)
}

// UsersListWithResponse request returning *UsersListResponse
func (c *ClientWithResponses) UsersListWithResponse(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*UsersListResponse, error) {
	rsp, err := c.UsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersListResponse(rsp)
}

// UsersCreateWithBodyWithResponse request with arbitrary body returning *UsersCreateResponse
func (c *ClientWithResponses) UsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) UsersCreateWithResponse(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

// UsersUpdateMeWithBodyWithResponse request with arbitrary body returning *UsersUpdateMeResponse
func (c *ClientWithResponses) UsersUpdateMeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error) {
	rsp, err := c.UsersUpdateMeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateMeResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdateMeWithResponse(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error) {
	rsp, err := c.UsersUpdateMe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateMeResponse(rsp)
}

// UsersUpdatePasswordWithBodyWithResponse request with arbitrary body returning *UsersUpdatePasswordResponse
func (c *ClientWithResponses) UsersUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error) {
	rsp, err := c.UsersUpdatePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePasswordResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdatePasswordWithResponse(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error) {
	rsp, err := c.UsersUpdatePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePasswordResponse(rsp)
}

// UsersGetSessionsWithResponse request returning *UsersGetSessionsResponse
func (c *ClientWithResponses) UsersGetSessionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsersGetSessionsResponse, error) {
	rsp, err := c.UsersGetSessions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetSessionsResponse(rsp)
}

// UsersDeleteSessionWithResponse request returning *UsersDeleteSessionResponse
func (c *ClientWithResponses) UsersDeleteSessionWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*UsersDeleteSessionResponse, error) {
	rsp, err := c.UsersDeleteSession(ctx, sessionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDeleteSessionResponse(rsp)
}

// UsersDeleteWithResponse request returning *UsersDeleteResponse
func (c *ClientWithResponses) UsersDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersDeleteResponse, error) {
	rsp, err := c.UsersDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDeleteResponse(rsp)
}

// UsersGetWithResponse request returning *UsersGetResponse
func (c *ClientWithResponses) UsersGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetResponse, error) {
	rsp, err := c.UsersGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetResponse(rsp)
}

// UsersUpdateWithBodyWithResponse request with arbitrary body returning *UsersUpdateResponse
func (c *ClientWithResponses) UsersUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error) {
	rsp, err := c.UsersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdateWithResponse(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error) {
	rsp, err := c.UsersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateResponse(rsp)
}

// UsersGetOrganizationsWithResponse request returning *UsersGetOrganizationsResponse
func (c *ClientWithResponses) UsersGetOrganizationsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetOrganizationsResponse, error) {
	rsp, err := c.UsersGetOrganizations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetOrganizationsResponse(rsp)
}

// WebhooksListWithResponse request returning *WebhooksListResponse
func (c *ClientWithResponses) WebhooksListWithResponse(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error) {
	rsp, err := c.WebhooksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListResponse(rsp)
}

// WebhooksCreateWithBodyWithResponse request with arbitrary body returning *WebhooksCreateResponse
func (c *ClientWithResponses) WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

// WebhooksReceiveWithResponse request returning *WebhooksReceiveResponse
func (c *ClientWithResponses) WebhooksReceiveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksReceiveResponse, error) {
	rsp, err := c.WebhooksReceive(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksReceiveResponse(rsp)
}

// WebhooksTriggerEventWithBodyWithResponse request with arbitrary body returning *WebhooksTriggerEventResponse
func (c *ClientWithResponses) WebhooksTriggerEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error) {
	rsp, err := c.WebhooksTriggerEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksTriggerEventResponse(rsp)
}

func (c *ClientWithResponses) WebhooksTriggerEventWithResponse(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error) {
	rsp, err := c.WebhooksTriggerEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksTriggerEventResponse(rsp)
}

// WebhooksDeleteWithResponse request returning *WebhooksDeleteResponse
func (c *ClientWithResponses) WebhooksDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error) {
	rsp, err := c.WebhooksDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksDeleteResponse(rsp)
}

// WebhooksGetWithResponse request returning *WebhooksGetResponse
func (c *ClientWithResponses) WebhooksGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error) {
	rsp, err := c.WebhooksGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetResponse(rsp)
}

// WebhooksUpdateWithBodyWithResponse request with arbitrary body returning *WebhooksUpdateResponse
func (c *ClientWithResponses) WebhooksUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksUpdateWithResponse(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

// WebhooksListEventsWithResponse request returning *WebhooksListEventsResponse
func (c *ClientWithResponses) WebhooksListEventsWithResponse(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*WebhooksListEventsResponse, error) {
	rsp, err := c.WebhooksListEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListEventsResponse(rsp)
}

// WebhooksReplayEventWithResponse request returning *WebhooksReplayEventResponse
func (c *ClientWithResponses) WebhooksReplayEventWithResponse(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*WebhooksReplayEventResponse, error) {
	rsp, err := c.WebhooksReplayEvent(ctx, id, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksReplayEventResponse(rsp)
}

// ParseHealthDebugResponse parses an HTTP response from a HealthDebugWithResponse call
func ParseHealthDebugResponse(rsp *http.Response) (*HealthDebugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthDebugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseHealthMetricsResponse parses an HTTP response from a HealthMetricsWithResponse call
func ParseHealthMetricsResponse(rsp *http.Response) (*HealthMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHealthReadyResponse parses an HTTP response from a HealthReadyWithResponse call
func ParseHealthReadyResponse(rsp *http.Response) (*HealthReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ReadyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseHealthVersionResponse parses an HTTP response from a HealthVersionWithResponse call
func ParseHealthVersionResponse(rsp *http.Response) (*HealthVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRbacCheckPermissionResponse parses an HTTP response from a RbacCheckPermissionWithResponse call
func ParseRbacCheckPermissionResponse(rsp *http.Response) (*RbacCheckPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCheckPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckPermissionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacCheckRoleResponse parses an HTTP response from a RbacCheckRoleWithResponse call
func ParseRbacCheckRoleResponse(rsp *http.Response) (*RbacCheckRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCheckRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckRoleResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysListResponse parses an HTTP response from a ApiKeysListWithResponse call
func ParseApiKeysListResponse(rsp *http.Response) (*ApiKeysListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysCreateResponse parses an HTTP response from a ApiKeysCreateWithResponse call
func ParseApiKeysCreateResponse(rsp *http.Response) (*ApiKeysCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest APIKeyWithSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysValidateResponse parses an HTTP response from a ApiKeysValidateWithResponse call
func ParseApiKeysValidateResponse(rsp *http.Response) (*ApiKeysValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysDeleteResponse parses an HTTP response from a ApiKeysDeleteWithResponse call
func ParseApiKeysDeleteResponse(rsp *http.Response) (*ApiKeysDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysGetResponse parses an HTTP response from a ApiKeysGetWithResponse call
func ParseApiKeysGetResponse(rsp *http.Response) (*ApiKeysGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysUpdateResponse parses an HTTP response from a ApiKeysUpdateWithResponse call
func ParseApiKeysUpdateResponse(rsp *http.Response) (*ApiKeysUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthCheckEmailVerificationResponse parses an HTTP response from a AuthCheckEmailVerificationWithResponse call
func ParseAuthCheckEmailVerificationResponse(rsp *http.Response) (*AuthCheckEmailVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthCheckEmailVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthCsrfResponse parses an HTTP response from a AuthCsrfWithResponse call
func ParseAuthCsrfResponse(rsp *http.Response) (*AuthCsrfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthCsrfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CSRFTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthForgotPasswordResponse parses an HTTP response from a AuthForgotPasswordWithResponse call
func ParseAuthForgotPasswordResponse(rsp *http.Response) (*AuthForgotPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthForgotPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLoginResponse parses an HTTP response from a AuthLoginWithResponse call
func ParseAuthLoginResponse(rsp *http.Response) (*AuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLogoutResponse parses an HTTP response from a AuthLogoutWithResponse call
func ParseAuthLogoutResponse(rsp *http.Response) (*AuthLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthMeResponse parses an HTTP response from a AuthMeWithResponse call
func ParseAuthMeResponse(rsp *http.Response) (*AuthMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaEnrollResponse parses an HTTP response from a MfaEnrollWithResponse call
func ParseMfaEnrollResponse(rsp *http.Response) (*MfaEnrollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaEnrollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrollResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaMethodsResponse parses an HTTP response from a MfaMethodsWithResponse call
func ParseMfaMethodsResponse(rsp *http.Response) (*MfaMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MethodsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaSendCodeResponse parses an HTTP response from a MfaSendCodeWithResponse call
func ParseMfaSendCodeResponse(rsp *http.Response) (*MfaSendCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaSendCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaUnenrollResponse parses an HTTP response from a MfaUnenrollWithResponse call
func ParseMfaUnenrollResponse(rsp *http.Response) (*MfaUnenrollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaUnenrollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaVerifyResponse parses an HTTP response from a MfaVerifyWithResponse call
func ParseMfaVerifyResponse(rsp *http.Response) (*MfaVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthClientProviderCallbackResponse parses an HTTP response from a OauthClientProviderCallbackWithResponse call
func ParseOauthClientProviderCallbackResponse(rsp *http.Response) (*OauthClientProviderCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthClientProviderCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProviderCallbackResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthClientListProvidersResponse parses an HTTP response from a OauthClientListProvidersWithResponse call
func ParseOauthClientListProvidersResponse(rsp *http.Response) (*OauthClientListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthClientListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProvidersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthClientProviderAuthResponse parses an HTTP response from a OauthClientProviderAuthWithResponse call
func ParseOauthClientProviderAuthResponse(rsp *http.Response) (*OauthClientProviderAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthClientProviderAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysListResponse parses an HTTP response from a PasskeysListWithResponse call
func ParsePasskeysListResponse(rsp *http.Response) (*PasskeysListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysLoginBeginResponse parses an HTTP response from a PasskeysLoginBeginWithResponse call
func ParsePasskeysLoginBeginResponse(rsp *http.Response) (*PasskeysLoginBeginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysLoginBeginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisterBeginResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysLoginCompleteResponse parses an HTTP response from a PasskeysLoginCompleteWithResponse call
func ParsePasskeysLoginCompleteResponse(rsp *http.Response) (*PasskeysLoginCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysLoginCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginCompleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysRegisterBeginResponse parses an HTTP response from a PasskeysRegisterBeginWithResponse call
func ParsePasskeysRegisterBeginResponse(rsp *http.Response) (*PasskeysRegisterBeginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysRegisterBeginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisterBeginResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysRegisterCompleteResponse parses an HTTP response from a PasskeysRegisterCompleteWithResponse call
func ParsePasskeysRegisterCompleteResponse(rsp *http.Response) (*PasskeysRegisterCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysRegisterCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisteredPasskey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysDeleteResponse parses an HTTP response from a PasskeysDeleteWithResponse call
func ParsePasskeysDeleteResponse(rsp *http.Response) (*PasskeysDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysUpdateResponse parses an HTTP response from a PasskeysUpdateWithResponse call
func ParsePasskeysUpdateResponse(rsp *http.Response) (*PasskeysUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessEmailResponse parses an HTTP response from a PasswordlessEmailWithResponse call
func ParsePasswordlessEmailResponse(rsp *http.Response) (*PasswordlessEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessMagicLinkResponse parses an HTTP response from a PasswordlessMagicLinkWithResponse call
func ParsePasswordlessMagicLinkResponse(rsp *http.Response) (*PasswordlessMagicLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessMagicLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MagicLinkResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessMethodsResponse parses an HTTP response from a PasswordlessMethodsWithResponse call
func ParsePasswordlessMethodsResponse(rsp *http.Response) (*PasswordlessMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MethodsResponseBody2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessSmsResponse parses an HTTP response from a PasswordlessSmsWithResponse call
func ParsePasswordlessSmsResponse(rsp *http.Response) (*PasswordlessSmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessSmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessVerifyResponse parses an HTTP response from a PasswordlessVerifyWithResponse call
func ParsePasswordlessVerifyResponse(rsp *http.Response) (*PasswordlessVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRefreshTokenResponse parses an HTTP response from a AuthRefreshTokenWithResponse call
func ParseAuthRefreshTokenResponse(rsp *http.Response) (*AuthRefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRegisterResponse parses an HTTP response from a AuthRegisterWithResponse call
func ParseAuthRegisterResponse(rsp *http.Response) (*AuthRegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LoginResponse3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthResetPasswordResponse parses an HTTP response from a AuthResetPasswordWithResponse call
func ParseAuthResetPasswordResponse(rsp *http.Response) (*AuthResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthSendEmailVerificationResponse parses an HTTP response from a AuthSendEmailVerificationWithResponse call
func ParseAuthSendEmailVerificationResponse(rsp *http.Response) (*AuthSendEmailVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthSendEmailVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoProviderCallbackResponse parses an HTTP response from a SsoProviderCallbackWithResponse call
func ParseSsoProviderCallbackResponse(rsp *http.Response) (*SsoProviderCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoProviderCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProviderCallbackResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoListIdentityProvidersResponse parses an HTTP response from a SsoListIdentityProvidersWithResponse call
func ParseSsoListIdentityProvidersResponse(rsp *http.Response) (*SsoListIdentityProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoListIdentityProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIdentityProvidersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoCreateIdentityProviderResponse parses an HTTP response from a SsoCreateIdentityProviderWithResponse call
func ParseSsoCreateIdentityProviderResponse(rsp *http.Response) (*SsoCreateIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoCreateIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IdentityProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoDeleteIdentityProviderResponse parses an HTTP response from a SsoDeleteIdentityProviderWithResponse call
func ParseSsoDeleteIdentityProviderResponse(rsp *http.Response) (*SsoDeleteIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoDeleteIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoGetIdentityProviderResponse parses an HTTP response from a SsoGetIdentityProviderWithResponse call
func ParseSsoGetIdentityProviderResponse(rsp *http.Response) (*SsoGetIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoGetIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoUpdateIdentityProviderResponse parses an HTTP response from a SsoUpdateIdentityProviderWithResponse call
func ParseSsoUpdateIdentityProviderResponse(rsp *http.Response) (*SsoUpdateIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoUpdateIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoListProvidersResponse parses an HTTP response from a SsoListProvidersWithResponse call
func ParseSsoListProvidersResponse(rsp *http.Response) (*SsoListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProvidersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoProviderAuthResponse parses an HTTP response from a SsoProviderAuthWithResponse call
func ParseSsoProviderAuthResponse(rsp *http.Response) (*SsoProviderAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoProviderAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoSamlAcsResponse parses an HTTP response from a SsoSamlAcsWithResponse call
func ParseSsoSamlAcsResponse(rsp *http.Response) (*SsoSamlAcsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoSamlAcsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoSamlMetadataResponse parses an HTTP response from a SsoSamlMetadataWithResponse call
func ParseSsoSamlMetadataResponse(rsp *http.Response) (*SsoSamlMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoSamlMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest SamlMetadataResponseBody
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseAuthVerifyEmailResponse parses an HTTP response from a AuthVerifyEmailWithResponse call
func ParseAuthVerifyEmailResponse(rsp *http.Response) (*AuthVerifyEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthVerifyEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailSendResponse parses an HTTP response from a EmailSendWithResponse call
func ParseEmailSendResponse(rsp *http.Response) (*EmailSendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailSendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailSendTemplateResponse parses an HTTP response from a EmailSendTemplateWithResponse call
func ParseEmailSendTemplateResponse(rsp *http.Response) (*EmailSendTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailSendTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailListTemplatesResponse parses an HTTP response from a EmailListTemplatesWithResponse call
func ParseEmailListTemplatesResponse(rsp *http.Response) (*EmailListTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTemplatesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailCreateTemplateResponse parses an HTTP response from a EmailCreateTemplateWithResponse call
func ParseEmailCreateTemplateResponse(rsp *http.Response) (*EmailCreateTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailCreateTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailGetTemplateByTypeResponse parses an HTTP response from a EmailGetTemplateByTypeWithResponse call
func ParseEmailGetTemplateByTypeResponse(rsp *http.Response) (*EmailGetTemplateByTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailGetTemplateByTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailDeleteTemplateResponse parses an HTTP response from a EmailDeleteTemplateWithResponse call
func ParseEmailDeleteTemplateResponse(rsp *http.Response) (*EmailDeleteTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailDeleteTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailGetTemplateResponse parses an HTTP response from a EmailGetTemplateWithResponse call
func ParseEmailGetTemplateResponse(rsp *http.Response) (*EmailGetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailGetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailUpdateTemplateResponse parses an HTTP response from a EmailUpdateTemplateWithResponse call
func ParseEmailUpdateTemplateResponse(rsp *http.Response) (*EmailUpdateTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailUpdateTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderJwksResponse parses an HTTP response from a OauthProviderJwksWithResponse call
func ParseOauthProviderJwksResponse(rsp *http.Response) (*OauthProviderJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JwksResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderOidcConfigurationResponse parses an HTTP response from a OauthProviderOidcConfigurationWithResponse call
func ParseOauthProviderOidcConfigurationResponse(rsp *http.Response) (*OauthProviderOidcConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderOidcConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcConfigurationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderAuthorizeResponse parses an HTTP response from a OauthProviderAuthorizeWithResponse call
func ParseOauthProviderAuthorizeResponse(rsp *http.Response) (*OauthProviderAuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderAuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderListClientsResponse parses an HTTP response from a OauthProviderListClientsWithResponse call
func ParseOauthProviderListClientsResponse(rsp *http.Response) (*OauthProviderListClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderListClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListClientsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderCreateClientResponse parses an HTTP response from a OauthProviderCreateClientWithResponse call
func ParseOauthProviderCreateClientResponse(rsp *http.Response) (*OauthProviderCreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderCreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OAuthClientWithSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderDeleteClientResponse parses an HTTP response from a OauthProviderDeleteClientWithResponse call
func ParseOauthProviderDeleteClientResponse(rsp *http.Response) (*OauthProviderDeleteClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderDeleteClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderGetClientResponse parses an HTTP response from a OauthProviderGetClientWithResponse call
func ParseOauthProviderGetClientResponse(rsp *http.Response) (*OauthProviderGetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderGetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderUpdateClientResponse parses an HTTP response from a OauthProviderUpdateClientWithResponse call
func ParseOauthProviderUpdateClientResponse(rsp *http.Response) (*OauthProviderUpdateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderUpdateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderRotateClientSecretResponse parses an HTTP response from a OauthProviderRotateClientSecretWithResponse call
func ParseOauthProviderRotateClientSecretResponse(rsp *http.Response) (*OauthProviderRotateClientSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderRotateClientSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RotateClientSecretResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderConsentResponse parses an HTTP response from a OauthProviderConsentWithResponse call
func ParseOauthProviderConsentResponse(rsp *http.Response) (*OauthProviderConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest ConsentResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderIntrospectResponse parses an HTTP response from a OauthProviderIntrospectWithResponse call
func ParseOauthProviderIntrospectResponse(rsp *http.Response) (*OauthProviderIntrospectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderIntrospectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntrospectResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderRevokeResponse parses an HTTP response from a OauthProviderRevokeWithResponse call
func ParseOauthProviderRevokeResponse(rsp *http.Response) (*OauthProviderRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderListScopesResponse parses an HTTP response from a OauthProviderListScopesWithResponse call
func ParseOauthProviderListScopesResponse(rsp *http.Response) (*OauthProviderListScopesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderListScopesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListScopesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderCreateScopeResponse parses an HTTP response from a OauthProviderCreateScopeWithResponse call
func ParseOauthProviderCreateScopeResponse(rsp *http.Response) (*OauthProviderCreateScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderCreateScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OAuthScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderDeleteScopeResponse parses an HTTP response from a OauthProviderDeleteScopeWithResponse call
func ParseOauthProviderDeleteScopeResponse(rsp *http.Response) (*OauthProviderDeleteScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderDeleteScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderGetScopeResponse parses an HTTP response from a OauthProviderGetScopeWithResponse call
func ParseOauthProviderGetScopeResponse(rsp *http.Response) (*OauthProviderGetScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderGetScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderUpdateScopeResponse parses an HTTP response from a OauthProviderUpdateScopeWithResponse call
func ParseOauthProviderUpdateScopeResponse(rsp *http.Response) (*OauthProviderUpdateScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderUpdateScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderTokenResponse parses an HTTP response from a OauthProviderTokenWithResponse call
func ParseOauthProviderTokenResponse(rsp *http.Response) (*OauthProviderTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderUserinfoResponse parses an HTTP response from a OauthProviderUserinfoWithResponse call
func ParseOauthProviderUserinfoResponse(rsp *http.Response) (*OauthProviderUserinfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderUserinfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserinfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsListResponse parses an HTTP response from a OrganizationsListWithResponse call
func ParseOrganizationsListResponse(rsp *http.Response) (*OrganizationsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsCreateResponse parses an HTTP response from a OrganizationsCreateWithResponse call
func ParseOrganizationsCreateResponse(rsp *http.Response) (*OrganizationsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsDeleteResponse parses an HTTP response from a OrganizationsDeleteWithResponse call
func ParseOrganizationsDeleteResponse(rsp *http.Response) (*OrganizationsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsGetResponse parses an HTTP response from a OrganizationsGetWithResponse call
func ParseOrganizationsGetResponse(rsp *http.Response) (*OrganizationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsUpdateResponse parses an HTTP response from a OrganizationsUpdateWithResponse call
func ParseOrganizationsUpdateResponse(rsp *http.Response) (*OrganizationsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsListFeaturesResponse parses an HTTP response from a OrganizationsListFeaturesWithResponse call
func ParseOrganizationsListFeaturesResponse(rsp *http.Response) (*OrganizationsListFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsListFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFeaturesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsEnableFeatureResponse parses an HTTP response from a OrganizationsEnableFeatureWithResponse call
func ParseOrganizationsEnableFeatureResponse(rsp *http.Response) (*OrganizationsEnableFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsEnableFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsDisableFeatureResponse parses an HTTP response from a OrganizationsDisableFeatureWithResponse call
func ParseOrganizationsDisableFeatureResponse(rsp *http.Response) (*OrganizationsDisableFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsDisableFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsListMembersResponse parses an HTTP response from a OrganizationsListMembersWithResponse call
func ParseOrganizationsListMembersResponse(rsp *http.Response) (*OrganizationsListMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsListMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMembersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsAddMemberResponse parses an HTTP response from a OrganizationsAddMemberWithResponse call
func ParseOrganizationsAddMemberResponse(rsp *http.Response) (*OrganizationsAddMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsAddMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsRemoveMemberResponse parses an HTTP response from a OrganizationsRemoveMemberWithResponse call
func ParseOrganizationsRemoveMemberResponse(rsp *http.Response) (*OrganizationsRemoveMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsRemoveMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsUpdateMemberResponse parses an HTTP response from a OrganizationsUpdateMemberWithResponse call
func ParseOrganizationsUpdateMemberResponse(rsp *http.Response) (*OrganizationsUpdateMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsUpdateMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacListPermissionsResponse parses an HTTP response from a RbacListPermissionsWithResponse call
func ParseRbacListPermissionsResponse(rsp *http.Response) (*RbacListPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacListPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacCreatePermissionResponse parses an HTTP response from a RbacCreatePermissionWithResponse call
func ParseRbacCreatePermissionResponse(rsp *http.Response) (*RbacCreatePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCreatePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PermissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacDeletePermissionResponse parses an HTTP response from a RbacDeletePermissionWithResponse call
func ParseRbacDeletePermissionResponse(rsp *http.Response) (*RbacDeletePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacDeletePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacGetPermissionResponse parses an HTTP response from a RbacGetPermissionWithResponse call
func ParseRbacGetPermissionResponse(rsp *http.Response) (*RbacGetPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacGetPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacUpdatePermissionResponse parses an HTTP response from a RbacUpdatePermissionWithResponse call
func ParseRbacUpdatePermissionResponse(rsp *http.Response) (*RbacUpdatePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacUpdatePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacListRolesResponse parses an HTTP response from a RbacListRolesWithResponse call
func ParseRbacListRolesResponse(rsp *http.Response) (*RbacListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRolesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacCreateRoleResponse parses an HTTP response from a RbacCreateRoleWithResponse call
func ParseRbacCreateRoleResponse(rsp *http.Response) (*RbacCreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacDeleteRoleResponse parses an HTTP response from a RbacDeleteRoleWithResponse call
func ParseRbacDeleteRoleResponse(rsp *http.Response) (*RbacDeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacDeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacGetRoleResponse parses an HTTP response from a RbacGetRoleWithResponse call
func ParseRbacGetRoleResponse(rsp *http.Response) (*RbacGetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacGetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacUpdateRoleResponse parses an HTTP response from a RbacUpdateRoleWithResponse call
func ParseRbacUpdateRoleResponse(rsp *http.Response) (*RbacUpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacUpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacListRolePermissionsResponse parses an HTTP response from a RbacListRolePermissionsWithResponse call
func ParseRbacListRolePermissionsResponse(rsp *http.Response) (*RbacListRolePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacListRolePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRolePermissionsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacAddRolePermissionResponse parses an HTTP response from a RbacAddRolePermissionWithResponse call
func ParseRbacAddRolePermissionResponse(rsp *http.Response) (*RbacAddRolePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacAddRolePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacRemoveRolePermissionResponse parses an HTTP response from a RbacRemoveRolePermissionWithResponse call
func ParseRbacRemoveRolePermissionResponse(rsp *http.Response) (*RbacRemoveRolePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacRemoveRolePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersListResponse parses an HTTP response from a UsersListWithResponse call
func ParseUsersListResponse(rsp *http.Response) (*UsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody4
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersCreateResponse parses an HTTP response from a UsersCreateWithResponse call
func ParseUsersCreateResponse(rsp *http.Response) (*UsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersUpdateMeResponse parses an HTTP response from a UsersUpdateMeWithResponse call
func ParseUsersUpdateMeResponse(rsp *http.Response) (*UsersUpdateMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdateMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersUpdatePasswordResponse parses an HTTP response from a UsersUpdatePasswordWithResponse call
func ParseUsersUpdatePasswordResponse(rsp *http.Response) (*UsersUpdatePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdatePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersGetSessionsResponse parses an HTTP response from a UsersGetSessionsWithResponse call
func ParseUsersGetSessionsResponse(rsp *http.Response) (*UsersGetSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersGetSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersDeleteSessionResponse parses an HTTP response from a UsersDeleteSessionWithResponse call
func ParseUsersDeleteSessionResponse(rsp *http.Response) (*UsersDeleteSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersDeleteResponse parses an HTTP response from a UsersDeleteWithResponse call
func ParseUsersDeleteResponse(rsp *http.Response) (*UsersDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersGetResponse parses an HTTP response from a UsersGetWithResponse call
func ParseUsersGetResponse(rsp *http.Response) (*UsersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersUpdateResponse parses an HTTP response from a UsersUpdateWithResponse call
func ParseUsersUpdateResponse(rsp *http.Response) (*UsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersGetOrganizationsResponse parses an HTTP response from a UsersGetOrganizationsWithResponse call
func ParseUsersGetOrganizationsResponse(rsp *http.Response) (*UsersGetOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersGetOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrganizationsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksListResponse parses an HTTP response from a WebhooksListWithResponse call
func ParseWebhooksListResponse(rsp *http.Response) (*WebhooksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody5
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksCreateResponse parses an HTTP response from a WebhooksCreateWithResponse call
func ParseWebhooksCreateResponse(rsp *http.Response) (*WebhooksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksReceiveResponse parses an HTTP response from a WebhooksReceiveWithResponse call
func ParseWebhooksReceiveResponse(rsp *http.Response) (*WebhooksReceiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksReceiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksTriggerEventResponse parses an HTTP response from a WebhooksTriggerEventWithResponse call
func ParseWebhooksTriggerEventResponse(rsp *http.Response) (*WebhooksTriggerEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksTriggerEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksDeleteResponse parses an HTTP response from a WebhooksDeleteWithResponse call
func ParseWebhooksDeleteResponse(rsp *http.Response) (*WebhooksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksGetResponse parses an HTTP response from a WebhooksGetWithResponse call
func ParseWebhooksGetResponse(rsp *http.Response) (*WebhooksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksUpdateResponse parses an HTTP response from a WebhooksUpdateWithResponse call
func ParseWebhooksUpdateResponse(rsp *http.Response) (*WebhooksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksListEventsResponse parses an HTTP response from a WebhooksListEventsWithResponse call
func ParseWebhooksListEventsResponse(rsp *http.Response) (*WebhooksListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEventsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksReplayEventResponse parses an HTTP response from a WebhooksReplayEventWithResponse call
func ParseWebhooksReplayEventResponse(rsp *http.Response) (*WebhooksReplayEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksReplayEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
