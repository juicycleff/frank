// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_key__Scopes                    = "api_key__.Scopes"
	Api_key_header_AuthorizationScopes = "api_key_header_Authorization.Scopes"
	Jwt_header_Scopes                  = "jwt_header_.Scopes"
	Jwt_header_AuthorizationScopes     = "jwt_header_Authorization.Scopes"
	Oauth2__Scopes                     = "oauth2__.Scopes"
	Oauth2_header_AuthorizationScopes  = "oauth2_header_Authorization.Scopes"
)

// Defines values for CreateAPIKeyRequestType.
const (
	CreateAPIKeyRequestTypeClient CreateAPIKeyRequestType = "client"
	CreateAPIKeyRequestTypeServer CreateAPIKeyRequestType = "server"
)

// Defines values for CreateIdentityProviderRequestProviderType.
const (
	Oauth2 CreateIdentityProviderRequestProviderType = "oauth2"
	Oidc   CreateIdentityProviderRequestProviderType = "oidc"
	Saml   CreateIdentityProviderRequestProviderType = "saml"
)

// Defines values for CreateWebhookRequestFormat.
const (
	CreateWebhookRequestFormatForm CreateWebhookRequestFormat = "form"
	CreateWebhookRequestFormatJson CreateWebhookRequestFormat = "json"
)

// Defines values for FormFieldType.
const (
	Checkbox FormFieldType = "checkbox"
	Number   FormFieldType = "number"
	Select   FormFieldType = "select"
	Text     FormFieldType = "text"
)

// Defines values for FormFieldWidth.
const (
	Full  FormFieldWidth = "full"
	Half  FormFieldWidth = "half"
	Third FormFieldWidth = "third"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusHealthy   HealthResponseStatus = "healthy"
	HealthResponseStatusUnhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for HealthStatusStatus.
const (
	HealthStatusStatusHealthy   HealthStatusStatus = "healthy"
	HealthStatusStatusUnhealthy HealthStatusStatus = "unhealthy"
)

// Defines values for MFAEnrollRequestMethod.
const (
	MFAEnrollRequestMethodBackupCodes MFAEnrollRequestMethod = "backup_codes"
	MFAEnrollRequestMethodEmail       MFAEnrollRequestMethod = "email"
	MFAEnrollRequestMethodSms         MFAEnrollRequestMethod = "sms"
	MFAEnrollRequestMethodTotp        MFAEnrollRequestMethod = "totp"
)

// Defines values for MFAUnEnrollRequestMethod.
const (
	MFAUnEnrollRequestMethodAll         MFAUnEnrollRequestMethod = "all"
	MFAUnEnrollRequestMethodBackupCodes MFAUnEnrollRequestMethod = "backup_codes"
	MFAUnEnrollRequestMethodEmail       MFAUnEnrollRequestMethod = "email"
	MFAUnEnrollRequestMethodSms         MFAUnEnrollRequestMethod = "sms"
	MFAUnEnrollRequestMethodTotp        MFAUnEnrollRequestMethod = "totp"
)

// Defines values for MFAVerifyRequestMethod.
const (
	MFAVerifyRequestMethodBackupCodes MFAVerifyRequestMethod = "backup_codes"
	MFAVerifyRequestMethodEmail       MFAVerifyRequestMethod = "email"
	MFAVerifyRequestMethodSms         MFAVerifyRequestMethod = "sms"
	MFAVerifyRequestMethodTotp        MFAVerifyRequestMethod = "totp"
)

// Defines values for OrganizationVerificationConfigMethod.
const (
	OrganizationVerificationConfigMethodEmail OrganizationVerificationConfigMethod = "email"
	OrganizationVerificationConfigMethodPhone OrganizationVerificationConfigMethod = "phone"
	OrganizationVerificationConfigMethodSms   OrganizationVerificationConfigMethod = "sms"
)

// Defines values for PasswordlessVerifyRequestAuthType.
const (
	PasswordlessVerifyRequestAuthTypeEmail PasswordlessVerifyRequestAuthType = "email"
	PasswordlessVerifyRequestAuthTypeSms   PasswordlessVerifyRequestAuthType = "sms"
)

// Defines values for ReadyResponseStatus.
const (
	NotReady ReadyResponseStatus = "not_ready"
	Ready    ReadyResponseStatus = "ready"
)

// Defines values for SendEmailVerificationRequestBodyMethod.
const (
	SendEmailVerificationRequestBodyMethodLink SendEmailVerificationRequestBodyMethod = "link"
	SendEmailVerificationRequestBodyMethodOtp  SendEmailVerificationRequestBodyMethod = "otp"
)

// Defines values for SendMFACodeRequestMethod.
const (
	SendMFACodeRequestMethodEmail SendMFACodeRequestMethod = "email"
	SendMFACodeRequestMethodSms   SendMFACodeRequestMethod = "sms"
)

// Defines values for UpdateWebhookRequestFormat.
const (
	UpdateWebhookRequestFormatForm UpdateWebhookRequestFormat = "form"
	UpdateWebhookRequestFormatJson UpdateWebhookRequestFormat = "json"
)

// Defines values for VerifyEmailRequestMethod.
const (
	VerifyEmailRequestMethodLink VerifyEmailRequestMethod = "link"
	VerifyEmailRequestMethodOtp  VerifyEmailRequestMethod = "otp"
)

// Defines values for ApiKeysListParamsType.
const (
	ApiKeysListParamsTypeClient ApiKeysListParamsType = "client"
	ApiKeysListParamsTypeServer ApiKeysListParamsType = "server"
)

// APIKeyResponse API key information without the actual key
type APIKeyResponse struct {
	// Active Whether API key is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// ExpiresAt Expiry timestamp
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Id API key ID
	Id string `json:"id"`

	// LastUsed Last used timestamp
	LastUsed *string `json:"last_used,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`

	// Type API key type (client/server)
	Type string `json:"type"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UserId User ID who owns the key
	UserId *string `json:"user_id,omitempty"`
}

// APIKeyWithSecretResponse API key information with the actual key
type APIKeyWithSecretResponse struct {
	// Active Whether API key is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// ExpiresAt Expiry timestamp
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Id API key ID
	Id string `json:"id"`

	// Key API key secret
	Key string `json:"key"`

	// LastUsed Last used timestamp
	LastUsed *string `json:"last_used,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`

	// Type API key type (client/server)
	Type string `json:"type"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UserId User ID who owns the key
	UserId *string `json:"user_id,omitempty"`
}

// AddMemberRequestBody defines model for AddMemberRequestBody.
type AddMemberRequestBody struct {
	// Member Add organization member request
	Member AddOrganizationMemberRequest `json:"member"`
}

// AddOrganizationMemberRequest Add organization member request
type AddOrganizationMemberRequest struct {
	// Roles Roles to assign
	Roles []string `json:"roles"`

	// UserId User ID to add
	UserId string `json:"user_id"`
}

// AddRolePermissionRequest Add permission to role request
type AddRolePermissionRequest struct {
	// PermissionId Permission ID
	PermissionId string `json:"permission_id"`
}

// AddRolePermissionRequestBody defines model for AddRolePermissionRequestBody.
type AddRolePermissionRequestBody struct {
	// Permission Add permission to role request
	Permission AddRolePermissionRequest `json:"permission"`
}

// BackupCodesResponse Backup codes response
type BackupCodesResponse struct {
	// BackupCodes List of backup codes
	BackupCodes []string `json:"backup_codes"`
}

// BadRequestError Bad request response
type BadRequestError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// CSRFTokenResponse CSRF token response
type CSRFTokenResponse struct {
	// CsrfToken CSRF token
	CsrfToken string `json:"csrf_token"`
}

// CheckEmailVerificationResponseBody defines model for CheckEmailVerificationResponseBody.
type CheckEmailVerificationResponseBody struct {
	// Verified Whether email is verified
	Verified bool `json:"verified"`
}

// CheckPermissionResponseBody defines model for CheckPermissionResponseBody.
type CheckPermissionResponseBody struct {
	// HasPermission Whether user has the permission
	HasPermission bool `json:"has_permission"`
}

// CheckRoleResponseBody defines model for CheckRoleResponseBody.
type CheckRoleResponseBody struct {
	// HasRole Whether user has the role
	HasRole bool `json:"has_role"`
}

// ConflictError Conflict response
type ConflictError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// ConsentRequest OAuth consent request
type ConsentRequest struct {
	// Approved Whether consent is approved
	Approved *bool `json:"approved,omitempty"`

	// ClientId OAuth client ID
	ClientId string `json:"client_id"`

	// RedirectUri Redirect URI
	RedirectUri string `json:"redirect_uri"`

	// Scope Requested scopes (space-separated)
	Scope string `json:"scope"`

	// State OAuth state parameter
	State *string `json:"state,omitempty"`
}

// ConsentResponseBody defines model for ConsentResponseBody.
type ConsentResponseBody struct {
	// RedirectUri Redirect URI with authorization code
	RedirectUri string `json:"redirect_uri"`
}

// CreateAPIKeyRequest Create API key request
type CreateAPIKeyRequest struct {
	// ExpiresIn Expiry in seconds
	ExpiresIn *int64 `json:"expires_in,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name string `json:"name"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`

	// Type API key type
	Type *CreateAPIKeyRequestType `json:"type,omitempty"`
}

// CreateAPIKeyRequestType API key type
type CreateAPIKeyRequestType string

// CreateEmailTemplateRequest Create email template request
type CreateEmailTemplateRequest struct {
	// Active Whether template is active
	Active *bool `json:"active,omitempty"`

	// HtmlContent HTML content
	HtmlContent string `json:"html_content"`

	// Locale Template locale
	Locale *string `json:"locale,omitempty"`

	// Metadata Template metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Template name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Subject Email subject
	Subject string `json:"subject"`

	// System Whether this is a system template
	System *bool `json:"system,omitempty"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`

	// Type Template type
	Type string `json:"type"`
}

// CreateIdentityProviderRequest Create identity provider request
type CreateIdentityProviderRequest struct {
	// Active Whether provider is active
	Active *bool `json:"active,omitempty"`

	// AttributesMapping Attributes mapping
	AttributesMapping *map[string]string `json:"attributes_mapping,omitempty"`

	// AuthorizationEndpoint OAuth/OIDC authorization endpoint
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// Certificate SAML certificate
	Certificate *string `json:"certificate,omitempty"`

	// ClientId OAuth/OIDC client ID
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret OAuth/OIDC client secret
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domains Allowed email domains
	Domains *[]string `json:"domains,omitempty"`

	// Issuer OIDC issuer URL
	Issuer *string `json:"issuer,omitempty"`

	// JwksUri OIDC JWKS URI
	JwksUri *string `json:"jwks_uri,omitempty"`

	// MetadataUrl SAML metadata URL
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Provider name
	Name string `json:"name"`

	// Primary Whether this is the primary provider
	Primary *bool `json:"primary,omitempty"`

	// PrivateKey SAML private key
	PrivateKey *string `json:"private_key,omitempty"`

	// ProviderType Provider type
	ProviderType CreateIdentityProviderRequestProviderType `json:"provider_type"`

	// RedirectUri OAuth/OIDC redirect URI
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// TokenEndpoint OAuth/OIDC token endpoint
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// UserinfoEndpoint OIDC userinfo endpoint
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
}

// CreateIdentityProviderRequestProviderType Provider type
type CreateIdentityProviderRequestProviderType string

// CreateIdentityProviderRequestBody defines model for CreateIdentityProviderRequestBody.
type CreateIdentityProviderRequestBody struct {
	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// Provider Create identity provider request
	Provider CreateIdentityProviderRequest `json:"provider"`
}

// CreateOAuthClientRequest Create OAuth client request
type CreateOAuthClientRequest struct {
	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes *[]string `json:"allowed_grant_types,omitempty"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientName Client name
	ClientName string `json:"client_name"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public *bool `json:"public,omitempty"`

	// RedirectUris Authorized redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`
}

// CreateOAuthScopeRequest Create OAuth scope request
type CreateOAuthScopeRequest struct {
	// DefaultScope Whether this scope is included by default
	DefaultScope *bool `json:"default_scope,omitempty"`

	// Description Scope description
	Description string `json:"description"`

	// Name Scope name
	Name string `json:"name"`

	// Public Whether this scope can be requested by any client
	Public *bool `json:"public,omitempty"`
}

// CreateOrganizationRequest Create organization request
type CreateOrganizationRequest struct {
	// Domain Organization domain
	Domain *string `json:"domain,omitempty"`

	// Features Features to enable
	Features *[]string `json:"features,omitempty"`

	// LogoUrl Organization logo URL
	LogoUrl *string `json:"logo_url,omitempty"`

	// Metadata Organization metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Organization name
	Name string `json:"name"`

	// Plan Organization plan
	Plan *string `json:"plan,omitempty"`

	// Slug Organization slug
	Slug *string `json:"slug,omitempty"`

	// TrialDays Number of trial days
	TrialDays *int64 `json:"trial_days,omitempty"`
}

// CreatePermissionRequest Create permission request
type CreatePermissionRequest struct {
	// Action Action this permission allows
	Action string `json:"action"`

	// Conditions JSON expression for conditional access
	Conditions *string `json:"conditions,omitempty"`

	// Description Permission description
	Description string `json:"description"`

	// Name Permission name
	Name string `json:"name"`

	// Resource Resource this permission applies to
	Resource string `json:"resource"`
}

// CreatePermissionRequestBody defines model for CreatePermissionRequestBody.
type CreatePermissionRequestBody struct {
	// Permission Create permission request
	Permission CreatePermissionRequest `json:"permission"`
}

// CreateRequestBody defines model for CreateRequestBody.
type CreateRequestBody struct {
	// Key Create API key request
	Key CreateAPIKeyRequest `json:"key"`
}

// CreateRequestBody2 defines model for CreateRequestBody2.
type CreateRequestBody2 struct {
	// Organization Create organization request
	Organization CreateOrganizationRequest `json:"organization"`
}

// CreateRequestBody3 defines model for CreateRequestBody3.
type CreateRequestBody3 struct {
	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// Webhook Create webhook request
	Webhook CreateWebhookRequest `json:"webhook"`
}

// CreateRoleRequest Create role request
type CreateRoleRequest struct {
	// Description Role description
	Description *string `json:"description,omitempty"`

	// IsDefault Whether this is a default role for new users
	IsDefault *bool `json:"is_default,omitempty"`

	// Name Role name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`
}

// CreateRoleRequestBody defines model for CreateRoleRequestBody.
type CreateRoleRequestBody struct {
	// Role Create role request
	Role CreateRoleRequest `json:"role"`
}

// CreateUserRequest Create user request
type CreateUserRequest struct {
	// Email Email address
	Email openapi_types.Email `json:"email"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// Id ID of the entity
	Id *string `json:"id,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Locale User locale
	Locale *string `json:"locale,omitempty"`

	// Metadata User metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID to add user to
	OrganizationId *string `json:"organization_id,omitempty"`

	// Password User password
	Password *string `json:"password,omitempty"`

	// PhoneNumber User phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// ProfileImageUrl URL to user's profile image
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`
}

// CreateWebhookRequest Create webhook request
type CreateWebhookRequest struct {
	// EventTypes Event types to subscribe to
	EventTypes []string `json:"event_types"`

	// Format Payload format
	Format *CreateWebhookRequestFormat `json:"format,omitempty"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name string `json:"name"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// Url Webhook URL
	Url string `json:"url"`
}

// CreateWebhookRequestFormat Payload format
type CreateWebhookRequestFormat string

// EmailResponseBody defines model for EmailResponseBody.
type EmailResponseBody struct {
	// Message Success message
	Message string `json:"message"`

	// VerificationId Verification ID
	VerificationId string `json:"verification_id"`
}

// EmailTemplateResponse Email template information
type EmailTemplateResponse struct {
	// Active Whether template is active
	Active bool `json:"active"`

	// CreatedAt Created At
	CreatedAt time.Time `json:"created_at"`

	// HtmlContent HTML content
	HtmlContent string `json:"html_content"`

	// Id ID of the entity
	Id string `json:"id"`

	// Locale Template locale
	Locale string `json:"locale"`

	// Metadata Template metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Template name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Subject Email subject
	Subject string `json:"subject"`

	// System Whether this is a system template
	System bool `json:"system"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`

	// Type Template type
	Type string `json:"type"`

	// UpdatedAt Updated At
	UpdatedAt time.Time `json:"updated_at"`
}

// EnableFeatureRequest Enable feature request
type EnableFeatureRequest struct {
	// FeatureKey Feature key to enable
	FeatureKey string `json:"feature_key"`

	// Settings Feature settings
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// EnableFeatureRequestBody defines model for EnableFeatureRequestBody.
type EnableFeatureRequestBody struct {
	// Feature Enable feature request
	Feature EnableFeatureRequest `json:"feature"`
}

// EnrollRequestBody defines model for EnrollRequestBody.
type EnrollRequestBody struct {
	// Request MFA enrollment request
	Request MFAEnrollRequest `json:"request"`
}

// EnrollResponseBody defines model for EnrollResponseBody.
type EnrollResponseBody struct {
	// BackupCodes Backup codes response
	BackupCodes *BackupCodesResponse `json:"backup_codes,omitempty"`

	// Message Success message for SMS/Email enrollment
	Message *string `json:"message,omitempty"`

	// Totp TOTP enrollment response
	Totp *TOTPEnrollResponse `json:"totp,omitempty"`
}

// ForbiddenError Forbidden response
type ForbiddenError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// ForgotPasswordRequest Forgot password request
type ForgotPasswordRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`
}

// FormField Represents a form field configuration
type FormField struct {
	// IsEmail Indicates if field represents an email
	IsEmail *bool `json:"isEmail,omitempty"`

	// IsFirstName Indicates if field represents a first name
	IsFirstName *bool `json:"isFirstName,omitempty"`

	// IsLastName Indicates if field represents a last name
	IsLastName *bool `json:"isLastName,omitempty"`

	// Label Display label for the field
	Label string `json:"label"`

	// Name Field identifier name
	Name string `json:"name"`

	// Options Options for select fields
	Options *[]FormFieldSelectOption `json:"options,omitempty"`

	// Placeholder Placeholder text
	Placeholder *string `json:"placeholder,omitempty"`

	// Required Whether the field is required
	Required *bool `json:"required,omitempty"`

	// Row Row position identifier (string or number)
	Row *interface{} `json:"row,omitempty"`

	// Type Type of form field
	Type FormFieldType `json:"type"`

	// Validation Validation rules for form fields
	Validation *FormFieldValidationRules `json:"validation,omitempty"`

	// Width Width of the field
	Width *FormFieldWidth `json:"width,omitempty"`
}

// FormFieldType Type of form field
type FormFieldType string

// FormFieldWidth Width of the field
type FormFieldWidth string

// FormFieldSelectOption Option for select fields
type FormFieldSelectOption struct {
	// Label Option display label
	Label string `json:"label"`

	// Value Option value
	Value string `json:"value"`
}

// FormFieldValidationRules Validation rules for form fields
type FormFieldValidationRules struct {
	// Max Maximum value
	Max *float32 `json:"max,omitempty"`

	// MaxLength Maximum length
	MaxLength *int64 `json:"maxLength,omitempty"`

	// Min Minimum value
	Min *float32 `json:"min,omitempty"`

	// MinLength Minimum length
	MinLength *int64 `json:"minLength,omitempty"`

	// Pattern Regex pattern for validation
	Pattern *string `json:"pattern,omitempty"`
}

// GetOrganizationsResponseBody defines model for GetOrganizationsResponseBody.
type GetOrganizationsResponseBody struct {
	Organizations []Organization `json:"organizations"`
}

// GetUserSessionResponse Get user session response
type GetUserSessionResponse struct {
	// Data User sessions
	Data []Session `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// HealthResponse Health check response
type HealthResponse struct {
	// Services Status of individual services
	Services *[]HealthStatus `json:"services,omitempty"`

	// Status Overall health status
	Status HealthResponseStatus `json:"status"`

	// Timestamp Timestamp of health check
	Timestamp time.Time `json:"timestamp"`
}

// HealthResponseStatus Overall health status
type HealthResponseStatus string

// HealthStatus Service health status
type HealthStatus struct {
	// Message Additional message
	Message *string `json:"message,omitempty"`

	// Service Service name
	Service string `json:"service"`

	// Status Service status
	Status HealthStatusStatus `json:"status"`
}

// HealthStatusStatus Service status
type HealthStatusStatus string

// IdentityProviderResponse Identity provider information
type IdentityProviderResponse struct {
	// Active Whether provider is active
	Active bool `json:"active"`

	// AttributesMapping Attributes mapping
	AttributesMapping *map[string]string `json:"attributes_mapping,omitempty"`

	// AuthorizationEndpoint OAuth/OIDC authorization endpoint
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// ClientId OAuth/OIDC client ID
	ClientId *string `json:"client_id,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Domains Allowed email domains
	Domains *[]string `json:"domains,omitempty"`

	// Id Provider ID
	Id string `json:"id"`

	// Issuer OIDC issuer URL
	Issuer *string `json:"issuer,omitempty"`

	// JwksUri OIDC JWKS URI
	JwksUri *string `json:"jwks_uri,omitempty"`

	// MetadataUrl SAML metadata URL
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Provider name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// Primary Whether this is the primary provider
	Primary *bool `json:"primary,omitempty"`

	// ProviderType Provider type (oauth2, oidc, saml)
	ProviderType string `json:"provider_type"`

	// RedirectUri OAuth/OIDC redirect URI
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// TokenEndpoint OAuth/OIDC token endpoint
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// UserinfoEndpoint OIDC userinfo endpoint
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
}

// InternalServerError Internal server error response
type InternalServerError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// IntrospectResponseBody defines model for IntrospectResponseBody.
type IntrospectResponseBody struct {
	// Active Whether token is active
	Active bool `json:"active"`

	// Aud Audience
	Aud *string `json:"aud,omitempty"`

	// ClientId Client ID
	ClientId *string `json:"client_id,omitempty"`

	// Exp Expiry timestamp
	Exp *int64 `json:"exp,omitempty"`

	// Iat Issued at timestamp
	Iat *int64 `json:"iat,omitempty"`

	// Iss Issuer
	Iss *string `json:"iss,omitempty"`

	// Jti JWTAuth ID
	Jti *string `json:"jti,omitempty"`

	// Nbf Not before timestamp
	Nbf *int64 `json:"nbf,omitempty"`

	// Scope Token scopes
	Scope *string `json:"scope,omitempty"`

	// Sub Subject (user ID)
	Sub *string `json:"sub,omitempty"`

	// TokenType Token type
	TokenType *string `json:"token_type,omitempty"`

	// Username Resource owner username
	Username *string `json:"username,omitempty"`
}

// JwksResponseBody defines model for JwksResponseBody.
type JwksResponseBody struct {
	Keys []interface{} `json:"keys"`
}

// ListClientsResponseBody defines model for ListClientsResponseBody.
type ListClientsResponseBody struct {
	Data []OAuthClientResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListEventsResponseBody defines model for ListEventsResponseBody.
type ListEventsResponseBody struct {
	Data []WebhookEventResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListFeaturesResponseBody defines model for ListFeaturesResponseBody.
type ListFeaturesResponseBody struct {
	Features []OrganizationFeatureResponse `json:"features"`
}

// ListIdentityProvidersResponseBody defines model for ListIdentityProvidersResponseBody.
type ListIdentityProvidersResponseBody struct {
	Providers []IdentityProviderResponse `json:"providers"`
}

// ListMembersResponseBody defines model for ListMembersResponseBody.
type ListMembersResponseBody struct {
	Data []OrganizationMemberResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListPermissionsResponse Add permission to role request
type ListPermissionsResponse struct {
	Data []PermissionResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListProvidersResponseBody defines model for ListProvidersResponseBody.
type ListProvidersResponseBody struct {
	Providers []SSOProvider `json:"providers"`
}

// ListResponseBody defines model for ListResponseBody.
type ListResponseBody struct {
	Data []APIKeyResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`

	// Total Total number of keys
	Total int64 `json:"total"`
}

// ListResponseBody2 defines model for ListResponseBody2.
type ListResponseBody2 struct {
	Data []Organization `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListResponseBody3 defines model for ListResponseBody3.
type ListResponseBody3 struct {
	Passkeys []RegisteredPasskey `json:"passkeys"`
}

// ListResponseBody4 defines model for ListResponseBody4.
type ListResponseBody4 struct {
	Data []User `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListResponseBody5 defines model for ListResponseBody5.
type ListResponseBody5 struct {
	Data []WebhookResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListRolePermissionsResponseBody defines model for ListRolePermissionsResponseBody.
type ListRolePermissionsResponseBody struct {
	Permissions []PermissionResponse `json:"permissions"`
}

// ListRolesResponseBody defines model for ListRolesResponseBody.
type ListRolesResponseBody struct {
	Data []RoleResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListScopesResponseBody defines model for ListScopesResponseBody.
type ListScopesResponseBody struct {
	Data []OAuthScopeResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// ListTemplatesResponseBody defines model for ListTemplatesResponseBody.
type ListTemplatesResponseBody struct {
	Data []EmailTemplateResponse `json:"data"`

	// Pagination Pagination parameters
	Pagination Pagination `json:"pagination"`
}

// LoginCompleteResponseBody defines model for LoginCompleteResponseBody.
type LoginCompleteResponseBody struct {
	// Authenticated Whether authentication was successful
	Authenticated bool `json:"authenticated"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// LoginRequest Login credentials
type LoginRequest struct {
	// CaptchaResponse CAPTCHA response for protected login
	CaptchaResponse *string `json:"captcha_response,omitempty"`

	// Email User email
	Email openapi_types.Email `json:"email"`

	// OrganizationId Organization ID if logging into a specific organization
	OrganizationId *string `json:"organization_id,omitempty"`

	// Password User password
	Password string `json:"password"`

	// RememberMe Whether to remember the user
	RememberMe *bool `json:"remember_me,omitempty"`
}

// LoginResponse2 defines model for LoginResponse2.
type LoginResponse2 struct {
	// CsrfToken CSRF token
	CsrfToken string `json:"csrf_token"`

	// EmailVerified Whether email is verified
	EmailVerified *bool `json:"emailVerified,omitempty"`

	// ExpiresAt Token expiry timestamp
	ExpiresAt int64 `json:"expires_at"`

	// Message Login message
	Message *string `json:"message,omitempty"`

	// MfaRequired Whether MFA is required to complete authentication
	MfaRequired bool `json:"mfa_required"`

	// MfaTypes Available MFA methods when MFA is required
	MfaTypes *[]string `json:"mfa_types,omitempty"`

	// RefreshToken JWTAuth refresh token
	RefreshToken string `json:"refresh_token"`

	// RequiresVerification Whether email verification is required
	RequiresVerification *bool `json:"requiresVerification,omitempty"`

	// Token JWTAuth access token
	Token string `json:"token"`

	// User User information
	User User `json:"user"`

	// VerificationId Verification ID for email verification
	VerificationId *string `json:"verificationId,omitempty"`

	// VerificationMethod Verification method for email verification
	VerificationMethod *string `json:"verificationMethod,omitempty"`

	// VerificationRequired Whether email verification is required
	VerificationRequired *bool `json:"verificationRequired,omitempty"`
}

// LoginResponse3 defines model for LoginResponse3.
type LoginResponse3 struct {
	// CsrfToken CSRF token
	CsrfToken string `json:"csrf_token"`

	// EmailVerified Whether email is verified
	EmailVerified *bool `json:"emailVerified,omitempty"`

	// ExpiresAt Token expiry timestamp
	ExpiresAt int64 `json:"expires_at"`

	// Message Login message
	Message *string `json:"message,omitempty"`

	// MfaRequired Whether MFA is required to complete authentication
	MfaRequired bool `json:"mfa_required"`

	// MfaTypes Available MFA methods when MFA is required
	MfaTypes *[]string `json:"mfa_types,omitempty"`

	// RefreshToken JWTAuth refresh token
	RefreshToken string `json:"refresh_token"`

	// RequiresVerification Whether email verification is required
	RequiresVerification *bool `json:"requiresVerification,omitempty"`

	// Token JWTAuth access token
	Token string `json:"token"`

	// User User information
	User User `json:"user"`

	// VerificationId Verification ID for email verification
	VerificationId *string `json:"verificationId,omitempty"`

	// VerificationMethod Verification method for email verification
	VerificationMethod *string `json:"verificationMethod,omitempty"`

	// VerificationRequired Whether email verification is required
	VerificationRequired *bool `json:"verificationRequired,omitempty"`
}

// MFAEnrollRequest MFA enrollment request
type MFAEnrollRequest struct {
	// Email Email for email verification
	Email *openapi_types.Email `json:"email,omitempty"`

	// Method MFA method to enroll
	Method MFAEnrollRequestMethod `json:"method"`

	// PhoneNumber Phone number for SMS verification
	PhoneNumber *string `json:"phone_number,omitempty"`
}

// MFAEnrollRequestMethod MFA method to enroll
type MFAEnrollRequestMethod string

// MFAUnEnrollRequest MFA unenrollment request
type MFAUnEnrollRequest struct {
	// Method MFA method to unenroll
	Method MFAUnEnrollRequestMethod `json:"method"`
}

// MFAUnEnrollRequestMethod MFA method to unenroll
type MFAUnEnrollRequestMethod string

// MFAVerifyRequest MFA verification request
type MFAVerifyRequest struct {
	// Code Verification code
	Code string `json:"code"`

	// Method MFA method to verify
	Method MFAVerifyRequestMethod `json:"method"`

	// PhoneNumber Phone number for SMS verification
	PhoneNumber *string `json:"phone_number,omitempty"`
}

// MFAVerifyRequestMethod MFA method to verify
type MFAVerifyRequestMethod string

// MagicLinkRequest Magic link generation request
type MagicLinkRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// ExpiresIn Link expiry in seconds
	ExpiresIn *int64 `json:"expires_in,omitempty"`

	// RedirectUrl URL to redirect after authentication
	RedirectUrl string `json:"redirect_url"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// MagicLinkResponseBody defines model for MagicLinkResponseBody.
type MagicLinkResponseBody struct {
	// ExpiresIn Expiry in seconds
	ExpiresIn int64 `json:"expires_in"`

	// MagicLink Generated magic link
	MagicLink string `json:"magic_link"`
}

// MethodsResponseBody defines model for MethodsResponseBody.
type MethodsResponseBody struct {
	// Methods Enabled MFA methods
	Methods []string `json:"methods"`
}

// MethodsResponseBody2 defines model for MethodsResponseBody2.
type MethodsResponseBody2 struct {
	// Enabled Whether passwordless auth is enabled
	Enabled bool `json:"enabled"`

	// Methods Available methods
	Methods []string `json:"methods"`
}

// MetricsResponseBody defines model for MetricsResponseBody.
type MetricsResponseBody struct {
	// Errors Total error count
	Errors *int64 `json:"errors,omitempty"`

	// Goroutines Number of goroutines
	Goroutines int64 `json:"goroutines"`

	// MemoryUsage Memory usage in bytes
	MemoryUsage int64 `json:"memory_usage"`

	// RequestRate Requests per second
	RequestRate *float32 `json:"request_rate,omitempty"`

	// Requests Total request count
	Requests *int64 `json:"requests,omitempty"`

	// Uptime System uptime in seconds
	Uptime int64 `json:"uptime"`
}

// NotFoundError Not found response
type NotFoundError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// OAuthClientResponse OAuth client information
type OAuthClientResponse struct {
	// Active Whether client is active
	Active bool `json:"active"`

	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes []string `json:"allowed_grant_types"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientId OAuth client ID
	ClientId string `json:"client_id"`

	// ClientName Client name
	ClientName string `json:"client_name"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"created_at,omitempty"`

	// Id Client ID
	Id string `json:"id"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public bool `json:"public"`

	// RedirectUris Authorized redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// OAuthClientWithSecretResponse OAuth client information with client secret
type OAuthClientWithSecretResponse struct {
	// Active Whether client is active
	Active bool `json:"active"`

	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes []string `json:"allowed_grant_types"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientId OAuth client ID
	ClientId string `json:"client_id"`

	// ClientName Client name
	ClientName string `json:"client_name"`

	// ClientSecret OAuth client secret
	ClientSecret string `json:"client_secret"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt *string `json:"created_at,omitempty"`

	// Id Client ID
	Id string `json:"id"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public bool `json:"public"`

	// RedirectUris Authorized redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// OAuthScopeResponse OAuth scope information
type OAuthScopeResponse struct {
	// DefaultScope Whether this scope is included by default
	DefaultScope bool `json:"default_scope"`

	// Description Scope description
	Description string `json:"description"`

	// Id Scope ID
	Id string `json:"id"`

	// Name Scope name
	Name string `json:"name"`

	// Public Whether this scope can be requested by any client
	Public bool `json:"public"`
}

// OidcConfigurationResponseBody defines model for OidcConfigurationResponseBody.
type OidcConfigurationResponseBody struct {
	AuthorizationEndpoint             string    `json:"authorization_endpoint"`
	ClaimsSupported                   *[]string `json:"claims_supported,omitempty"`
	GrantTypesSupported               *[]string `json:"grant_types_supported,omitempty"`
	IdTokenSigningAlgValuesSupported  *[]string `json:"id_token_signing_alg_values_supported,omitempty"`
	Issuer                            string    `json:"issuer"`
	JwksUri                           string    `json:"jwks_uri"`
	RegistrationEndpoint              *string   `json:"registration_endpoint,omitempty"`
	ResponseModesSupported            *[]string `json:"response_modes_supported,omitempty"`
	ResponseTypesSupported            *[]string `json:"response_types_supported,omitempty"`
	ScopesSupported                   *[]string `json:"scopes_supported,omitempty"`
	SubjectTypesSupported             *[]string `json:"subject_types_supported,omitempty"`
	TokenEndpoint                     string    `json:"token_endpoint"`
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
	UserinfoEndpoint                  string    `json:"userinfo_endpoint"`
}

// Organization Organization information
type Organization struct {
	// Active Whether organization is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Domain Organization domain
	Domain *string `json:"domain,omitempty"`

	// Id Organization ID
	Id string `json:"id"`

	// LogoUrl Organization logo URL
	LogoUrl *string `json:"logo_url,omitempty"`

	// Metadata Organization metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Organization name
	Name string `json:"name"`

	// Plan Organization plan
	Plan *string `json:"plan,omitempty"`

	// Settings Organization information
	Settings *OrganizationSettings `json:"settings,omitempty"`

	// Slug Organization slug
	Slug string `json:"slug"`

	// TrialEndsAt Trial end date
	TrialEndsAt *string `json:"trial_ends_at,omitempty"`

	// TrialUsed Whether trial has been used
	TrialUsed *bool `json:"trial_used,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt string `json:"updated_at"`
}

// OrganizationFeatureResponse Organization feature information
type OrganizationFeatureResponse struct {
	// Component Feature component category
	Component *string `json:"component,omitempty"`

	// Description Feature description
	Description *string `json:"description,omitempty"`

	// Enabled Whether feature is enabled
	Enabled bool `json:"enabled"`

	// Id Feature ID
	Id string `json:"id"`

	// IsPremium Whether feature is premium
	IsPremium *bool `json:"is_premium,omitempty"`

	// Key Feature key
	Key string `json:"key"`

	// Name Feature name
	Name string `json:"name"`

	// Settings Feature settings
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// OrganizationMemberResponse Organization member information
type OrganizationMemberResponse struct {
	// Email User email
	Email string `json:"email"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// Id User ID
	Id string `json:"id"`

	// JoinedAt When user joined the organization
	JoinedAt string `json:"joined_at"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Roles User roles in organization
	Roles []string `json:"roles"`
}

// OrganizationSettings Organization information
type OrganizationSettings struct {
	// SignupFields Signup fields
	SignupFields *[]FormField `json:"signupFields,omitempty"`

	// Verification Signup fields
	Verification *[]OrganizationVerificationConfig `json:"verification,omitempty"`
}

// OrganizationVerificationConfig Configuration for organization verification
type OrganizationVerificationConfig struct {
	// CodeLength Length of verification code
	CodeLength *int64 `json:"code_length,omitempty"`

	// Method Method used for verification
	Method *OrganizationVerificationConfigMethod `json:"method,omitempty"`
}

// OrganizationVerificationConfigMethod Method used for verification
type OrganizationVerificationConfigMethod string

// Pagination Pagination parameters
type Pagination struct {
	// CurrentPage Current page number
	CurrentPage int64 `json:"current_page"`

	// HasNext Has next page
	HasNext bool `json:"has_next"`

	// HasPrevious Has previous page
	HasPrevious bool `json:"has_previous"`

	// Limit Limit
	Limit int64 `json:"limit"`

	// Offset Offset
	Offset int64 `json:"offset"`

	// Total Total number of items
	Total int64 `json:"total"`

	// TotalPages Total number of pages
	TotalPages int64 `json:"total_pages"`
}

// PasskeyLoginCompleteRequest Complete passkey authentication request
type PasskeyLoginCompleteRequest struct {
	// Response WebAuthn assertion response
	Response interface{} `json:"response"`

	// SessionId Authentication session ID
	SessionId string `json:"session_id"`
}

// PasskeyRegisterBeginRequest Begin passkey registration request
type PasskeyRegisterBeginRequest struct {
	// DeviceName Name of the device
	DeviceName *string `json:"device_name,omitempty"`

	// DeviceType Type of the device
	DeviceType *string `json:"device_type,omitempty"`
}

// PasskeyRegisterCompleteRequest Complete passkey registration request
type PasskeyRegisterCompleteRequest struct {
	// DeviceName Name of the device
	DeviceName *string `json:"device_name,omitempty"`

	// DeviceType Type of the device
	DeviceType *string `json:"device_type,omitempty"`

	// Response WebAuthn credential creation response
	Response interface{} `json:"response"`

	// SessionId Registration session ID
	SessionId string `json:"session_id"`
}

// PasswordlessEmailRequest Passwordless email login request
type PasswordlessEmailRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// RedirectUrl URL to redirect after successful authentication
	RedirectUrl *string `json:"redirect_url,omitempty"`
}

// PasswordlessSMSRequest Passwordless SMS login request
type PasswordlessSMSRequest struct {
	// PhoneNumber User phone number
	PhoneNumber string `json:"phone_number"`

	// RedirectUrl URL to redirect after successful authentication
	RedirectUrl *string `json:"redirect_url,omitempty"`
}

// PasswordlessVerifyRequest Passwordless verification request
type PasswordlessVerifyRequest struct {
	// AuthType Authentication type
	AuthType PasswordlessVerifyRequestAuthType `json:"auth_type"`

	// Code Verification code for SMS authentication
	Code *string `json:"code,omitempty"`

	// PhoneNumber Phone number for SMS authentication
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Token Verification token for email authentication
	Token *string `json:"token,omitempty"`
}

// PasswordlessVerifyRequestAuthType Authentication type
type PasswordlessVerifyRequestAuthType string

// PermissionResponse Permission information
type PermissionResponse struct {
	// Action Action this permission allows
	Action string `json:"action"`

	// Conditions JSON expression for conditional access
	Conditions *string `json:"conditions,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Description Permission description
	Description string `json:"description"`

	// Id Permission ID
	Id string `json:"id"`

	// Name Permission name
	Name string `json:"name"`

	// Resource Resource this permission applies to
	Resource string `json:"resource"`

	// System Whether this is a system permission
	System bool `json:"system"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// ProviderCallbackResponseBody defines model for ProviderCallbackResponseBody.
type ProviderCallbackResponseBody struct {
	// Authenticated Whether authentication was successful
	Authenticated bool `json:"authenticated"`

	// Message Success or error message
	Message string `json:"message"`

	// User User information
	User *User `json:"user,omitempty"`
}

// ReadyResponse Readiness check response
type ReadyResponse struct {
	// Status Readiness status
	Status ReadyResponseStatus `json:"status"`

	// Timestamp Timestamp of health check
	Timestamp time.Time `json:"timestamp"`
}

// ReadyResponseStatus Readiness status
type ReadyResponseStatus string

// RefreshTokenRequest Refresh token request
type RefreshTokenRequest struct {
	// RefreshToken JWTAuth refresh token
	RefreshToken string `json:"refresh_token"`
}

// RefreshTokenResponse Refresh token response
type RefreshTokenResponse struct {
	// ExpiresAt Token expiry timestamp
	ExpiresAt int64 `json:"expires_at"`

	// RefreshToken New refresh token
	RefreshToken string `json:"refresh_token"`

	// Token New JWTAuth access token
	Token string `json:"token"`
}

// RegisterBeginResponseBody defines model for RegisterBeginResponseBody.
type RegisterBeginResponseBody struct {
	// Options WebAuthn credential creation options
	Options interface{} `json:"options"`

	// SessionId Registration session ID
	SessionId string `json:"session_id"`
}

// RegisterRequest User registration data
type RegisterRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Metadata Additional user metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID if creating a user for a specific organization
	OrganizationId *string `json:"organization_id,omitempty"`

	// Password User password
	Password string `json:"password"`
}

// RegisteredPasskey Registered passkey information
type RegisteredPasskey struct {
	// DeviceType Device type
	DeviceType string `json:"device_type"`

	// Id Passkey ID
	Id string `json:"id"`

	// LastUsed Last usage timestamp
	LastUsed *string `json:"last_used,omitempty"`

	// Name Passkey name
	Name string `json:"name"`

	// RegisteredAt Registration timestamp
	RegisteredAt string `json:"registered_at"`
}

// ResetPasswordRequest Reset password request
type ResetPasswordRequest struct {
	// NewPassword New password
	NewPassword string `json:"new_password"`

	// Token Password reset token
	Token string `json:"token"`
}

// RoleResponse Role information
type RoleResponse struct {
	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Description Role description
	Description *string `json:"description,omitempty"`

	// Id Role ID
	Id string `json:"id"`

	// IsDefault Whether this is a default role for new users
	IsDefault bool `json:"is_default"`

	// Name Role name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Permissions Permissions assigned to this role
	Permissions *[]PermissionResponse `json:"permissions,omitempty"`

	// System Whether this is a system role
	System bool `json:"system"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// RotateClientSecretResponseBody defines model for RotateClientSecretResponseBody.
type RotateClientSecretResponseBody struct {
	ClientId     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
}

// SSOProvider SSO Provider information
type SSOProvider struct {
	// IconUrl Provider icon URL
	IconUrl *string `json:"icon_url,omitempty"`

	// Id Provider ID
	Id string `json:"id"`

	// Name Provider name
	Name string `json:"name"`

	// Type Provider type (oauth2, oidc, saml)
	Type string `json:"type"`
}

// SamlMetadataResponseBody defines model for SamlMetadataResponseBody.
type SamlMetadataResponseBody struct {
	// Metadata SAML metadata XML
	Metadata string `json:"metadata"`
}

// SendCodeRequestBody defines model for SendCodeRequestBody.
type SendCodeRequestBody struct {
	// Request Send MFA code request
	Request SendMFACodeRequest `json:"request"`
}

// SendEmailRequest Send email request
type SendEmailRequest struct {
	// Bcc BCC recipients
	Bcc *[]string `json:"bcc,omitempty"`

	// Cc CC recipients
	Cc *[]string `json:"cc,omitempty"`

	// From Sender email
	From *string `json:"from,omitempty"`

	// Headers Custom headers
	Headers *map[string]string `json:"headers,omitempty"`

	// HtmlContent HTML content
	HtmlContent *string `json:"html_content,omitempty"`

	// Metadata Email metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ReplyTo Reply-to address
	ReplyTo *string `json:"reply_to,omitempty"`

	// Subject Email subject
	Subject string `json:"subject"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`

	// To Recipients
	To []string `json:"to"`
}

// SendEmailVerificationRequestBody defines model for SendEmailVerificationRequestBody.
type SendEmailVerificationRequestBody struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// Method Verification method (link or otp)
	Method *SendEmailVerificationRequestBodyMethod `json:"method,omitempty"`
}

// SendEmailVerificationRequestBodyMethod Verification method (link or otp)
type SendEmailVerificationRequestBodyMethod string

// SendEmailVerificationResponseBody defines model for SendEmailVerificationResponseBody.
type SendEmailVerificationResponseBody struct {
	// ExpiresAt When the verification code/link expires
	ExpiresAt int64 `json:"expires_at"`

	// Message Success message
	Message string `json:"message"`
}

// SendMFACodeRequest Send MFA code request
type SendMFACodeRequest struct {
	// Method MFA method
	Method SendMFACodeRequestMethod `json:"method"`
}

// SendMFACodeRequestMethod MFA method
type SendMFACodeRequestMethod string

// SendResponseBody defines model for SendResponseBody.
type SendResponseBody struct {
	// Message Success message
	Message string `json:"message"`
}

// SendTemplateEmailRequest Send template email request
type SendTemplateEmailRequest struct {
	// Bcc BCC recipients
	Bcc *[]string `json:"bcc,omitempty"`

	// Cc CC recipients
	Cc *[]string `json:"cc,omitempty"`

	// From Sender email
	From *string `json:"from,omitempty"`

	// Headers Custom headers
	Headers *map[string]string `json:"headers,omitempty"`

	// Locale Template locale
	Locale *string `json:"locale,omitempty"`

	// Metadata Email metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// ReplyTo Reply-to address
	ReplyTo *string `json:"reply_to,omitempty"`

	// Subject Custom subject (overrides template subject)
	Subject *string `json:"subject,omitempty"`

	// TemplateData Template data
	TemplateData map[string]interface{} `json:"template_data"`

	// TemplateType Template type
	TemplateType string `json:"template_type"`

	// To Recipients
	To []string `json:"to"`
}

// Session User session information
type Session struct {
	// CreatedAt Created At
	CreatedAt time.Time `json:"created_at"`

	// DeviceId Device ID
	DeviceId *string `json:"device_id,omitempty"`

	// ExpiresAt Expiry timestamp
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID of the entity
	Id string `json:"id"`

	// IpAddress IP address
	IpAddress *string `json:"ip_address,omitempty"`

	// IsActive Session is active
	IsActive *bool `json:"is_active,omitempty"`

	// LastActiveAt Last activity timestamp
	LastActiveAt *time.Time `json:"last_active_at,omitempty"`

	// Location Location
	Location *string `json:"location,omitempty"`

	// Metadata Session metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `json:"organization_id,omitempty"`

	// Token Session token
	Token *string `json:"token,omitempty"`

	// UpdatedAt Updated At
	UpdatedAt time.Time `json:"updated_at"`

	// UserAgent User agent string
	UserAgent *string `json:"user_agent,omitempty"`

	// UserId User ID
	UserId *string `json:"user_id,omitempty"`
}

// TOTPEnrollResponse TOTP enrollment response
type TOTPEnrollResponse struct {
	// QrCodeData TOTP QR code as base64 image
	QrCodeData string `json:"qr_code_data"`

	// Secret TOTP secret key
	Secret string `json:"secret"`

	// Uri TOTP URI for QR code generation
	Uri string `json:"uri"`
}

// TokenResponseBody defines model for TokenResponseBody.
type TokenResponseBody struct {
	// AccessToken Access token
	AccessToken string `json:"access_token"`

	// ExpiresIn Token expiry in seconds
	ExpiresIn int64 `json:"expires_in"`

	// RefreshToken Refresh token
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope Granted scopes
	Scope *string `json:"scope,omitempty"`

	// TokenType Token type
	TokenType string `json:"token_type"`
}

// TriggerEventRequest Trigger webhook event request
type TriggerEventRequest struct {
	// EventType Event type
	EventType string `json:"event_type"`

	// Headers Custom headers
	Headers *map[string]string `json:"headers,omitempty"`

	// Payload Event payload
	Payload interface{} `json:"payload"`
}

// TriggerEventRequestBody defines model for TriggerEventRequestBody.
type TriggerEventRequestBody struct {
	// Event Trigger webhook event request
	Event TriggerEventRequest `json:"event"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`
}

// UnauthorizedError Unauthorized response
type UnauthorizedError struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *interface{} `json:"details,omitempty"`

	// Id Unique error ID
	Id *string `json:"id,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// UnenrollRequestBody defines model for UnenrollRequestBody.
type UnenrollRequestBody struct {
	// Request MFA unenrollment request
	Request MFAUnEnrollRequest `json:"request"`
}

// UpdateAPIKeyRequest Update API key request
type UpdateAPIKeyRequest struct {
	// Active Whether API key is active
	Active *bool `json:"active,omitempty"`

	// ExpiresAt Expiry timestamp
	ExpiresAt *string `json:"expires_at,omitempty"`

	// Metadata Key metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name API key name
	Name *string `json:"name,omitempty"`

	// Permissions Key permissions
	Permissions *[]string `json:"permissions,omitempty"`

	// Scopes Key scopes
	Scopes *[]string `json:"scopes,omitempty"`
}

// UpdateClientRequestBody defines model for UpdateClientRequestBody.
type UpdateClientRequestBody struct {
	// Client Update OAuth client request
	Client UpdateOAuthClientRequest `json:"client"`
}

// UpdateEmailTemplateRequest Update email template request
type UpdateEmailTemplateRequest struct {
	// Active Whether template is active
	Active *bool `json:"active,omitempty"`

	// HtmlContent HTML content
	HtmlContent *string `json:"html_content,omitempty"`

	// Locale Template locale
	Locale *string `json:"locale,omitempty"`

	// Metadata Template metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Template name
	Name *string `json:"name,omitempty"`

	// Subject Email subject
	Subject *string `json:"subject,omitempty"`

	// TextContent Text content
	TextContent *string `json:"text_content,omitempty"`
}

// UpdateIdentityProviderRequest Update identity provider request
type UpdateIdentityProviderRequest struct {
	// Active Whether provider is active
	Active *bool `json:"active,omitempty"`

	// AttributesMapping Attributes mapping
	AttributesMapping *map[string]string `json:"attributes_mapping,omitempty"`

	// AuthorizationEndpoint OAuth/OIDC authorization endpoint
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// Certificate SAML certificate
	Certificate *string `json:"certificate,omitempty"`

	// ClientId OAuth/OIDC client ID
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret OAuth/OIDC client secret
	ClientSecret *string `json:"client_secret,omitempty"`

	// Domains Allowed email domains
	Domains *[]string `json:"domains,omitempty"`

	// Issuer OIDC issuer URL
	Issuer *string `json:"issuer,omitempty"`

	// JwksUri OIDC JWKS URI
	JwksUri *string `json:"jwks_uri,omitempty"`

	// MetadataUrl SAML metadata URL
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// Name Provider name
	Name *string `json:"name,omitempty"`

	// Primary Whether this is the primary provider
	Primary *bool `json:"primary,omitempty"`

	// PrivateKey SAML private key
	PrivateKey *string `json:"private_key,omitempty"`

	// RedirectUri OAuth/OIDC redirect URI
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// TokenEndpoint OAuth/OIDC token endpoint
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// UserinfoEndpoint OIDC userinfo endpoint
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`
}

// UpdateIdentityProviderRequestBody defines model for UpdateIdentityProviderRequestBody.
type UpdateIdentityProviderRequestBody struct {
	// Provider Update identity provider request
	Provider UpdateIdentityProviderRequest `json:"provider"`
}

// UpdateMemberRequestBody defines model for UpdateMemberRequestBody.
type UpdateMemberRequestBody struct {
	// Member Update organization member request
	Member UpdateOrganizationMemberRequest `json:"member"`
}

// UpdateOAuthClientRequest Update OAuth client request
type UpdateOAuthClientRequest struct {
	// Active Whether client is active
	Active *bool `json:"active,omitempty"`

	// AllowedCorsOrigins Allowed CORS origins
	AllowedCorsOrigins *[]string `json:"allowed_cors_origins,omitempty"`

	// AllowedGrantTypes Allowed grant types
	AllowedGrantTypes *[]string `json:"allowed_grant_types,omitempty"`

	// ClientDescription Client description
	ClientDescription *string `json:"client_description,omitempty"`

	// ClientName Client name
	ClientName *string `json:"client_name,omitempty"`

	// ClientUri Client URI
	ClientUri *string `json:"client_uri,omitempty"`

	// LogoUri Logo URI
	LogoUri *string `json:"logo_uri,omitempty"`

	// PostLogoutRedirectUris Authorized post-logout redirect URIs
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`

	// Public Whether client is public
	Public *bool `json:"public,omitempty"`

	// RedirectUris Authorized redirect URIs
	RedirectUris *[]string `json:"redirect_uris,omitempty"`

	// RefreshTokenExpirySeconds Refresh token expiry in seconds
	RefreshTokenExpirySeconds *int64 `json:"refresh_token_expiry_seconds,omitempty"`

	// RequiresConsent Whether user consent is required
	RequiresConsent *bool `json:"requires_consent,omitempty"`

	// RequiresPkce Whether PKCE is required
	RequiresPkce *bool `json:"requires_pkce,omitempty"`

	// TokenExpirySeconds Access token expiry in seconds
	TokenExpirySeconds *int64 `json:"token_expiry_seconds,omitempty"`
}

// UpdateOrganizationMemberRequest Update organization member request
type UpdateOrganizationMemberRequest struct {
	// Roles Roles to assign
	Roles []string `json:"roles"`
}

// UpdateOrganizationRequest Update organization request
type UpdateOrganizationRequest struct {
	// Active Whether organization is active
	Active *bool `json:"active,omitempty"`

	// Domain Organization domain
	Domain *string `json:"domain,omitempty"`

	// LogoUrl Organization logo URL
	LogoUrl *string `json:"logo_url,omitempty"`

	// Metadata Organization metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Organization name
	Name *string `json:"name,omitempty"`

	// Plan Organization plan
	Plan *string `json:"plan,omitempty"`
}

// UpdatePasskeyRequest Update passkey request
type UpdatePasskeyRequest struct {
	// Name New passkey name
	Name string `json:"name"`
}

// UpdatePasswordRequest Update password request
type UpdatePasswordRequest struct {
	// CurrentPassword Current password
	CurrentPassword string `json:"current_password"`

	// NewPassword New password
	NewPassword string `json:"new_password"`
}

// UpdatePermissionRequest Update permission request
type UpdatePermissionRequest struct {
	// Conditions JSON expression for conditional access
	Conditions *string `json:"conditions,omitempty"`

	// Description Permission description
	Description *string `json:"description,omitempty"`

	// Name Permission name
	Name *string `json:"name,omitempty"`
}

// UpdatePermissionRequestBody defines model for UpdatePermissionRequestBody.
type UpdatePermissionRequestBody struct {
	// Permission Update permission request
	Permission UpdatePermissionRequest `json:"permission"`
}

// UpdateRequestBody defines model for UpdateRequestBody.
type UpdateRequestBody struct {
	// Key Update API key request
	Key UpdateAPIKeyRequest `json:"key"`
}

// UpdateRequestBody2 defines model for UpdateRequestBody2.
type UpdateRequestBody2 struct {
	// Organization Update organization request
	Organization UpdateOrganizationRequest `json:"organization"`
}

// UpdateRequestBody3 defines model for UpdateRequestBody3.
type UpdateRequestBody3 struct {
	// Request Update passkey request
	Request UpdatePasskeyRequest `json:"request"`
}

// UpdateRequestBody4 defines model for UpdateRequestBody4.
type UpdateRequestBody4 struct {
	// User Update user request
	User UpdateUserRequest `json:"user"`
}

// UpdateRequestBody5 defines model for UpdateRequestBody5.
type UpdateRequestBody5 struct {
	// Webhook Update webhook request
	Webhook UpdateWebhookRequest `json:"webhook"`
}

// UpdateRoleRequest Update role request
type UpdateRoleRequest struct {
	// Description Role description
	Description *string `json:"description,omitempty"`

	// IsDefault Whether this is a default role for new users
	IsDefault *bool `json:"is_default,omitempty"`

	// Name Role name
	Name *string `json:"name,omitempty"`
}

// UpdateRoleRequestBody defines model for UpdateRoleRequestBody.
type UpdateRoleRequestBody struct {
	// Role Update role request
	Role UpdateRoleRequest `json:"role"`
}

// UpdateScopeRequestBody defines model for UpdateScopeRequestBody.
type UpdateScopeRequestBody struct {
	// DefaultScope Whether this scope is included by default
	DefaultScope *bool `json:"default_scope,omitempty"`

	// Description Scope description
	Description *string `json:"description,omitempty"`

	// Public Whether this scope can be requested by any client
	Public *bool `json:"public,omitempty"`
}

// UpdateTemplateRequestBody defines model for UpdateTemplateRequestBody.
type UpdateTemplateRequestBody struct {
	// Template Update email template request
	Template UpdateEmailTemplateRequest `json:"template"`
}

// UpdateUserRequest Update user request
type UpdateUserRequest struct {
	// Active Whether user is active
	Active *bool `json:"active,omitempty"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Locale User locale
	Locale *string `json:"locale,omitempty"`

	// Metadata User metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PhoneNumber User phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PrimaryOrganizationId Primary organization ID
	PrimaryOrganizationId *string `json:"primary_organization_id,omitempty"`

	// ProfileImageUrl Profile image URL
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`
}

// UpdateWebhookRequest Update webhook request
type UpdateWebhookRequest struct {
	// Active Whether webhook is active
	Active *bool `json:"active,omitempty"`

	// EventTypes Event types to subscribe to
	EventTypes *[]string `json:"event_types,omitempty"`

	// Format Payload format
	Format *UpdateWebhookRequestFormat `json:"format,omitempty"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name *string `json:"name,omitempty"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// Url Webhook URL
	Url *string `json:"url,omitempty"`
}

// UpdateWebhookRequestFormat Payload format
type UpdateWebhookRequestFormat string

// User User information
type User struct {
	// Active Whether account is active
	Active bool `json:"active"`

	// Email Email address
	Email openapi_types.Email `json:"email"`

	// EmailVerified Whether email is verified
	EmailVerified bool `json:"email_verified"`

	// FirstName User first name
	FirstName *string `json:"first_name,omitempty"`

	// Id ID of the entity
	Id *string `json:"id,omitempty"`

	// LastName User last name
	LastName *string `json:"last_name,omitempty"`

	// Locale User locale
	Locale *string `json:"locale,omitempty"`

	// Metadata User metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PhoneNumber User phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PhoneVerified Whether phone is verified
	PhoneVerified *bool `json:"phone_verified,omitempty"`

	// ProfileImageUrl URL to user's profile image
	ProfileImageUrl *string `json:"profile_image_url,omitempty"`
}

// UserinfoResponseBody defines model for UserinfoResponseBody.
type UserinfoResponseBody struct {
	// Birthdate Birth date
	Birthdate *string `json:"birthdate,omitempty"`

	// Email Email address
	Email *string `json:"email,omitempty"`

	// EmailVerified Whether email is verified
	EmailVerified *bool `json:"email_verified,omitempty"`

	// FamilyName Last name
	FamilyName *string `json:"family_name,omitempty"`

	// Gender Gender
	Gender *string `json:"gender,omitempty"`

	// GivenName First name
	GivenName *string `json:"given_name,omitempty"`

	// Locale Locale
	Locale *string `json:"locale,omitempty"`

	// MiddleName Middle name
	MiddleName *string `json:"middle_name,omitempty"`

	// Name Full name
	Name *string `json:"name,omitempty"`

	// Nickname Nickname
	Nickname *string `json:"nickname,omitempty"`

	// PhoneNumber Phone number
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PhoneNumberVerified Whether phone number is verified
	PhoneNumberVerified *bool `json:"phone_number_verified,omitempty"`

	// Picture Picture URL
	Picture *string `json:"picture,omitempty"`

	// PreferredUsername Preferred username
	PreferredUsername *string `json:"preferred_username,omitempty"`

	// Profile Profile URL
	Profile *string `json:"profile,omitempty"`

	// Sub Subject (user ID)
	Sub string `json:"sub"`

	// UpdatedAt Last update timestamp
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// Website Website URL
	Website *string `json:"website,omitempty"`

	// Zoneinfo Time zone
	Zoneinfo *string `json:"zoneinfo,omitempty"`
}

// ValidateResponseBody defines model for ValidateResponseBody.
type ValidateResponseBody struct {
	// Key API key information without the actual key
	Key *APIKeyResponse `json:"key,omitempty"`

	// Valid Whether key is valid
	Valid bool `json:"valid"`
}

// VerifyEmailRequest Email verification request
type VerifyEmailRequest struct {
	// Email User email
	Email openapi_types.Email `json:"email"`

	// Method Verification method (link or otp)
	Method VerifyEmailRequestMethod `json:"method"`

	// Otp One-time password for OTP verification
	Otp *string `json:"otp,omitempty"`

	// Token Email verification token for link verification
	Token *string `json:"token,omitempty"`
}

// VerifyEmailRequestMethod Verification method (link or otp)
type VerifyEmailRequestMethod string

// VerifyRequestBody defines model for VerifyRequestBody.
type VerifyRequestBody struct {
	// Request MFA verification request
	Request MFAVerifyRequest `json:"request"`
}

// VerifyResponseBody defines model for VerifyResponseBody.
type VerifyResponseBody struct {
	// Authenticated Whether authentication was successful
	Authenticated bool `json:"authenticated"`

	// Email User email
	Email *string `json:"email,omitempty"`

	// User User information
	User *User `json:"user,omitempty"`

	// UserId User ID
	UserId string `json:"user_id"`
}

// VersionResponseBody defines model for VersionResponseBody.
type VersionResponseBody struct {
	// BuildDate Build date
	BuildDate time.Time `json:"build_date"`

	// GitCommit Git commit hash
	GitCommit *string `json:"git_commit,omitempty"`

	// GoVersion Go version
	GoVersion *string `json:"go_version,omitempty"`

	// Version System version
	Version string `json:"version"`
}

// WebhookEventResponse Webhook event information
type WebhookEventResponse struct {
	// Attempts Number of delivery attempts
	Attempts int64 `json:"attempts"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// Delivered Whether event was delivered
	Delivered bool `json:"delivered"`

	// DeliveredAt Delivery timestamp
	DeliveredAt *string `json:"delivered_at,omitempty"`

	// Error Error from last attempt
	Error *string `json:"error,omitempty"`

	// EventType Event type
	EventType string `json:"event_type"`

	// Headers Event headers
	Headers *map[string]string `json:"headers,omitempty"`

	// Id Event ID
	Id string `json:"id"`

	// NextRetry Next retry timestamp
	NextRetry *string `json:"next_retry,omitempty"`

	// Payload Event payload
	Payload *interface{} `json:"payload,omitempty"`

	// ResponseBody Response from last attempt
	ResponseBody *string `json:"response_body,omitempty"`

	// StatusCode HTTP status code from last attempt
	StatusCode *int64 `json:"status_code,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// WebhookId Webhook ID
	WebhookId string `json:"webhook_id"`
}

// WebhookResponse Webhook information
type WebhookResponse struct {
	// Active Whether webhook is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// EventTypes Event types webhook subscribes to
	EventTypes []string `json:"event_types"`

	// Format Payload format (json/form)
	Format *string `json:"format,omitempty"`

	// Id Webhook ID
	Id string `json:"id"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Url Webhook URL
	Url string `json:"url"`

	// Version Webhook version
	Version *string `json:"version,omitempty"`
}

// WebhookSecretResponse Webhook creation response with secret
type WebhookSecretResponse struct {
	// Active Whether webhook is active
	Active bool `json:"active"`

	// CreatedAt Creation timestamp
	CreatedAt string `json:"created_at"`

	// EventTypes Event types webhook subscribes to
	EventTypes []string `json:"event_types"`

	// Format Payload format (json/form)
	Format *string `json:"format,omitempty"`

	// Id Webhook ID
	Id string `json:"id"`

	// Metadata Webhook metadata
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Webhook name
	Name string `json:"name"`

	// OrganizationId Organization ID
	OrganizationId string `json:"organization_id"`

	// RetryCount Number of retries on failure
	RetryCount *int64 `json:"retry_count,omitempty"`

	// Secret Webhook secret for signature verification
	Secret string `json:"secret"`

	// TimeoutMs Timeout in milliseconds
	TimeoutMs *int64 `json:"timeout_ms,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Url Webhook URL
	Url string `json:"url"`

	// Version Webhook version
	Version *string `json:"version,omitempty"`
}

// RbacCheckPermissionParams defines parameters for RbacCheckPermission.
type RbacCheckPermissionParams struct {
	// Resource Resource to check
	Resource string `form:"resource" json:"resource"`

	// Action Action to check
	Action string `form:"action" json:"action"`
}

// RbacCheckRoleParams defines parameters for RbacCheckRole.
type RbacCheckRoleParams struct {
	// Role Role name to check
	Role string `form:"role" json:"role"`

	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// ApiKeysListParams defines parameters for ApiKeysList.
type ApiKeysListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Type Filter by key type
	Type *ApiKeysListParamsType `form:"type,omitempty" json:"type,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// ApiKeysListParamsType defines parameters for ApiKeysList.
type ApiKeysListParamsType string

// ApiKeysValidateParams defines parameters for ApiKeysValidate.
type ApiKeysValidateParams struct {
	// ApiKey API key to validate
	ApiKey string `form:"api_key" json:"api_key"`
}

// AuthCheckEmailVerificationParams defines parameters for AuthCheckEmailVerification.
type AuthCheckEmailVerificationParams struct {
	// Email User email
	Email    openapi_types.Email `form:"email" json:"email"`
	FrankSid *string             `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthCsrfParams defines parameters for AuthCsrf.
type AuthCsrfParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthForgotPasswordParams defines parameters for AuthForgotPassword.
type AuthForgotPasswordParams struct {
	// RedirectUrl URL to redirect after password reset
	RedirectUrl *string `form:"redirect_url,omitempty" json:"redirect_url,omitempty"`
	FrankSid    *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthLoginParams defines parameters for AuthLogin.
type AuthLoginParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthLogoutParams defines parameters for AuthLogout.
type AuthLogoutParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthMeParams defines parameters for AuthMe.
type AuthMeParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// OauthClientProviderCallbackParams defines parameters for OauthClientProviderCallback.
type OauthClientProviderCallbackParams struct {
	// Code Authorization code
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// State State parameter
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// OauthClientProviderAuthParams defines parameters for OauthClientProviderAuth.
type OauthClientProviderAuthParams struct {
	// RedirectUri Redirect URI after authentication
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
}

// AuthRefreshTokenParams defines parameters for AuthRefreshToken.
type AuthRefreshTokenParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthRegisterParams defines parameters for AuthRegister.
type AuthRegisterParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthResetPasswordParams defines parameters for AuthResetPassword.
type AuthResetPasswordParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// AuthSendEmailVerificationParams defines parameters for AuthSendEmailVerification.
type AuthSendEmailVerificationParams struct {
	// RedirectUrl URL to redirect after verification (for link verification)
	RedirectUrl *string `form:"redirect_url,omitempty" json:"redirect_url,omitempty"`
	FrankSid    *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// SsoProviderCallbackParams defines parameters for SsoProviderCallback.
type SsoProviderCallbackParams struct {
	// Code Authorization code
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// State State parameter
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// SAMLResponse SAML response
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`

	// RelayState SAML relay state
	RelayState *string `form:"RelayState,omitempty" json:"RelayState,omitempty"`
}

// SsoListIdentityProvidersParams defines parameters for SsoListIdentityProviders.
type SsoListIdentityProvidersParams struct {
	// OrganizationId Organization ID
	OrganizationId string `form:"organization_id" json:"organization_id"`
}

// SsoListProvidersParams defines parameters for SsoListProviders.
type SsoListProvidersParams struct {
	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// SsoProviderAuthParams defines parameters for SsoProviderAuth.
type SsoProviderAuthParams struct {
	// RedirectUri Redirect URI after authentication
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
}

// AuthVerifyEmailParams defines parameters for AuthVerifyEmail.
type AuthVerifyEmailParams struct {
	FrankSid *string `form:"frank_sid,omitempty" json:"frank_sid,omitempty"`
}

// EmailListTemplatesParams defines parameters for EmailListTemplates.
type EmailListTemplatesParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Type Filter by template type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Locale Filter by locale
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// EmailGetTemplateByTypeParams defines parameters for EmailGetTemplateByType.
type EmailGetTemplateByTypeParams struct {
	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Locale Template locale
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// OauthProviderAuthorizeParams defines parameters for OauthProviderAuthorize.
type OauthProviderAuthorizeParams struct {
	// ClientId OAuth client identifier
	ClientId string `form:"client_id" json:"client_id"`

	// ResponseType OAuth response type
	ResponseType string `form:"response_type" json:"response_type"`

	// RedirectUri Redirect URI after authorization
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// Scope Requested scopes (space-separated)
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// State OAuth state parameter
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// CodeChallenge PKCE code challenge
	CodeChallenge *string `form:"code_challenge,omitempty" json:"code_challenge,omitempty"`

	// CodeChallengeMethod PKCE code challenge method
	CodeChallengeMethod *string `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`
}

// OauthProviderListClientsParams defines parameters for OauthProviderListClients.
type OauthProviderListClientsParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// OauthProviderIntrospectParams defines parameters for OauthProviderIntrospect.
type OauthProviderIntrospectParams struct {
	// Token Token to introspect
	Token string `form:"token" json:"token"`

	// TokenTypeHint Token type hint
	TokenTypeHint *string `form:"token_type_hint,omitempty" json:"token_type_hint,omitempty"`
}

// OauthProviderRevokeParams defines parameters for OauthProviderRevoke.
type OauthProviderRevokeParams struct {
	// Token Token to revoke
	Token string `form:"token" json:"token"`

	// TokenTypeHint Token type hint
	TokenTypeHint *string `form:"token_type_hint,omitempty" json:"token_type_hint,omitempty"`

	// ClientId Client ID
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// ClientSecret Client secret
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty"`
}

// OauthProviderListScopesParams defines parameters for OauthProviderListScopes.
type OauthProviderListScopesParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// OauthProviderTokenParams defines parameters for OauthProviderToken.
type OauthProviderTokenParams struct {
	// GrantType Grant type
	GrantType string `form:"grant_type" json:"grant_type"`

	// Code Authorization code (for authorization_code grant)
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// RedirectUri Redirect URI (for authorization_code grant)
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// ClientId Client ID
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// ClientSecret Client secret
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty"`

	// RefreshToken Refresh token (for refresh_token grant)
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`

	// CodeVerifier PKCE code verifier (for authorization_code grant)
	CodeVerifier *string `form:"code_verifier,omitempty" json:"code_verifier,omitempty"`

	// Username Resource owner username (for password grant)
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Password Resource owner password (for password grant)
	Password *string `form:"password,omitempty" json:"password,omitempty"`

	// Scope Requested scopes (space-separated)
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`
}

// OrganizationsListParams defines parameters for OrganizationsList.
type OrganizationsListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// OrganizationsListMembersParams defines parameters for OrganizationsListMembers.
type OrganizationsListMembersParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// RbacListPermissionsParams defines parameters for RbacListPermissions.
type RbacListPermissionsParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Resource Filter by resource
	Resource *string `form:"resource,omitempty" json:"resource,omitempty"`

	// Action Filter by action
	Action *string `form:"action,omitempty" json:"action,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// RbacListRolesParams defines parameters for RbacListRoles.
type RbacListRolesParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// UsersListParams defines parameters for UsersList.
type UsersListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Search term
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// OrganizationId Filter by organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`
}

// WebhooksListParams defines parameters for WebhooksList.
type WebhooksListParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrganizationId Organization ID
	OrganizationId *string `form:"organization_id,omitempty" json:"organization_id,omitempty"`

	// EventTypes Filter by event types
	EventTypes *[]string `form:"event_types,omitempty" json:"event_types,omitempty"`
}

// WebhooksListEventsParams defines parameters for WebhooksListEvents.
type WebhooksListEventsParams struct {
	// Offset Pagination offset
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventType Filter by event type
	EventType *string `form:"event_type,omitempty" json:"event_type,omitempty"`

	// Delivered Filter by delivery status
	Delivered *bool `form:"delivered,omitempty" json:"delivered,omitempty"`
}

// ApiKeysCreateJSONRequestBody defines body for ApiKeysCreate for application/json ContentType.
type ApiKeysCreateJSONRequestBody = CreateRequestBody

// ApiKeysUpdateJSONRequestBody defines body for ApiKeysUpdate for application/json ContentType.
type ApiKeysUpdateJSONRequestBody = UpdateRequestBody

// AuthForgotPasswordJSONRequestBody defines body for AuthForgotPassword for application/json ContentType.
type AuthForgotPasswordJSONRequestBody = ForgotPasswordRequest

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody = LoginRequest

// MfaEnrollJSONRequestBody defines body for MfaEnroll for application/json ContentType.
type MfaEnrollJSONRequestBody = EnrollRequestBody

// MfaSendCodeJSONRequestBody defines body for MfaSendCode for application/json ContentType.
type MfaSendCodeJSONRequestBody = SendCodeRequestBody

// MfaUnenrollJSONRequestBody defines body for MfaUnenroll for application/json ContentType.
type MfaUnenrollJSONRequestBody = UnenrollRequestBody

// MfaVerifyJSONRequestBody defines body for MfaVerify for application/json ContentType.
type MfaVerifyJSONRequestBody = VerifyRequestBody

// PasskeysLoginCompleteJSONRequestBody defines body for PasskeysLoginComplete for application/json ContentType.
type PasskeysLoginCompleteJSONRequestBody = PasskeyLoginCompleteRequest

// PasskeysRegisterBeginJSONRequestBody defines body for PasskeysRegisterBegin for application/json ContentType.
type PasskeysRegisterBeginJSONRequestBody = PasskeyRegisterBeginRequest

// PasskeysRegisterCompleteJSONRequestBody defines body for PasskeysRegisterComplete for application/json ContentType.
type PasskeysRegisterCompleteJSONRequestBody = PasskeyRegisterCompleteRequest

// PasskeysUpdateJSONRequestBody defines body for PasskeysUpdate for application/json ContentType.
type PasskeysUpdateJSONRequestBody = UpdateRequestBody3

// PasswordlessEmailJSONRequestBody defines body for PasswordlessEmail for application/json ContentType.
type PasswordlessEmailJSONRequestBody = PasswordlessEmailRequest

// PasswordlessMagicLinkJSONRequestBody defines body for PasswordlessMagicLink for application/json ContentType.
type PasswordlessMagicLinkJSONRequestBody = MagicLinkRequest

// PasswordlessSmsJSONRequestBody defines body for PasswordlessSms for application/json ContentType.
type PasswordlessSmsJSONRequestBody = PasswordlessSMSRequest

// PasswordlessVerifyJSONRequestBody defines body for PasswordlessVerify for application/json ContentType.
type PasswordlessVerifyJSONRequestBody = PasswordlessVerifyRequest

// AuthRefreshTokenJSONRequestBody defines body for AuthRefreshToken for application/json ContentType.
type AuthRefreshTokenJSONRequestBody = RefreshTokenRequest

// AuthRegisterJSONRequestBody defines body for AuthRegister for application/json ContentType.
type AuthRegisterJSONRequestBody = RegisterRequest

// AuthResetPasswordJSONRequestBody defines body for AuthResetPassword for application/json ContentType.
type AuthResetPasswordJSONRequestBody = ResetPasswordRequest

// AuthSendEmailVerificationJSONRequestBody defines body for AuthSendEmailVerification for application/json ContentType.
type AuthSendEmailVerificationJSONRequestBody = SendEmailVerificationRequestBody

// SsoCreateIdentityProviderJSONRequestBody defines body for SsoCreateIdentityProvider for application/json ContentType.
type SsoCreateIdentityProviderJSONRequestBody = CreateIdentityProviderRequestBody

// SsoUpdateIdentityProviderJSONRequestBody defines body for SsoUpdateIdentityProvider for application/json ContentType.
type SsoUpdateIdentityProviderJSONRequestBody = UpdateIdentityProviderRequestBody

// AuthVerifyEmailJSONRequestBody defines body for AuthVerifyEmail for application/json ContentType.
type AuthVerifyEmailJSONRequestBody = VerifyEmailRequest

// EmailSendJSONRequestBody defines body for EmailSend for application/json ContentType.
type EmailSendJSONRequestBody = SendEmailRequest

// EmailSendTemplateJSONRequestBody defines body for EmailSendTemplate for application/json ContentType.
type EmailSendTemplateJSONRequestBody = SendTemplateEmailRequest

// EmailCreateTemplateJSONRequestBody defines body for EmailCreateTemplate for application/json ContentType.
type EmailCreateTemplateJSONRequestBody = CreateEmailTemplateRequest

// EmailUpdateTemplateJSONRequestBody defines body for EmailUpdateTemplate for application/json ContentType.
type EmailUpdateTemplateJSONRequestBody = UpdateTemplateRequestBody

// OauthProviderCreateClientJSONRequestBody defines body for OauthProviderCreateClient for application/json ContentType.
type OauthProviderCreateClientJSONRequestBody = CreateOAuthClientRequest

// OauthProviderUpdateClientJSONRequestBody defines body for OauthProviderUpdateClient for application/json ContentType.
type OauthProviderUpdateClientJSONRequestBody = UpdateClientRequestBody

// OauthProviderConsentJSONRequestBody defines body for OauthProviderConsent for application/json ContentType.
type OauthProviderConsentJSONRequestBody = ConsentRequest

// OauthProviderCreateScopeJSONRequestBody defines body for OauthProviderCreateScope for application/json ContentType.
type OauthProviderCreateScopeJSONRequestBody = CreateOAuthScopeRequest

// OauthProviderUpdateScopeJSONRequestBody defines body for OauthProviderUpdateScope for application/json ContentType.
type OauthProviderUpdateScopeJSONRequestBody = UpdateScopeRequestBody

// OrganizationsCreateJSONRequestBody defines body for OrganizationsCreate for application/json ContentType.
type OrganizationsCreateJSONRequestBody = CreateRequestBody2

// OrganizationsUpdateJSONRequestBody defines body for OrganizationsUpdate for application/json ContentType.
type OrganizationsUpdateJSONRequestBody = UpdateRequestBody2

// OrganizationsEnableFeatureJSONRequestBody defines body for OrganizationsEnableFeature for application/json ContentType.
type OrganizationsEnableFeatureJSONRequestBody = EnableFeatureRequestBody

// OrganizationsAddMemberJSONRequestBody defines body for OrganizationsAddMember for application/json ContentType.
type OrganizationsAddMemberJSONRequestBody = AddMemberRequestBody

// OrganizationsUpdateMemberJSONRequestBody defines body for OrganizationsUpdateMember for application/json ContentType.
type OrganizationsUpdateMemberJSONRequestBody = UpdateMemberRequestBody

// RbacCreatePermissionJSONRequestBody defines body for RbacCreatePermission for application/json ContentType.
type RbacCreatePermissionJSONRequestBody = CreatePermissionRequestBody

// RbacUpdatePermissionJSONRequestBody defines body for RbacUpdatePermission for application/json ContentType.
type RbacUpdatePermissionJSONRequestBody = UpdatePermissionRequestBody

// RbacCreateRoleJSONRequestBody defines body for RbacCreateRole for application/json ContentType.
type RbacCreateRoleJSONRequestBody = CreateRoleRequestBody

// RbacUpdateRoleJSONRequestBody defines body for RbacUpdateRole for application/json ContentType.
type RbacUpdateRoleJSONRequestBody = UpdateRoleRequestBody

// RbacAddRolePermissionJSONRequestBody defines body for RbacAddRolePermission for application/json ContentType.
type RbacAddRolePermissionJSONRequestBody = AddRolePermissionRequestBody

// UsersCreateJSONRequestBody defines body for UsersCreate for application/json ContentType.
type UsersCreateJSONRequestBody = CreateUserRequest

// UsersUpdateMeJSONRequestBody defines body for UsersUpdateMe for application/json ContentType.
type UsersUpdateMeJSONRequestBody = UpdateUserRequest

// UsersUpdatePasswordJSONRequestBody defines body for UsersUpdatePassword for application/json ContentType.
type UsersUpdatePasswordJSONRequestBody = UpdatePasswordRequest

// UsersUpdateJSONRequestBody defines body for UsersUpdate for application/json ContentType.
type UsersUpdateJSONRequestBody = UpdateRequestBody4

// WebhooksCreateJSONRequestBody defines body for WebhooksCreate for application/json ContentType.
type WebhooksCreateJSONRequestBody = CreateRequestBody3

// WebhooksTriggerEventJSONRequestBody defines body for WebhooksTriggerEvent for application/json ContentType.
type WebhooksTriggerEventJSONRequestBody = TriggerEventRequestBody

// WebhooksUpdateJSONRequestBody defines body for WebhooksUpdate for application/json ContentType.
type WebhooksUpdateJSONRequestBody = UpdateRequestBody5

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthDebug request
	HealthDebug(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthMetrics request
	HealthMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthReady request
	HealthReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthVersion request
	HealthVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCheckPermission request
	RbacCheckPermission(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCheckRole request
	RbacCheckRole(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysList request
	ApiKeysList(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysCreateWithBody request with any body
	ApiKeysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiKeysCreate(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysValidate request
	ApiKeysValidate(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysDelete request
	ApiKeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysGet request
	ApiKeysGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiKeysUpdateWithBody request with any body
	ApiKeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiKeysUpdate(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthCheckEmailVerification request
	AuthCheckEmailVerification(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthCsrf request
	AuthCsrf(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthForgotPasswordWithBody request with any body
	AuthForgotPasswordWithBody(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthForgotPassword(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLoginWithBody request with any body
	AuthLoginWithBody(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLogin(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogout request
	AuthLogout(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthMe request
	AuthMe(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaEnrollWithBody request with any body
	MfaEnrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaEnroll(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaMethods request
	MfaMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaSendCodeWithBody request with any body
	MfaSendCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaSendCode(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaUnenrollWithBody request with any body
	MfaUnenrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaUnenroll(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MfaVerifyWithBody request with any body
	MfaVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MfaVerify(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthClientProviderCallback request
	OauthClientProviderCallback(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthClientListProviders request
	OauthClientListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthClientProviderAuth request
	OauthClientProviderAuth(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysList request
	PasskeysList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysLoginBegin request
	PasskeysLoginBegin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysLoginCompleteWithBody request with any body
	PasskeysLoginCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysLoginComplete(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysRegisterBeginWithBody request with any body
	PasskeysRegisterBeginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysRegisterBegin(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysRegisterCompleteWithBody request with any body
	PasskeysRegisterCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysRegisterComplete(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysDelete request
	PasskeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeysUpdateWithBody request with any body
	PasskeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeysUpdate(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessEmailWithBody request with any body
	PasswordlessEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessEmail(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessMagicLinkWithBody request with any body
	PasswordlessMagicLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessMagicLink(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessMethods request
	PasswordlessMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessSmsWithBody request with any body
	PasswordlessSmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessSms(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordlessVerifyWithBody request with any body
	PasswordlessVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordlessVerify(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRefreshTokenWithBody request with any body
	AuthRefreshTokenWithBody(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthRefreshToken(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRegisterWithBody request with any body
	AuthRegisterWithBody(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthRegister(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthResetPasswordWithBody request with any body
	AuthResetPasswordWithBody(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthResetPassword(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthSendEmailVerificationWithBody request with any body
	AuthSendEmailVerificationWithBody(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthSendEmailVerification(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoProviderCallback request
	SsoProviderCallback(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoListIdentityProviders request
	SsoListIdentityProviders(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoCreateIdentityProviderWithBody request with any body
	SsoCreateIdentityProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SsoCreateIdentityProvider(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoDeleteIdentityProvider request
	SsoDeleteIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoGetIdentityProvider request
	SsoGetIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoUpdateIdentityProviderWithBody request with any body
	SsoUpdateIdentityProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SsoUpdateIdentityProvider(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoListProviders request
	SsoListProviders(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoProviderAuth request
	SsoProviderAuth(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoSamlAcs request
	SsoSamlAcs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SsoSamlMetadata request
	SsoSamlMetadata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthVerifyEmailWithBody request with any body
	AuthVerifyEmailWithBody(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthVerifyEmail(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailSendWithBody request with any body
	EmailSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailSend(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailSendTemplateWithBody request with any body
	EmailSendTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailSendTemplate(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailListTemplates request
	EmailListTemplates(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailCreateTemplateWithBody request with any body
	EmailCreateTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailCreateTemplate(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailGetTemplateByType request
	EmailGetTemplateByType(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailDeleteTemplate request
	EmailDeleteTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailGetTemplate request
	EmailGetTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailUpdateTemplateWithBody request with any body
	EmailUpdateTemplateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailUpdateTemplate(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderJwks request
	OauthProviderJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderOidcConfiguration request
	OauthProviderOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderAuthorize request
	OauthProviderAuthorize(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderListClients request
	OauthProviderListClients(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderCreateClientWithBody request with any body
	OauthProviderCreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderCreateClient(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderDeleteClient request
	OauthProviderDeleteClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderGetClient request
	OauthProviderGetClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderUpdateClientWithBody request with any body
	OauthProviderUpdateClientWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderUpdateClient(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderRotateClientSecret request
	OauthProviderRotateClientSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderConsentWithBody request with any body
	OauthProviderConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderConsent(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderIntrospect request
	OauthProviderIntrospect(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderRevoke request
	OauthProviderRevoke(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderListScopes request
	OauthProviderListScopes(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderCreateScopeWithBody request with any body
	OauthProviderCreateScopeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderCreateScope(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderDeleteScope request
	OauthProviderDeleteScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderGetScope request
	OauthProviderGetScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderUpdateScopeWithBody request with any body
	OauthProviderUpdateScopeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthProviderUpdateScope(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderToken request
	OauthProviderToken(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthProviderUserinfo request
	OauthProviderUserinfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsList request
	OrganizationsList(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsCreateWithBody request with any body
	OrganizationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsCreate(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsDelete request
	OrganizationsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsGet request
	OrganizationsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsUpdateWithBody request with any body
	OrganizationsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsUpdate(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsListFeatures request
	OrganizationsListFeatures(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsEnableFeatureWithBody request with any body
	OrganizationsEnableFeatureWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsEnableFeature(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsDisableFeature request
	OrganizationsDisableFeature(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsListMembers request
	OrganizationsListMembers(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsAddMemberWithBody request with any body
	OrganizationsAddMemberWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsAddMember(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsRemoveMember request
	OrganizationsRemoveMember(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationsUpdateMemberWithBody request with any body
	OrganizationsUpdateMemberWithBody(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrganizationsUpdateMember(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacListPermissions request
	RbacListPermissions(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCreatePermissionWithBody request with any body
	RbacCreatePermissionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacCreatePermission(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacDeletePermission request
	RbacDeletePermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacGetPermission request
	RbacGetPermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacUpdatePermissionWithBody request with any body
	RbacUpdatePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacUpdatePermission(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacListRoles request
	RbacListRoles(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacCreateRoleWithBody request with any body
	RbacCreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacCreateRole(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacDeleteRole request
	RbacDeleteRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacGetRole request
	RbacGetRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacUpdateRoleWithBody request with any body
	RbacUpdateRoleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacUpdateRole(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacListRolePermissions request
	RbacListRolePermissions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacAddRolePermissionWithBody request with any body
	RbacAddRolePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RbacAddRolePermission(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RbacRemoveRolePermission request
	RbacRemoveRolePermission(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersList request
	UsersList(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersCreateWithBody request with any body
	UsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersCreate(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdateMeWithBody request with any body
	UsersUpdateMeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdateMe(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdatePasswordWithBody request with any body
	UsersUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdatePassword(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersGetSessions request
	UsersGetSessions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDeleteSession request
	UsersDeleteSession(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDelete request
	UsersDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersGet request
	UsersGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdateWithBody request with any body
	UsersUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdate(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersGetOrganizations request
	UsersGetOrganizations(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksList request
	WebhooksList(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksCreateWithBody request with any body
	WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksReceive request
	WebhooksReceive(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksTriggerEventWithBody request with any body
	WebhooksTriggerEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksTriggerEvent(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksDelete request
	WebhooksDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksGet request
	WebhooksGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksUpdateWithBody request with any body
	WebhooksUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhooksUpdate(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksListEvents request
	WebhooksListEvents(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhooksReplayEvent request
	WebhooksReplayEvent(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthDebug(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthDebugRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCheckPermission(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCheckPermissionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCheckRole(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCheckRoleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysList(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysCreate(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysValidate(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysValidateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiKeysUpdate(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiKeysUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthCheckEmailVerification(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthCheckEmailVerificationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthCsrf(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthCsrfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthForgotPasswordWithBody(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthForgotPasswordRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthForgotPassword(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthForgotPasswordRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginWithBody(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogin(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogout(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthMe(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthMeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaEnrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaEnrollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaEnroll(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaEnrollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaMethodsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaSendCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaSendCodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaSendCode(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaSendCodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaUnenrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaUnenrollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaUnenroll(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaUnenrollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaVerifyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MfaVerify(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMfaVerifyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthClientProviderCallback(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthClientProviderCallbackRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthClientListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthClientListProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthClientProviderAuth(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthClientProviderAuthRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysLoginBegin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysLoginBeginRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysLoginCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysLoginCompleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysLoginComplete(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysLoginCompleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterBeginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterBeginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterBegin(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterBeginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterCompleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterCompleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysRegisterComplete(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysRegisterCompleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeysUpdate(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeysUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessEmail(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessMagicLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessMagicLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessMagicLink(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessMagicLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessMethodsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessSmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessSmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessSms(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessSmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessVerifyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordlessVerify(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordlessVerifyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRefreshTokenWithBody(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRefreshTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRefreshToken(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRefreshTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegisterWithBody(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegisterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegister(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegisterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthResetPasswordWithBody(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthResetPasswordRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthResetPassword(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthResetPasswordRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthSendEmailVerificationWithBody(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthSendEmailVerificationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthSendEmailVerification(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthSendEmailVerificationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoProviderCallback(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoProviderCallbackRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoListIdentityProviders(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoListIdentityProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoCreateIdentityProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoCreateIdentityProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoCreateIdentityProvider(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoCreateIdentityProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoDeleteIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoDeleteIdentityProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoGetIdentityProvider(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoGetIdentityProviderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoUpdateIdentityProviderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoUpdateIdentityProviderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoUpdateIdentityProvider(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoUpdateIdentityProviderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoListProviders(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoListProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoProviderAuth(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoProviderAuthRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoSamlAcs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoSamlAcsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SsoSamlMetadata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSsoSamlMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthVerifyEmailWithBody(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthVerifyEmailRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthVerifyEmail(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthVerifyEmailRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSend(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSendTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailSendTemplate(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailSendTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailListTemplates(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailListTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailCreateTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailCreateTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailCreateTemplate(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailCreateTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailGetTemplateByType(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailGetTemplateByTypeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailDeleteTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailDeleteTemplateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailGetTemplate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailGetTemplateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailUpdateTemplateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailUpdateTemplateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailUpdateTemplate(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailUpdateTemplateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderJwksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderOidcConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderAuthorize(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderListClients(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderListClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateClient(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderDeleteClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderDeleteClientRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderGetClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderGetClientRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateClientWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateClientRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateClient(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateClientRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderRotateClientSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderRotateClientSecretRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderConsent(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderIntrospect(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderIntrospectRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderRevoke(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderRevokeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderListScopes(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderListScopesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateScopeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateScopeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderCreateScope(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderCreateScopeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderDeleteScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderDeleteScopeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderGetScope(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderGetScopeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateScopeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateScopeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUpdateScope(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUpdateScopeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderToken(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthProviderUserinfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthProviderUserinfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsList(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsCreate(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdate(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsListFeatures(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsListFeaturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsEnableFeatureWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsEnableFeatureRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsEnableFeature(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsEnableFeatureRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsDisableFeature(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsDisableFeatureRequest(c.Server, id, featureKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsListMembers(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsListMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsAddMemberWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsAddMemberRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsAddMember(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsAddMemberRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsRemoveMember(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsRemoveMemberRequest(c.Server, id, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdateMemberWithBody(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateMemberRequestWithBody(c.Server, id, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationsUpdateMember(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationsUpdateMemberRequest(c.Server, id, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacListPermissions(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacListPermissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreatePermissionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreatePermissionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreatePermission(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreatePermissionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacDeletePermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacDeletePermissionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacGetPermission(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacGetPermissionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdatePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdatePermissionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdatePermission(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdatePermissionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacListRoles(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacListRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreateRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacCreateRole(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacCreateRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacDeleteRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacDeleteRoleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacGetRole(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacGetRoleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdateRoleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdateRoleRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacUpdateRole(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacUpdateRoleRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacListRolePermissions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacListRolePermissionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacAddRolePermissionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacAddRolePermissionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacAddRolePermission(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacAddRolePermissionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RbacRemoveRolePermission(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRbacRemoveRolePermissionRequest(c.Server, id, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersList(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreate(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateMeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateMeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateMe(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateMeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePassword(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGetSessions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersGetSessionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDeleteSession(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDeleteSessionRequest(c.Server, sessionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdate(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGetOrganizations(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersGetOrganizationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksList(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksCreate(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksReceive(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksReceiveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksTriggerEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksTriggerEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksTriggerEvent(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksTriggerEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksUpdate(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksListEvents(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksListEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhooksReplayEvent(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhooksReplayEventRequest(c.Server, id, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthDebugRequest generates requests for HealthDebug
func NewHealthDebugRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__debug")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthMetricsRequest generates requests for HealthMetrics
func NewHealthMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthReadyRequest generates requests for HealthReady
func NewHealthReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthVersionRequest generates requests for HealthVersion
func NewHealthVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/__version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCheckPermissionRequest generates requests for RbacCheckPermission
func NewRbacCheckPermissionRequest(server string, params *RbacCheckPermissionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/access/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCheckRoleRequest generates requests for RbacCheckRole
func NewRbacCheckRoleRequest(server string, params *RbacCheckRoleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/access/check-role")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysListRequest generates requests for ApiKeysList
func NewApiKeysListRequest(server string, params *ApiKeysListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysCreateRequest calls the generic ApiKeysCreate builder with application/json body
func NewApiKeysCreateRequest(server string, body ApiKeysCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiKeysCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewApiKeysCreateRequestWithBody generates requests for ApiKeysCreate with any type of body
func NewApiKeysCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApiKeysValidateRequest generates requests for ApiKeysValidate
func NewApiKeysValidateRequest(server string, params *ApiKeysValidateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "api_key", runtime.ParamLocationQuery, params.ApiKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysDeleteRequest generates requests for ApiKeysDelete
func NewApiKeysDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysGetRequest generates requests for ApiKeysGet
func NewApiKeysGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiKeysUpdateRequest calls the generic ApiKeysUpdate builder with application/json body
func NewApiKeysUpdateRequest(server string, id string, body ApiKeysUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiKeysUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewApiKeysUpdateRequestWithBody generates requests for ApiKeysUpdate with any type of body
func NewApiKeysUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthCheckEmailVerificationRequest generates requests for AuthCheckEmailVerification
func NewAuthCheckEmailVerificationRequest(server string, params *AuthCheckEmailVerificationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/check-verification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthCsrfRequest generates requests for AuthCsrf
func NewAuthCsrfRequest(server string, params *AuthCsrfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/csrf-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthForgotPasswordRequest calls the generic AuthForgotPassword builder with application/json body
func NewAuthForgotPasswordRequest(server string, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthForgotPasswordRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthForgotPasswordRequestWithBody generates requests for AuthForgotPassword with any type of body
func NewAuthForgotPasswordRequestWithBody(server string, params *AuthForgotPasswordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/forgot-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_url", runtime.ParamLocationQuery, *params.RedirectUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthLoginRequest calls the generic AuthLogin builder with application/json body
func NewAuthLoginRequest(server string, params *AuthLoginParams, body AuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthLoginRequestWithBody generates requests for AuthLogin with any type of body
func NewAuthLoginRequestWithBody(server string, params *AuthLoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthLogoutRequest generates requests for AuthLogout
func NewAuthLogoutRequest(server string, params *AuthLogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthMeRequest generates requests for AuthMe
func NewAuthMeRequest(server string, params *AuthMeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewMfaEnrollRequest calls the generic MfaEnroll builder with application/json body
func NewMfaEnrollRequest(server string, body MfaEnrollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaEnrollRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaEnrollRequestWithBody generates requests for MfaEnroll with any type of body
func NewMfaEnrollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/enroll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMfaMethodsRequest generates requests for MfaMethods
func NewMfaMethodsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMfaSendCodeRequest calls the generic MfaSendCode builder with application/json body
func NewMfaSendCodeRequest(server string, body MfaSendCodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaSendCodeRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaSendCodeRequestWithBody generates requests for MfaSendCode with any type of body
func NewMfaSendCodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/send-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMfaUnenrollRequest calls the generic MfaUnenroll builder with application/json body
func NewMfaUnenrollRequest(server string, body MfaUnenrollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaUnenrollRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaUnenrollRequestWithBody generates requests for MfaUnenroll with any type of body
func NewMfaUnenrollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/unenroll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMfaVerifyRequest calls the generic MfaVerify builder with application/json body
func NewMfaVerifyRequest(server string, body MfaVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMfaVerifyRequestWithBody(server, "application/json", bodyReader)
}

// NewMfaVerifyRequestWithBody generates requests for MfaVerify with any type of body
func NewMfaVerifyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/mfa/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthClientProviderCallbackRequest generates requests for OauthClientProviderCallback
func NewOauthClientProviderCallbackRequest(server string, provider string, params *OauthClientProviderCallbackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/oauth/callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthClientListProvidersRequest generates requests for OauthClientListProviders
func NewOauthClientListProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/oauth/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthClientProviderAuthRequest generates requests for OauthClientProviderAuth
func NewOauthClientProviderAuthRequest(server string, provider string, params *OauthClientProviderAuthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/oauth/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysListRequest generates requests for PasskeysList
func NewPasskeysListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysLoginBeginRequest generates requests for PasskeysLoginBegin
func NewPasskeysLoginBeginRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/login/begin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysLoginCompleteRequest calls the generic PasskeysLoginComplete builder with application/json body
func NewPasskeysLoginCompleteRequest(server string, body PasskeysLoginCompleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysLoginCompleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeysLoginCompleteRequestWithBody generates requests for PasskeysLoginComplete with any type of body
func NewPasskeysLoginCompleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/login/complete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeysRegisterBeginRequest calls the generic PasskeysRegisterBegin builder with application/json body
func NewPasskeysRegisterBeginRequest(server string, body PasskeysRegisterBeginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysRegisterBeginRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeysRegisterBeginRequestWithBody generates requests for PasskeysRegisterBegin with any type of body
func NewPasskeysRegisterBeginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/register/begin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeysRegisterCompleteRequest calls the generic PasskeysRegisterComplete builder with application/json body
func NewPasskeysRegisterCompleteRequest(server string, body PasskeysRegisterCompleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysRegisterCompleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeysRegisterCompleteRequestWithBody generates requests for PasskeysRegisterComplete with any type of body
func NewPasskeysRegisterCompleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/register/complete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeysDeleteRequest generates requests for PasskeysDelete
func NewPasskeysDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeysUpdateRequest calls the generic PasskeysUpdate builder with application/json body
func NewPasskeysUpdateRequest(server string, id string, body PasskeysUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeysUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPasskeysUpdateRequestWithBody generates requests for PasskeysUpdate with any type of body
func NewPasskeysUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passkeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessEmailRequest calls the generic PasswordlessEmail builder with application/json body
func NewPasswordlessEmailRequest(server string, body PasswordlessEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessEmailRequestWithBody generates requests for PasswordlessEmail with any type of body
func NewPasswordlessEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessMagicLinkRequest calls the generic PasswordlessMagicLink builder with application/json body
func NewPasswordlessMagicLinkRequest(server string, body PasswordlessMagicLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessMagicLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessMagicLinkRequestWithBody generates requests for PasswordlessMagicLink with any type of body
func NewPasswordlessMagicLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/magic-link")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessMethodsRequest generates requests for PasswordlessMethods
func NewPasswordlessMethodsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasswordlessSmsRequest calls the generic PasswordlessSms builder with application/json body
func NewPasswordlessSmsRequest(server string, body PasswordlessSmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessSmsRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessSmsRequestWithBody generates requests for PasswordlessSms with any type of body
func NewPasswordlessSmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/sms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordlessVerifyRequest calls the generic PasswordlessVerify builder with application/json body
func NewPasswordlessVerifyRequest(server string, body PasswordlessVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordlessVerifyRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordlessVerifyRequestWithBody generates requests for PasswordlessVerify with any type of body
func NewPasswordlessVerifyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/passwordless/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthRefreshTokenRequest calls the generic AuthRefreshToken builder with application/json body
func NewAuthRefreshTokenRequest(server string, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthRefreshTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthRefreshTokenRequestWithBody generates requests for AuthRefreshToken with any type of body
func NewAuthRefreshTokenRequestWithBody(server string, params *AuthRefreshTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthRegisterRequest calls the generic AuthRegister builder with application/json body
func NewAuthRegisterRequest(server string, params *AuthRegisterParams, body AuthRegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthRegisterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthRegisterRequestWithBody generates requests for AuthRegister with any type of body
func NewAuthRegisterRequestWithBody(server string, params *AuthRegisterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthResetPasswordRequest calls the generic AuthResetPassword builder with application/json body
func NewAuthResetPasswordRequest(server string, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthResetPasswordRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthResetPasswordRequestWithBody generates requests for AuthResetPassword with any type of body
func NewAuthResetPasswordRequestWithBody(server string, params *AuthResetPasswordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewAuthSendEmailVerificationRequest calls the generic AuthSendEmailVerification builder with application/json body
func NewAuthSendEmailVerificationRequest(server string, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthSendEmailVerificationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthSendEmailVerificationRequestWithBody generates requests for AuthSendEmailVerification with any type of body
func NewAuthSendEmailVerificationRequestWithBody(server string, params *AuthSendEmailVerificationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/send-verification-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_url", runtime.ParamLocationQuery, *params.RedirectUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewSsoProviderCallbackRequest generates requests for SsoProviderCallback
func NewSsoProviderCallbackRequest(server string, provider string, params *SsoProviderCallbackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SAMLResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SAMLResponse", runtime.ParamLocationQuery, *params.SAMLResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelayState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "RelayState", runtime.ParamLocationQuery, *params.RelayState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoListIdentityProvidersRequest generates requests for SsoListIdentityProviders
func NewSsoListIdentityProvidersRequest(server string, params *SsoListIdentityProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, params.OrganizationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoCreateIdentityProviderRequest calls the generic SsoCreateIdentityProvider builder with application/json body
func NewSsoCreateIdentityProviderRequest(server string, body SsoCreateIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSsoCreateIdentityProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewSsoCreateIdentityProviderRequestWithBody generates requests for SsoCreateIdentityProvider with any type of body
func NewSsoCreateIdentityProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSsoDeleteIdentityProviderRequest generates requests for SsoDeleteIdentityProvider
func NewSsoDeleteIdentityProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoGetIdentityProviderRequest generates requests for SsoGetIdentityProvider
func NewSsoGetIdentityProviderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoUpdateIdentityProviderRequest calls the generic SsoUpdateIdentityProvider builder with application/json body
func NewSsoUpdateIdentityProviderRequest(server string, id string, body SsoUpdateIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSsoUpdateIdentityProviderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSsoUpdateIdentityProviderRequestWithBody generates requests for SsoUpdateIdentityProvider with any type of body
func NewSsoUpdateIdentityProviderRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/identity-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSsoListProvidersRequest generates requests for SsoListProviders
func NewSsoListProvidersRequest(server string, params *SsoListProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoProviderAuthRequest generates requests for SsoProviderAuth
func NewSsoProviderAuthRequest(server string, provider string, params *SsoProviderAuthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoSamlAcsRequest generates requests for SsoSamlAcs
func NewSsoSamlAcsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/saml/%s/acs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSsoSamlMetadataRequest generates requests for SsoSamlMetadata
func NewSsoSamlMetadataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/sso/saml/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthVerifyEmailRequest calls the generic AuthVerifyEmail builder with application/json body
func NewAuthVerifyEmailRequest(server string, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthVerifyEmailRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAuthVerifyEmailRequestWithBody generates requests for AuthVerifyEmail with any type of body
func NewAuthVerifyEmailRequestWithBody(server string, params *AuthVerifyEmailParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FrankSid != nil {
			var cookieParam0 string

			cookieParam0, err = runtime.StyleParamWithLocation("simple", true, "frank_sid", runtime.ParamLocationCookie, *params.FrankSid)
			if err != nil {
				return nil, err
			}

			cookie0 := &http.Cookie{
				Name:  "frank_sid",
				Value: cookieParam0,
			}
			req.AddCookie(cookie0)
		}
	}
	return req, nil
}

// NewEmailSendRequest calls the generic EmailSend builder with application/json body
func NewEmailSendRequest(server string, body EmailSendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailSendRequestWithBody(server, "application/json", bodyReader)
}

// NewEmailSendRequestWithBody generates requests for EmailSend with any type of body
func NewEmailSendRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmailSendTemplateRequest calls the generic EmailSendTemplate builder with application/json body
func NewEmailSendTemplateRequest(server string, body EmailSendTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailSendTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewEmailSendTemplateRequestWithBody generates requests for EmailSendTemplate with any type of body
func NewEmailSendTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/send-template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmailListTemplatesRequest generates requests for EmailListTemplates
func NewEmailListTemplatesRequest(server string, params *EmailListTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailCreateTemplateRequest calls the generic EmailCreateTemplate builder with application/json body
func NewEmailCreateTemplateRequest(server string, body EmailCreateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailCreateTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewEmailCreateTemplateRequestWithBody generates requests for EmailCreateTemplate with any type of body
func NewEmailCreateTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmailGetTemplateByTypeRequest generates requests for EmailGetTemplateByType
func NewEmailGetTemplateByTypeRequest(server string, pType string, params *EmailGetTemplateByTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/by-type/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailDeleteTemplateRequest generates requests for EmailDeleteTemplate
func NewEmailDeleteTemplateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailGetTemplateRequest generates requests for EmailGetTemplate
func NewEmailGetTemplateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailUpdateTemplateRequest calls the generic EmailUpdateTemplate builder with application/json body
func NewEmailUpdateTemplateRequest(server string, id string, body EmailUpdateTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailUpdateTemplateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEmailUpdateTemplateRequestWithBody generates requests for EmailUpdateTemplate with any type of body
func NewEmailUpdateTemplateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/email/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderJwksRequest generates requests for OauthProviderJwks
func NewOauthProviderJwksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/.well-known/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderOidcConfigurationRequest generates requests for OauthProviderOidcConfiguration
func NewOauthProviderOidcConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderAuthorizeRequest generates requests for OauthProviderAuthorize
func NewOauthProviderAuthorizeRequest(server string, params *OauthProviderAuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, *params.CodeChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeChallengeMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, *params.CodeChallengeMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderListClientsRequest generates requests for OauthProviderListClients
func NewOauthProviderListClientsRequest(server string, params *OauthProviderListClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderCreateClientRequest calls the generic OauthProviderCreateClient builder with application/json body
func NewOauthProviderCreateClientRequest(server string, body OauthProviderCreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderCreateClientRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthProviderCreateClientRequestWithBody generates requests for OauthProviderCreateClient with any type of body
func NewOauthProviderCreateClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderDeleteClientRequest generates requests for OauthProviderDeleteClient
func NewOauthProviderDeleteClientRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderGetClientRequest generates requests for OauthProviderGetClient
func NewOauthProviderGetClientRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderUpdateClientRequest calls the generic OauthProviderUpdateClient builder with application/json body
func NewOauthProviderUpdateClientRequest(server string, id string, body OauthProviderUpdateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderUpdateClientRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOauthProviderUpdateClientRequestWithBody generates requests for OauthProviderUpdateClient with any type of body
func NewOauthProviderUpdateClientRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderRotateClientSecretRequest generates requests for OauthProviderRotateClientSecret
func NewOauthProviderRotateClientSecretRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/clients/%s/rotate-secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderConsentRequest calls the generic OauthProviderConsent builder with application/json body
func NewOauthProviderConsentRequest(server string, body OauthProviderConsentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthProviderConsentRequestWithBody generates requests for OauthProviderConsent with any type of body
func NewOauthProviderConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderIntrospectRequest generates requests for OauthProviderIntrospect
func NewOauthProviderIntrospectRequest(server string, params *OauthProviderIntrospectParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TokenTypeHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token_type_hint", runtime.ParamLocationQuery, *params.TokenTypeHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderRevokeRequest generates requests for OauthProviderRevoke
func NewOauthProviderRevokeRequest(server string, params *OauthProviderRevokeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TokenTypeHint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token_type_hint", runtime.ParamLocationQuery, *params.TokenTypeHint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientSecret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, *params.ClientSecret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderListScopesRequest generates requests for OauthProviderListScopes
func NewOauthProviderListScopesRequest(server string, params *OauthProviderListScopesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderCreateScopeRequest calls the generic OauthProviderCreateScope builder with application/json body
func NewOauthProviderCreateScopeRequest(server string, body OauthProviderCreateScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderCreateScopeRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthProviderCreateScopeRequestWithBody generates requests for OauthProviderCreateScope with any type of body
func NewOauthProviderCreateScopeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderDeleteScopeRequest generates requests for OauthProviderDeleteScope
func NewOauthProviderDeleteScopeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderGetScopeRequest generates requests for OauthProviderGetScope
func NewOauthProviderGetScopeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderUpdateScopeRequest calls the generic OauthProviderUpdateScope builder with application/json body
func NewOauthProviderUpdateScopeRequest(server string, id string, body OauthProviderUpdateScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthProviderUpdateScopeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOauthProviderUpdateScopeRequestWithBody generates requests for OauthProviderUpdateScope with any type of body
func NewOauthProviderUpdateScopeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/scopes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthProviderTokenRequest generates requests for OauthProviderToken
func NewOauthProviderTokenRequest(server string, params *OauthProviderTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grant_type", runtime.ParamLocationQuery, params.GrantType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientSecret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, *params.ClientSecret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefreshToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh_token", runtime.ParamLocationQuery, *params.RefreshToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CodeVerifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_verifier", runtime.ParamLocationQuery, *params.CodeVerifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthProviderUserinfoRequest generates requests for OauthProviderUserinfo
func NewOauthProviderUserinfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/oauth/userinfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsListRequest generates requests for OrganizationsList
func NewOrganizationsListRequest(server string, params *OrganizationsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsCreateRequest calls the generic OrganizationsCreate builder with application/json body
func NewOrganizationsCreateRequest(server string, body OrganizationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewOrganizationsCreateRequestWithBody generates requests for OrganizationsCreate with any type of body
func NewOrganizationsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsDeleteRequest generates requests for OrganizationsDelete
func NewOrganizationsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsGetRequest generates requests for OrganizationsGet
func NewOrganizationsGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsUpdateRequest calls the generic OrganizationsUpdate builder with application/json body
func NewOrganizationsUpdateRequest(server string, id string, body OrganizationsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOrganizationsUpdateRequestWithBody generates requests for OrganizationsUpdate with any type of body
func NewOrganizationsUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsListFeaturesRequest generates requests for OrganizationsListFeatures
func NewOrganizationsListFeaturesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/features", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsEnableFeatureRequest calls the generic OrganizationsEnableFeature builder with application/json body
func NewOrganizationsEnableFeatureRequest(server string, id string, body OrganizationsEnableFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsEnableFeatureRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOrganizationsEnableFeatureRequestWithBody generates requests for OrganizationsEnableFeature with any type of body
func NewOrganizationsEnableFeatureRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/features", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsDisableFeatureRequest generates requests for OrganizationsDisableFeature
func NewOrganizationsDisableFeatureRequest(server string, id string, featureKey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature_key", runtime.ParamLocationPath, featureKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/features/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsListMembersRequest generates requests for OrganizationsListMembers
func NewOrganizationsListMembersRequest(server string, id string, params *OrganizationsListMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsAddMemberRequest calls the generic OrganizationsAddMember builder with application/json body
func NewOrganizationsAddMemberRequest(server string, id string, body OrganizationsAddMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsAddMemberRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOrganizationsAddMemberRequestWithBody generates requests for OrganizationsAddMember with any type of body
func NewOrganizationsAddMemberRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrganizationsRemoveMemberRequest generates requests for OrganizationsRemoveMember
func NewOrganizationsRemoveMemberRequest(server string, id string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationsUpdateMemberRequest calls the generic OrganizationsUpdateMember builder with application/json body
func NewOrganizationsUpdateMemberRequest(server string, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrganizationsUpdateMemberRequestWithBody(server, id, userId, "application/json", bodyReader)
}

// NewOrganizationsUpdateMemberRequestWithBody generates requests for OrganizationsUpdateMember with any type of body
func NewOrganizationsUpdateMemberRequestWithBody(server string, id string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/organizations/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacListPermissionsRequest generates requests for RbacListPermissions
func NewRbacListPermissionsRequest(server string, params *RbacListPermissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCreatePermissionRequest calls the generic RbacCreatePermission builder with application/json body
func NewRbacCreatePermissionRequest(server string, body RbacCreatePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacCreatePermissionRequestWithBody(server, "application/json", bodyReader)
}

// NewRbacCreatePermissionRequestWithBody generates requests for RbacCreatePermission with any type of body
func NewRbacCreatePermissionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacDeletePermissionRequest generates requests for RbacDeletePermission
func NewRbacDeletePermissionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacGetPermissionRequest generates requests for RbacGetPermission
func NewRbacGetPermissionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacUpdatePermissionRequest calls the generic RbacUpdatePermission builder with application/json body
func NewRbacUpdatePermissionRequest(server string, id string, body RbacUpdatePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacUpdatePermissionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRbacUpdatePermissionRequestWithBody generates requests for RbacUpdatePermission with any type of body
func NewRbacUpdatePermissionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacListRolesRequest generates requests for RbacListRoles
func NewRbacListRolesRequest(server string, params *RbacListRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacCreateRoleRequest calls the generic RbacCreateRole builder with application/json body
func NewRbacCreateRoleRequest(server string, body RbacCreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacCreateRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewRbacCreateRoleRequestWithBody generates requests for RbacCreateRole with any type of body
func NewRbacCreateRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacDeleteRoleRequest generates requests for RbacDeleteRole
func NewRbacDeleteRoleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacGetRoleRequest generates requests for RbacGetRole
func NewRbacGetRoleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacUpdateRoleRequest calls the generic RbacUpdateRole builder with application/json body
func NewRbacUpdateRoleRequest(server string, id string, body RbacUpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacUpdateRoleRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRbacUpdateRoleRequestWithBody generates requests for RbacUpdateRole with any type of body
func NewRbacUpdateRoleRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacListRolePermissionsRequest generates requests for RbacListRolePermissions
func NewRbacListRolePermissionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRbacAddRolePermissionRequest calls the generic RbacAddRolePermission builder with application/json body
func NewRbacAddRolePermissionRequest(server string, id string, body RbacAddRolePermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRbacAddRolePermissionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRbacAddRolePermissionRequestWithBody generates requests for RbacAddRolePermission with any type of body
func NewRbacAddRolePermissionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRbacRemoveRolePermissionRequest generates requests for RbacRemoveRolePermission
func NewRbacRemoveRolePermissionRequest(server string, id string, permissionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/roles/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersListRequest generates requests for UsersList
func NewUsersListRequest(server string, params *UsersListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersCreateRequest calls the generic UsersCreate builder with application/json body
func NewUsersCreateRequest(server string, body UsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersCreateRequestWithBody generates requests for UsersCreate with any type of body
func NewUsersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersUpdateMeRequest calls the generic UsersUpdateMe builder with application/json body
func NewUsersUpdateMeRequest(server string, body UsersUpdateMeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdateMeRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersUpdateMeRequestWithBody generates requests for UsersUpdateMe with any type of body
func NewUsersUpdateMeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersUpdatePasswordRequest calls the generic UsersUpdatePassword builder with application/json body
func NewUsersUpdatePasswordRequest(server string, body UsersUpdatePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdatePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersUpdatePasswordRequestWithBody generates requests for UsersUpdatePassword with any type of body
func NewUsersUpdatePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersGetSessionsRequest generates requests for UsersGetSessions
func NewUsersGetSessionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersDeleteSessionRequest generates requests for UsersDeleteSession
func NewUsersDeleteSessionRequest(server string, sessionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/me/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersDeleteRequest generates requests for UsersDelete
func NewUsersDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersGetRequest generates requests for UsersGet
func NewUsersGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersUpdateRequest calls the generic UsersUpdate builder with application/json body
func NewUsersUpdateRequest(server string, id string, body UsersUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersUpdateRequestWithBody generates requests for UsersUpdate with any type of body
func NewUsersUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersGetOrganizationsRequest generates requests for UsersGetOrganizations
func NewUsersGetOrganizationsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/%s/organizations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksListRequest generates requests for WebhooksList
func NewWebhooksListRequest(server string, params *WebhooksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization_id", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_types", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksCreateRequest calls the generic WebhooksCreate builder with application/json body
func NewWebhooksCreateRequest(server string, body WebhooksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksCreateRequestWithBody generates requests for WebhooksCreate with any type of body
func NewWebhooksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksReceiveRequest generates requests for WebhooksReceive
func NewWebhooksReceiveRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/external/receive/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksTriggerEventRequest calls the generic WebhooksTriggerEvent builder with application/json body
func NewWebhooksTriggerEventRequest(server string, body WebhooksTriggerEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksTriggerEventRequestWithBody(server, "application/json", bodyReader)
}

// NewWebhooksTriggerEventRequestWithBody generates requests for WebhooksTriggerEvent with any type of body
func NewWebhooksTriggerEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/trigger")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksDeleteRequest generates requests for WebhooksDelete
func NewWebhooksDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksGetRequest generates requests for WebhooksGet
func NewWebhooksGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksUpdateRequest calls the generic WebhooksUpdate builder with application/json body
func NewWebhooksUpdateRequest(server string, id string, body WebhooksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhooksUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewWebhooksUpdateRequestWithBody generates requests for WebhooksUpdate with any type of body
func NewWebhooksUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebhooksListEventsRequest generates requests for WebhooksListEvents
func NewWebhooksListEventsRequest(server string, id string, params *WebhooksListEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Delivered != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delivered", runtime.ParamLocationQuery, *params.Delivered); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhooksReplayEventRequest generates requests for WebhooksReplayEvent
func NewWebhooksReplayEventRequest(server string, id string, eventId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/webhooks/%s/events/%s/replay", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthDebugWithResponse request
	HealthDebugWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthDebugResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// HealthMetricsWithResponse request
	HealthMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthMetricsResponse, error)

	// HealthReadyWithResponse request
	HealthReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthReadyResponse, error)

	// HealthVersionWithResponse request
	HealthVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthVersionResponse, error)

	// RbacCheckPermissionWithResponse request
	RbacCheckPermissionWithResponse(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*RbacCheckPermissionResponse, error)

	// RbacCheckRoleWithResponse request
	RbacCheckRoleWithResponse(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*RbacCheckRoleResponse, error)

	// ApiKeysListWithResponse request
	ApiKeysListWithResponse(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*ApiKeysListResponse, error)

	// ApiKeysCreateWithBodyWithResponse request with any body
	ApiKeysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error)

	ApiKeysCreateWithResponse(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error)

	// ApiKeysValidateWithResponse request
	ApiKeysValidateWithResponse(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*ApiKeysValidateResponse, error)

	// ApiKeysDeleteWithResponse request
	ApiKeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysDeleteResponse, error)

	// ApiKeysGetWithResponse request
	ApiKeysGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysGetResponse, error)

	// ApiKeysUpdateWithBodyWithResponse request with any body
	ApiKeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error)

	ApiKeysUpdateWithResponse(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error)

	// AuthCheckEmailVerificationWithResponse request
	AuthCheckEmailVerificationWithResponse(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*AuthCheckEmailVerificationResponse, error)

	// AuthCsrfWithResponse request
	AuthCsrfWithResponse(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*AuthCsrfResponse, error)

	// AuthForgotPasswordWithBodyWithResponse request with any body
	AuthForgotPasswordWithBodyWithResponse(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error)

	AuthForgotPasswordWithResponse(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error)

	// AuthLoginWithBodyWithResponse request with any body
	AuthLoginWithBodyWithResponse(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	AuthLoginWithResponse(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	// AuthLogoutWithResponse request
	AuthLogoutWithResponse(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error)

	// AuthMeWithResponse request
	AuthMeWithResponse(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*AuthMeResponse, error)

	// MfaEnrollWithBodyWithResponse request with any body
	MfaEnrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error)

	MfaEnrollWithResponse(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error)

	// MfaMethodsWithResponse request
	MfaMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MfaMethodsResponse, error)

	// MfaSendCodeWithBodyWithResponse request with any body
	MfaSendCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error)

	MfaSendCodeWithResponse(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error)

	// MfaUnenrollWithBodyWithResponse request with any body
	MfaUnenrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error)

	MfaUnenrollWithResponse(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error)

	// MfaVerifyWithBodyWithResponse request with any body
	MfaVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error)

	MfaVerifyWithResponse(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error)

	// OauthClientProviderCallbackWithResponse request
	OauthClientProviderCallbackWithResponse(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*OauthClientProviderCallbackResponse, error)

	// OauthClientListProvidersWithResponse request
	OauthClientListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthClientListProvidersResponse, error)

	// OauthClientProviderAuthWithResponse request
	OauthClientProviderAuthWithResponse(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*OauthClientProviderAuthResponse, error)

	// PasskeysListWithResponse request
	PasskeysListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysListResponse, error)

	// PasskeysLoginBeginWithResponse request
	PasskeysLoginBeginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysLoginBeginResponse, error)

	// PasskeysLoginCompleteWithBodyWithResponse request with any body
	PasskeysLoginCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error)

	PasskeysLoginCompleteWithResponse(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error)

	// PasskeysRegisterBeginWithBodyWithResponse request with any body
	PasskeysRegisterBeginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error)

	PasskeysRegisterBeginWithResponse(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error)

	// PasskeysRegisterCompleteWithBodyWithResponse request with any body
	PasskeysRegisterCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error)

	PasskeysRegisterCompleteWithResponse(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error)

	// PasskeysDeleteWithResponse request
	PasskeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PasskeysDeleteResponse, error)

	// PasskeysUpdateWithBodyWithResponse request with any body
	PasskeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error)

	PasskeysUpdateWithResponse(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error)

	// PasswordlessEmailWithBodyWithResponse request with any body
	PasswordlessEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error)

	PasswordlessEmailWithResponse(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error)

	// PasswordlessMagicLinkWithBodyWithResponse request with any body
	PasswordlessMagicLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error)

	PasswordlessMagicLinkWithResponse(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error)

	// PasswordlessMethodsWithResponse request
	PasswordlessMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasswordlessMethodsResponse, error)

	// PasswordlessSmsWithBodyWithResponse request with any body
	PasswordlessSmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error)

	PasswordlessSmsWithResponse(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error)

	// PasswordlessVerifyWithBodyWithResponse request with any body
	PasswordlessVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error)

	PasswordlessVerifyWithResponse(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error)

	// AuthRefreshTokenWithBodyWithResponse request with any body
	AuthRefreshTokenWithBodyWithResponse(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error)

	AuthRefreshTokenWithResponse(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error)

	// AuthRegisterWithBodyWithResponse request with any body
	AuthRegisterWithBodyWithResponse(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error)

	AuthRegisterWithResponse(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error)

	// AuthResetPasswordWithBodyWithResponse request with any body
	AuthResetPasswordWithBodyWithResponse(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error)

	AuthResetPasswordWithResponse(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error)

	// AuthSendEmailVerificationWithBodyWithResponse request with any body
	AuthSendEmailVerificationWithBodyWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error)

	AuthSendEmailVerificationWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error)

	// SsoProviderCallbackWithResponse request
	SsoProviderCallbackWithResponse(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*SsoProviderCallbackResponse, error)

	// SsoListIdentityProvidersWithResponse request
	SsoListIdentityProvidersWithResponse(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*SsoListIdentityProvidersResponse, error)

	// SsoCreateIdentityProviderWithBodyWithResponse request with any body
	SsoCreateIdentityProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error)

	SsoCreateIdentityProviderWithResponse(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error)

	// SsoDeleteIdentityProviderWithResponse request
	SsoDeleteIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoDeleteIdentityProviderResponse, error)

	// SsoGetIdentityProviderWithResponse request
	SsoGetIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoGetIdentityProviderResponse, error)

	// SsoUpdateIdentityProviderWithBodyWithResponse request with any body
	SsoUpdateIdentityProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error)

	SsoUpdateIdentityProviderWithResponse(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error)

	// SsoListProvidersWithResponse request
	SsoListProvidersWithResponse(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*SsoListProvidersResponse, error)

	// SsoProviderAuthWithResponse request
	SsoProviderAuthWithResponse(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*SsoProviderAuthResponse, error)

	// SsoSamlAcsWithResponse request
	SsoSamlAcsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlAcsResponse, error)

	// SsoSamlMetadataWithResponse request
	SsoSamlMetadataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlMetadataResponse, error)

	// AuthVerifyEmailWithBodyWithResponse request with any body
	AuthVerifyEmailWithBodyWithResponse(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error)

	AuthVerifyEmailWithResponse(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error)

	// EmailSendWithBodyWithResponse request with any body
	EmailSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendResponse, error)

	EmailSendWithResponse(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendResponse, error)

	// EmailSendTemplateWithBodyWithResponse request with any body
	EmailSendTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error)

	EmailSendTemplateWithResponse(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error)

	// EmailListTemplatesWithResponse request
	EmailListTemplatesWithResponse(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*EmailListTemplatesResponse, error)

	// EmailCreateTemplateWithBodyWithResponse request with any body
	EmailCreateTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error)

	EmailCreateTemplateWithResponse(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error)

	// EmailGetTemplateByTypeWithResponse request
	EmailGetTemplateByTypeWithResponse(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*EmailGetTemplateByTypeResponse, error)

	// EmailDeleteTemplateWithResponse request
	EmailDeleteTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailDeleteTemplateResponse, error)

	// EmailGetTemplateWithResponse request
	EmailGetTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailGetTemplateResponse, error)

	// EmailUpdateTemplateWithBodyWithResponse request with any body
	EmailUpdateTemplateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error)

	EmailUpdateTemplateWithResponse(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error)

	// OauthProviderJwksWithResponse request
	OauthProviderJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderJwksResponse, error)

	// OauthProviderOidcConfigurationWithResponse request
	OauthProviderOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderOidcConfigurationResponse, error)

	// OauthProviderAuthorizeWithResponse request
	OauthProviderAuthorizeWithResponse(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*OauthProviderAuthorizeResponse, error)

	// OauthProviderListClientsWithResponse request
	OauthProviderListClientsWithResponse(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*OauthProviderListClientsResponse, error)

	// OauthProviderCreateClientWithBodyWithResponse request with any body
	OauthProviderCreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error)

	OauthProviderCreateClientWithResponse(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error)

	// OauthProviderDeleteClientWithResponse request
	OauthProviderDeleteClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteClientResponse, error)

	// OauthProviderGetClientWithResponse request
	OauthProviderGetClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetClientResponse, error)

	// OauthProviderUpdateClientWithBodyWithResponse request with any body
	OauthProviderUpdateClientWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error)

	OauthProviderUpdateClientWithResponse(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error)

	// OauthProviderRotateClientSecretWithResponse request
	OauthProviderRotateClientSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderRotateClientSecretResponse, error)

	// OauthProviderConsentWithBodyWithResponse request with any body
	OauthProviderConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error)

	OauthProviderConsentWithResponse(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error)

	// OauthProviderIntrospectWithResponse request
	OauthProviderIntrospectWithResponse(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*OauthProviderIntrospectResponse, error)

	// OauthProviderRevokeWithResponse request
	OauthProviderRevokeWithResponse(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*OauthProviderRevokeResponse, error)

	// OauthProviderListScopesWithResponse request
	OauthProviderListScopesWithResponse(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*OauthProviderListScopesResponse, error)

	// OauthProviderCreateScopeWithBodyWithResponse request with any body
	OauthProviderCreateScopeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error)

	OauthProviderCreateScopeWithResponse(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error)

	// OauthProviderDeleteScopeWithResponse request
	OauthProviderDeleteScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteScopeResponse, error)

	// OauthProviderGetScopeWithResponse request
	OauthProviderGetScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetScopeResponse, error)

	// OauthProviderUpdateScopeWithBodyWithResponse request with any body
	OauthProviderUpdateScopeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error)

	OauthProviderUpdateScopeWithResponse(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error)

	// OauthProviderTokenWithResponse request
	OauthProviderTokenWithResponse(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*OauthProviderTokenResponse, error)

	// OauthProviderUserinfoWithResponse request
	OauthProviderUserinfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderUserinfoResponse, error)

	// OrganizationsListWithResponse request
	OrganizationsListWithResponse(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*OrganizationsListResponse, error)

	// OrganizationsCreateWithBodyWithResponse request with any body
	OrganizationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error)

	OrganizationsCreateWithResponse(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error)

	// OrganizationsDeleteWithResponse request
	OrganizationsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsDeleteResponse, error)

	// OrganizationsGetWithResponse request
	OrganizationsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsGetResponse, error)

	// OrganizationsUpdateWithBodyWithResponse request with any body
	OrganizationsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error)

	OrganizationsUpdateWithResponse(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error)

	// OrganizationsListFeaturesWithResponse request
	OrganizationsListFeaturesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsListFeaturesResponse, error)

	// OrganizationsEnableFeatureWithBodyWithResponse request with any body
	OrganizationsEnableFeatureWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error)

	OrganizationsEnableFeatureWithResponse(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error)

	// OrganizationsDisableFeatureWithResponse request
	OrganizationsDisableFeatureWithResponse(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*OrganizationsDisableFeatureResponse, error)

	// OrganizationsListMembersWithResponse request
	OrganizationsListMembersWithResponse(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*OrganizationsListMembersResponse, error)

	// OrganizationsAddMemberWithBodyWithResponse request with any body
	OrganizationsAddMemberWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error)

	OrganizationsAddMemberWithResponse(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error)

	// OrganizationsRemoveMemberWithResponse request
	OrganizationsRemoveMemberWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*OrganizationsRemoveMemberResponse, error)

	// OrganizationsUpdateMemberWithBodyWithResponse request with any body
	OrganizationsUpdateMemberWithBodyWithResponse(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error)

	OrganizationsUpdateMemberWithResponse(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error)

	// RbacListPermissionsWithResponse request
	RbacListPermissionsWithResponse(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*RbacListPermissionsResponse, error)

	// RbacCreatePermissionWithBodyWithResponse request with any body
	RbacCreatePermissionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error)

	RbacCreatePermissionWithResponse(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error)

	// RbacDeletePermissionWithResponse request
	RbacDeletePermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeletePermissionResponse, error)

	// RbacGetPermissionWithResponse request
	RbacGetPermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetPermissionResponse, error)

	// RbacUpdatePermissionWithBodyWithResponse request with any body
	RbacUpdatePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error)

	RbacUpdatePermissionWithResponse(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error)

	// RbacListRolesWithResponse request
	RbacListRolesWithResponse(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*RbacListRolesResponse, error)

	// RbacCreateRoleWithBodyWithResponse request with any body
	RbacCreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error)

	RbacCreateRoleWithResponse(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error)

	// RbacDeleteRoleWithResponse request
	RbacDeleteRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeleteRoleResponse, error)

	// RbacGetRoleWithResponse request
	RbacGetRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetRoleResponse, error)

	// RbacUpdateRoleWithBodyWithResponse request with any body
	RbacUpdateRoleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error)

	RbacUpdateRoleWithResponse(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error)

	// RbacListRolePermissionsWithResponse request
	RbacListRolePermissionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacListRolePermissionsResponse, error)

	// RbacAddRolePermissionWithBodyWithResponse request with any body
	RbacAddRolePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error)

	RbacAddRolePermissionWithResponse(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error)

	// RbacRemoveRolePermissionWithResponse request
	RbacRemoveRolePermissionWithResponse(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*RbacRemoveRolePermissionResponse, error)

	// UsersListWithResponse request
	UsersListWithResponse(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*UsersListResponse, error)

	// UsersCreateWithBodyWithResponse request with any body
	UsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	UsersCreateWithResponse(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	// UsersUpdateMeWithBodyWithResponse request with any body
	UsersUpdateMeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error)

	UsersUpdateMeWithResponse(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error)

	// UsersUpdatePasswordWithBodyWithResponse request with any body
	UsersUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error)

	UsersUpdatePasswordWithResponse(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error)

	// UsersGetSessionsWithResponse request
	UsersGetSessionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsersGetSessionsResponse, error)

	// UsersDeleteSessionWithResponse request
	UsersDeleteSessionWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*UsersDeleteSessionResponse, error)

	// UsersDeleteWithResponse request
	UsersDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersDeleteResponse, error)

	// UsersGetWithResponse request
	UsersGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetResponse, error)

	// UsersUpdateWithBodyWithResponse request with any body
	UsersUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error)

	UsersUpdateWithResponse(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error)

	// UsersGetOrganizationsWithResponse request
	UsersGetOrganizationsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetOrganizationsResponse, error)

	// WebhooksListWithResponse request
	WebhooksListWithResponse(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error)

	// WebhooksCreateWithBodyWithResponse request with any body
	WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error)

	// WebhooksReceiveWithResponse request
	WebhooksReceiveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksReceiveResponse, error)

	// WebhooksTriggerEventWithBodyWithResponse request with any body
	WebhooksTriggerEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error)

	WebhooksTriggerEventWithResponse(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error)

	// WebhooksDeleteWithResponse request
	WebhooksDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error)

	// WebhooksGetWithResponse request
	WebhooksGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error)

	// WebhooksUpdateWithBodyWithResponse request with any body
	WebhooksUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	WebhooksUpdateWithResponse(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error)

	// WebhooksListEventsWithResponse request
	WebhooksListEventsWithResponse(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*WebhooksListEventsResponse, error)

	// WebhooksReplayEventWithResponse request
	WebhooksReplayEventWithResponse(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*WebhooksReplayEventResponse, error)
}

type HealthDebugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r HealthDebugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthDebugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
	JSON503      *HealthResponse
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsResponseBody
}

// Status returns HTTPResponse.Status
func (r HealthMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadyResponse
	JSON503      *ReadyResponse
}

// Status returns HTTPResponse.Status
func (r HealthReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionResponseBody
}

// Status returns HTTPResponse.Status
func (r HealthVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCheckPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckPermissionResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCheckPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCheckPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCheckRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckRoleResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCheckRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCheckRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *APIKeyWithSecretResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKeyResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiKeysUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKeyResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ApiKeysUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiKeysUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthCheckEmailVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthCheckEmailVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthCheckEmailVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthCsrfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CSRFTokenResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthCsrfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthCsrfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthForgotPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthForgotPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthForgotPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse2
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaEnrollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrollResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaEnrollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaEnrollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MethodsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaSendCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaSendCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaSendCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaUnenrollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaUnenrollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaUnenrollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MfaVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MfaVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MfaVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthClientProviderCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProviderCallbackResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthClientProviderCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthClientProviderCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthClientListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProvidersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthClientListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthClientListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthClientProviderAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthClientProviderAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthClientProviderAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody3
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysLoginBeginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisterBeginResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysLoginBeginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysLoginBeginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysLoginCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginCompleteResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysLoginCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysLoginCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysRegisterBeginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisterBeginResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysRegisterBeginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysRegisterBeginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysRegisterCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisteredPasskey
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysRegisterCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysRegisterCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeysUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasskeysUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeysUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessMagicLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MagicLinkResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessMagicLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessMagicLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MethodsResponseBody2
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessSmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessSmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessSmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordlessVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PasswordlessVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordlessVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshTokenResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthRefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LoginResponse3
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthRegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthSendEmailVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendEmailVerificationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthSendEmailVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthSendEmailVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoProviderCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProviderCallbackResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoProviderCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoProviderCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoListIdentityProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIdentityProvidersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoListIdentityProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoListIdentityProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoCreateIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IdentityProviderResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoCreateIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoCreateIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoDeleteIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoDeleteIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoDeleteIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoGetIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProviderResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoGetIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoGetIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoUpdateIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProviderResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoUpdateIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoUpdateIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProvidersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoProviderAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoProviderAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoProviderAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoSamlAcsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoSamlAcsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoSamlAcsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SsoSamlMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *SamlMetadataResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SsoSamlMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SsoSamlMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthVerifyEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AuthVerifyEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthVerifyEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailSendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailSendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailSendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailSendTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailSendTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailSendTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTemplatesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailCreateTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailCreateTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailCreateTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailGetTemplateByTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailGetTemplateByTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailGetTemplateByTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailDeleteTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailDeleteTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailDeleteTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailGetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailGetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailGetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailUpdateTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmailTemplateResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EmailUpdateTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailUpdateTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JwksResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderOidcConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcConfigurationResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderOidcConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderOidcConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderAuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderAuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderAuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderListClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListClientsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderListClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderListClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderCreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OAuthClientWithSecretResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderCreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderCreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderDeleteClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderDeleteClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderDeleteClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderGetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthClientResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderGetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderGetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderUpdateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthClientResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderUpdateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderUpdateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderRotateClientSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RotateClientSecretResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderRotateClientSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderRotateClientSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON307      *ConsentResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderIntrospectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntrospectResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderIntrospectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderIntrospectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderListScopesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListScopesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderListScopesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderListScopesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderCreateScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OAuthScopeResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderCreateScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderCreateScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderDeleteScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderDeleteScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderDeleteScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderGetScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthScopeResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderGetScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderGetScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderUpdateScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthScopeResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderUpdateScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderUpdateScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthProviderUserinfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserinfoResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OauthProviderUserinfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthProviderUserinfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody2
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Organization
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsListFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFeaturesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsListFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsListFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsEnableFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsEnableFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsEnableFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsDisableFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsDisableFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsDisableFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsListMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMembersResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsListMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsListMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsAddMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsAddMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsAddMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsRemoveMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsRemoveMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsRemoveMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationsUpdateMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OrganizationsUpdateMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationsUpdateMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacListPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPermissionsResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacListPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacListPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCreatePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PermissionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCreatePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCreatePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacDeletePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacDeletePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacDeletePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacGetPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacGetPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacGetPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacUpdatePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacUpdatePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacUpdatePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRolesResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacCreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RoleResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacCreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacCreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacDeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacDeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacDeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacGetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacGetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacGetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacUpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacUpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacUpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacListRolePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRolePermissionsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacListRolePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacListRolePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacAddRolePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacAddRolePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacAddRolePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RbacRemoveRolePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RbacRemoveRolePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RbacRemoveRolePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody4
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdateMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersUpdateMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdateMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdatePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersUpdatePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdatePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserSessionResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersGetSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersDeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOrganizationsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON409      *ConflictError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UsersGetOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponseBody5
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookSecretResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksReceiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksReceiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksReceiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksTriggerEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEventResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksTriggerEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksTriggerEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEventsResponseBody
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhooksReplayEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEventResponse
	JSON400      *BadRequestError
	JSON401      *UnauthorizedError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r WebhooksReplayEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhooksReplayEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthDebugWithResponse request returning *HealthDebugResponse
func (c *ClientWithResponses) HealthDebugWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthDebugResponse, error) {
	rsp, err := c.HealthDebug(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthDebugResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// HealthMetricsWithResponse request returning *HealthMetricsResponse
func (c *ClientWithResponses) HealthMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthMetricsResponse, error) {
	rsp, err := c.HealthMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthMetricsResponse(rsp)
}

// HealthReadyWithResponse request returning *HealthReadyResponse
func (c *ClientWithResponses) HealthReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthReadyResponse, error) {
	rsp, err := c.HealthReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthReadyResponse(rsp)
}

// HealthVersionWithResponse request returning *HealthVersionResponse
func (c *ClientWithResponses) HealthVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthVersionResponse, error) {
	rsp, err := c.HealthVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthVersionResponse(rsp)
}

// RbacCheckPermissionWithResponse request returning *RbacCheckPermissionResponse
func (c *ClientWithResponses) RbacCheckPermissionWithResponse(ctx context.Context, params *RbacCheckPermissionParams, reqEditors ...RequestEditorFn) (*RbacCheckPermissionResponse, error) {
	rsp, err := c.RbacCheckPermission(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCheckPermissionResponse(rsp)
}

// RbacCheckRoleWithResponse request returning *RbacCheckRoleResponse
func (c *ClientWithResponses) RbacCheckRoleWithResponse(ctx context.Context, params *RbacCheckRoleParams, reqEditors ...RequestEditorFn) (*RbacCheckRoleResponse, error) {
	rsp, err := c.RbacCheckRole(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCheckRoleResponse(rsp)
}

// ApiKeysListWithResponse request returning *ApiKeysListResponse
func (c *ClientWithResponses) ApiKeysListWithResponse(ctx context.Context, params *ApiKeysListParams, reqEditors ...RequestEditorFn) (*ApiKeysListResponse, error) {
	rsp, err := c.ApiKeysList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysListResponse(rsp)
}

// ApiKeysCreateWithBodyWithResponse request with arbitrary body returning *ApiKeysCreateResponse
func (c *ClientWithResponses) ApiKeysCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error) {
	rsp, err := c.ApiKeysCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysCreateResponse(rsp)
}

func (c *ClientWithResponses) ApiKeysCreateWithResponse(ctx context.Context, body ApiKeysCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysCreateResponse, error) {
	rsp, err := c.ApiKeysCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysCreateResponse(rsp)
}

// ApiKeysValidateWithResponse request returning *ApiKeysValidateResponse
func (c *ClientWithResponses) ApiKeysValidateWithResponse(ctx context.Context, params *ApiKeysValidateParams, reqEditors ...RequestEditorFn) (*ApiKeysValidateResponse, error) {
	rsp, err := c.ApiKeysValidate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysValidateResponse(rsp)
}

// ApiKeysDeleteWithResponse request returning *ApiKeysDeleteResponse
func (c *ClientWithResponses) ApiKeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysDeleteResponse, error) {
	rsp, err := c.ApiKeysDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysDeleteResponse(rsp)
}

// ApiKeysGetWithResponse request returning *ApiKeysGetResponse
func (c *ClientWithResponses) ApiKeysGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ApiKeysGetResponse, error) {
	rsp, err := c.ApiKeysGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysGetResponse(rsp)
}

// ApiKeysUpdateWithBodyWithResponse request with arbitrary body returning *ApiKeysUpdateResponse
func (c *ClientWithResponses) ApiKeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error) {
	rsp, err := c.ApiKeysUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysUpdateResponse(rsp)
}

func (c *ClientWithResponses) ApiKeysUpdateWithResponse(ctx context.Context, id string, body ApiKeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiKeysUpdateResponse, error) {
	rsp, err := c.ApiKeysUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiKeysUpdateResponse(rsp)
}

// AuthCheckEmailVerificationWithResponse request returning *AuthCheckEmailVerificationResponse
func (c *ClientWithResponses) AuthCheckEmailVerificationWithResponse(ctx context.Context, params *AuthCheckEmailVerificationParams, reqEditors ...RequestEditorFn) (*AuthCheckEmailVerificationResponse, error) {
	rsp, err := c.AuthCheckEmailVerification(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthCheckEmailVerificationResponse(rsp)
}

// AuthCsrfWithResponse request returning *AuthCsrfResponse
func (c *ClientWithResponses) AuthCsrfWithResponse(ctx context.Context, params *AuthCsrfParams, reqEditors ...RequestEditorFn) (*AuthCsrfResponse, error) {
	rsp, err := c.AuthCsrf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthCsrfResponse(rsp)
}

// AuthForgotPasswordWithBodyWithResponse request with arbitrary body returning *AuthForgotPasswordResponse
func (c *ClientWithResponses) AuthForgotPasswordWithBodyWithResponse(ctx context.Context, params *AuthForgotPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error) {
	rsp, err := c.AuthForgotPasswordWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthForgotPasswordResponse(rsp)
}

func (c *ClientWithResponses) AuthForgotPasswordWithResponse(ctx context.Context, params *AuthForgotPasswordParams, body AuthForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthForgotPasswordResponse, error) {
	rsp, err := c.AuthForgotPassword(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthForgotPasswordResponse(rsp)
}

// AuthLoginWithBodyWithResponse request with arbitrary body returning *AuthLoginResponse
func (c *ClientWithResponses) AuthLoginWithBodyWithResponse(ctx context.Context, params *AuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) AuthLoginWithResponse(ctx context.Context, params *AuthLoginParams, body AuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLogin(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

// AuthLogoutWithResponse request returning *AuthLogoutResponse
func (c *ClientWithResponses) AuthLogoutWithResponse(ctx context.Context, params *AuthLogoutParams, reqEditors ...RequestEditorFn) (*AuthLogoutResponse, error) {
	rsp, err := c.AuthLogout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutResponse(rsp)
}

// AuthMeWithResponse request returning *AuthMeResponse
func (c *ClientWithResponses) AuthMeWithResponse(ctx context.Context, params *AuthMeParams, reqEditors ...RequestEditorFn) (*AuthMeResponse, error) {
	rsp, err := c.AuthMe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthMeResponse(rsp)
}

// MfaEnrollWithBodyWithResponse request with arbitrary body returning *MfaEnrollResponse
func (c *ClientWithResponses) MfaEnrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error) {
	rsp, err := c.MfaEnrollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaEnrollResponse(rsp)
}

func (c *ClientWithResponses) MfaEnrollWithResponse(ctx context.Context, body MfaEnrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaEnrollResponse, error) {
	rsp, err := c.MfaEnroll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaEnrollResponse(rsp)
}

// MfaMethodsWithResponse request returning *MfaMethodsResponse
func (c *ClientWithResponses) MfaMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MfaMethodsResponse, error) {
	rsp, err := c.MfaMethods(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaMethodsResponse(rsp)
}

// MfaSendCodeWithBodyWithResponse request with arbitrary body returning *MfaSendCodeResponse
func (c *ClientWithResponses) MfaSendCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error) {
	rsp, err := c.MfaSendCodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaSendCodeResponse(rsp)
}

func (c *ClientWithResponses) MfaSendCodeWithResponse(ctx context.Context, body MfaSendCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaSendCodeResponse, error) {
	rsp, err := c.MfaSendCode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaSendCodeResponse(rsp)
}

// MfaUnenrollWithBodyWithResponse request with arbitrary body returning *MfaUnenrollResponse
func (c *ClientWithResponses) MfaUnenrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error) {
	rsp, err := c.MfaUnenrollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaUnenrollResponse(rsp)
}

func (c *ClientWithResponses) MfaUnenrollWithResponse(ctx context.Context, body MfaUnenrollJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaUnenrollResponse, error) {
	rsp, err := c.MfaUnenroll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaUnenrollResponse(rsp)
}

// MfaVerifyWithBodyWithResponse request with arbitrary body returning *MfaVerifyResponse
func (c *ClientWithResponses) MfaVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error) {
	rsp, err := c.MfaVerifyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaVerifyResponse(rsp)
}

func (c *ClientWithResponses) MfaVerifyWithResponse(ctx context.Context, body MfaVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*MfaVerifyResponse, error) {
	rsp, err := c.MfaVerify(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMfaVerifyResponse(rsp)
}

// OauthClientProviderCallbackWithResponse request returning *OauthClientProviderCallbackResponse
func (c *ClientWithResponses) OauthClientProviderCallbackWithResponse(ctx context.Context, provider string, params *OauthClientProviderCallbackParams, reqEditors ...RequestEditorFn) (*OauthClientProviderCallbackResponse, error) {
	rsp, err := c.OauthClientProviderCallback(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthClientProviderCallbackResponse(rsp)
}

// OauthClientListProvidersWithResponse request returning *OauthClientListProvidersResponse
func (c *ClientWithResponses) OauthClientListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthClientListProvidersResponse, error) {
	rsp, err := c.OauthClientListProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthClientListProvidersResponse(rsp)
}

// OauthClientProviderAuthWithResponse request returning *OauthClientProviderAuthResponse
func (c *ClientWithResponses) OauthClientProviderAuthWithResponse(ctx context.Context, provider string, params *OauthClientProviderAuthParams, reqEditors ...RequestEditorFn) (*OauthClientProviderAuthResponse, error) {
	rsp, err := c.OauthClientProviderAuth(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthClientProviderAuthResponse(rsp)
}

// PasskeysListWithResponse request returning *PasskeysListResponse
func (c *ClientWithResponses) PasskeysListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysListResponse, error) {
	rsp, err := c.PasskeysList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysListResponse(rsp)
}

// PasskeysLoginBeginWithResponse request returning *PasskeysLoginBeginResponse
func (c *ClientWithResponses) PasskeysLoginBeginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasskeysLoginBeginResponse, error) {
	rsp, err := c.PasskeysLoginBegin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysLoginBeginResponse(rsp)
}

// PasskeysLoginCompleteWithBodyWithResponse request with arbitrary body returning *PasskeysLoginCompleteResponse
func (c *ClientWithResponses) PasskeysLoginCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error) {
	rsp, err := c.PasskeysLoginCompleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysLoginCompleteResponse(rsp)
}

func (c *ClientWithResponses) PasskeysLoginCompleteWithResponse(ctx context.Context, body PasskeysLoginCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysLoginCompleteResponse, error) {
	rsp, err := c.PasskeysLoginComplete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysLoginCompleteResponse(rsp)
}

// PasskeysRegisterBeginWithBodyWithResponse request with arbitrary body returning *PasskeysRegisterBeginResponse
func (c *ClientWithResponses) PasskeysRegisterBeginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error) {
	rsp, err := c.PasskeysRegisterBeginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterBeginResponse(rsp)
}

func (c *ClientWithResponses) PasskeysRegisterBeginWithResponse(ctx context.Context, body PasskeysRegisterBeginJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterBeginResponse, error) {
	rsp, err := c.PasskeysRegisterBegin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterBeginResponse(rsp)
}

// PasskeysRegisterCompleteWithBodyWithResponse request with arbitrary body returning *PasskeysRegisterCompleteResponse
func (c *ClientWithResponses) PasskeysRegisterCompleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error) {
	rsp, err := c.PasskeysRegisterCompleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterCompleteResponse(rsp)
}

func (c *ClientWithResponses) PasskeysRegisterCompleteWithResponse(ctx context.Context, body PasskeysRegisterCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysRegisterCompleteResponse, error) {
	rsp, err := c.PasskeysRegisterComplete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysRegisterCompleteResponse(rsp)
}

// PasskeysDeleteWithResponse request returning *PasskeysDeleteResponse
func (c *ClientWithResponses) PasskeysDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PasskeysDeleteResponse, error) {
	rsp, err := c.PasskeysDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysDeleteResponse(rsp)
}

// PasskeysUpdateWithBodyWithResponse request with arbitrary body returning *PasskeysUpdateResponse
func (c *ClientWithResponses) PasskeysUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error) {
	rsp, err := c.PasskeysUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysUpdateResponse(rsp)
}

func (c *ClientWithResponses) PasskeysUpdateWithResponse(ctx context.Context, id string, body PasskeysUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeysUpdateResponse, error) {
	rsp, err := c.PasskeysUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeysUpdateResponse(rsp)
}

// PasswordlessEmailWithBodyWithResponse request with arbitrary body returning *PasswordlessEmailResponse
func (c *ClientWithResponses) PasswordlessEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error) {
	rsp, err := c.PasswordlessEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessEmailResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessEmailWithResponse(ctx context.Context, body PasswordlessEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessEmailResponse, error) {
	rsp, err := c.PasswordlessEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessEmailResponse(rsp)
}

// PasswordlessMagicLinkWithBodyWithResponse request with arbitrary body returning *PasswordlessMagicLinkResponse
func (c *ClientWithResponses) PasswordlessMagicLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error) {
	rsp, err := c.PasswordlessMagicLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessMagicLinkResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessMagicLinkWithResponse(ctx context.Context, body PasswordlessMagicLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessMagicLinkResponse, error) {
	rsp, err := c.PasswordlessMagicLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessMagicLinkResponse(rsp)
}

// PasswordlessMethodsWithResponse request returning *PasswordlessMethodsResponse
func (c *ClientWithResponses) PasswordlessMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PasswordlessMethodsResponse, error) {
	rsp, err := c.PasswordlessMethods(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessMethodsResponse(rsp)
}

// PasswordlessSmsWithBodyWithResponse request with arbitrary body returning *PasswordlessSmsResponse
func (c *ClientWithResponses) PasswordlessSmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error) {
	rsp, err := c.PasswordlessSmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessSmsResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessSmsWithResponse(ctx context.Context, body PasswordlessSmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessSmsResponse, error) {
	rsp, err := c.PasswordlessSms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessSmsResponse(rsp)
}

// PasswordlessVerifyWithBodyWithResponse request with arbitrary body returning *PasswordlessVerifyResponse
func (c *ClientWithResponses) PasswordlessVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error) {
	rsp, err := c.PasswordlessVerifyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessVerifyResponse(rsp)
}

func (c *ClientWithResponses) PasswordlessVerifyWithResponse(ctx context.Context, body PasswordlessVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordlessVerifyResponse, error) {
	rsp, err := c.PasswordlessVerify(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordlessVerifyResponse(rsp)
}

// AuthRefreshTokenWithBodyWithResponse request with arbitrary body returning *AuthRefreshTokenResponse
func (c *ClientWithResponses) AuthRefreshTokenWithBodyWithResponse(ctx context.Context, params *AuthRefreshTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error) {
	rsp, err := c.AuthRefreshTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) AuthRefreshTokenWithResponse(ctx context.Context, params *AuthRefreshTokenParams, body AuthRefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRefreshTokenResponse, error) {
	rsp, err := c.AuthRefreshToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRefreshTokenResponse(rsp)
}

// AuthRegisterWithBodyWithResponse request with arbitrary body returning *AuthRegisterResponse
func (c *ClientWithResponses) AuthRegisterWithBodyWithResponse(ctx context.Context, params *AuthRegisterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error) {
	rsp, err := c.AuthRegisterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegisterResponse(rsp)
}

func (c *ClientWithResponses) AuthRegisterWithResponse(ctx context.Context, params *AuthRegisterParams, body AuthRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthRegisterResponse, error) {
	rsp, err := c.AuthRegister(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegisterResponse(rsp)
}

// AuthResetPasswordWithBodyWithResponse request with arbitrary body returning *AuthResetPasswordResponse
func (c *ClientWithResponses) AuthResetPasswordWithBodyWithResponse(ctx context.Context, params *AuthResetPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error) {
	rsp, err := c.AuthResetPasswordWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) AuthResetPasswordWithResponse(ctx context.Context, params *AuthResetPasswordParams, body AuthResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthResetPasswordResponse, error) {
	rsp, err := c.AuthResetPassword(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthResetPasswordResponse(rsp)
}

// AuthSendEmailVerificationWithBodyWithResponse request with arbitrary body returning *AuthSendEmailVerificationResponse
func (c *ClientWithResponses) AuthSendEmailVerificationWithBodyWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error) {
	rsp, err := c.AuthSendEmailVerificationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthSendEmailVerificationResponse(rsp)
}

func (c *ClientWithResponses) AuthSendEmailVerificationWithResponse(ctx context.Context, params *AuthSendEmailVerificationParams, body AuthSendEmailVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthSendEmailVerificationResponse, error) {
	rsp, err := c.AuthSendEmailVerification(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthSendEmailVerificationResponse(rsp)
}

// SsoProviderCallbackWithResponse request returning *SsoProviderCallbackResponse
func (c *ClientWithResponses) SsoProviderCallbackWithResponse(ctx context.Context, provider string, params *SsoProviderCallbackParams, reqEditors ...RequestEditorFn) (*SsoProviderCallbackResponse, error) {
	rsp, err := c.SsoProviderCallback(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoProviderCallbackResponse(rsp)
}

// SsoListIdentityProvidersWithResponse request returning *SsoListIdentityProvidersResponse
func (c *ClientWithResponses) SsoListIdentityProvidersWithResponse(ctx context.Context, params *SsoListIdentityProvidersParams, reqEditors ...RequestEditorFn) (*SsoListIdentityProvidersResponse, error) {
	rsp, err := c.SsoListIdentityProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoListIdentityProvidersResponse(rsp)
}

// SsoCreateIdentityProviderWithBodyWithResponse request with arbitrary body returning *SsoCreateIdentityProviderResponse
func (c *ClientWithResponses) SsoCreateIdentityProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error) {
	rsp, err := c.SsoCreateIdentityProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoCreateIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) SsoCreateIdentityProviderWithResponse(ctx context.Context, body SsoCreateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoCreateIdentityProviderResponse, error) {
	rsp, err := c.SsoCreateIdentityProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoCreateIdentityProviderResponse(rsp)
}

// SsoDeleteIdentityProviderWithResponse request returning *SsoDeleteIdentityProviderResponse
func (c *ClientWithResponses) SsoDeleteIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoDeleteIdentityProviderResponse, error) {
	rsp, err := c.SsoDeleteIdentityProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoDeleteIdentityProviderResponse(rsp)
}

// SsoGetIdentityProviderWithResponse request returning *SsoGetIdentityProviderResponse
func (c *ClientWithResponses) SsoGetIdentityProviderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoGetIdentityProviderResponse, error) {
	rsp, err := c.SsoGetIdentityProvider(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoGetIdentityProviderResponse(rsp)
}

// SsoUpdateIdentityProviderWithBodyWithResponse request with arbitrary body returning *SsoUpdateIdentityProviderResponse
func (c *ClientWithResponses) SsoUpdateIdentityProviderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error) {
	rsp, err := c.SsoUpdateIdentityProviderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoUpdateIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) SsoUpdateIdentityProviderWithResponse(ctx context.Context, id string, body SsoUpdateIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*SsoUpdateIdentityProviderResponse, error) {
	rsp, err := c.SsoUpdateIdentityProvider(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoUpdateIdentityProviderResponse(rsp)
}

// SsoListProvidersWithResponse request returning *SsoListProvidersResponse
func (c *ClientWithResponses) SsoListProvidersWithResponse(ctx context.Context, params *SsoListProvidersParams, reqEditors ...RequestEditorFn) (*SsoListProvidersResponse, error) {
	rsp, err := c.SsoListProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoListProvidersResponse(rsp)
}

// SsoProviderAuthWithResponse request returning *SsoProviderAuthResponse
func (c *ClientWithResponses) SsoProviderAuthWithResponse(ctx context.Context, provider string, params *SsoProviderAuthParams, reqEditors ...RequestEditorFn) (*SsoProviderAuthResponse, error) {
	rsp, err := c.SsoProviderAuth(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoProviderAuthResponse(rsp)
}

// SsoSamlAcsWithResponse request returning *SsoSamlAcsResponse
func (c *ClientWithResponses) SsoSamlAcsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlAcsResponse, error) {
	rsp, err := c.SsoSamlAcs(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoSamlAcsResponse(rsp)
}

// SsoSamlMetadataWithResponse request returning *SsoSamlMetadataResponse
func (c *ClientWithResponses) SsoSamlMetadataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SsoSamlMetadataResponse, error) {
	rsp, err := c.SsoSamlMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSsoSamlMetadataResponse(rsp)
}

// AuthVerifyEmailWithBodyWithResponse request with arbitrary body returning *AuthVerifyEmailResponse
func (c *ClientWithResponses) AuthVerifyEmailWithBodyWithResponse(ctx context.Context, params *AuthVerifyEmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error) {
	rsp, err := c.AuthVerifyEmailWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthVerifyEmailResponse(rsp)
}

func (c *ClientWithResponses) AuthVerifyEmailWithResponse(ctx context.Context, params *AuthVerifyEmailParams, body AuthVerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthVerifyEmailResponse, error) {
	rsp, err := c.AuthVerifyEmail(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthVerifyEmailResponse(rsp)
}

// EmailSendWithBodyWithResponse request with arbitrary body returning *EmailSendResponse
func (c *ClientWithResponses) EmailSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendResponse, error) {
	rsp, err := c.EmailSendWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendResponse(rsp)
}

func (c *ClientWithResponses) EmailSendWithResponse(ctx context.Context, body EmailSendJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendResponse, error) {
	rsp, err := c.EmailSend(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendResponse(rsp)
}

// EmailSendTemplateWithBodyWithResponse request with arbitrary body returning *EmailSendTemplateResponse
func (c *ClientWithResponses) EmailSendTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error) {
	rsp, err := c.EmailSendTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendTemplateResponse(rsp)
}

func (c *ClientWithResponses) EmailSendTemplateWithResponse(ctx context.Context, body EmailSendTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailSendTemplateResponse, error) {
	rsp, err := c.EmailSendTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailSendTemplateResponse(rsp)
}

// EmailListTemplatesWithResponse request returning *EmailListTemplatesResponse
func (c *ClientWithResponses) EmailListTemplatesWithResponse(ctx context.Context, params *EmailListTemplatesParams, reqEditors ...RequestEditorFn) (*EmailListTemplatesResponse, error) {
	rsp, err := c.EmailListTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailListTemplatesResponse(rsp)
}

// EmailCreateTemplateWithBodyWithResponse request with arbitrary body returning *EmailCreateTemplateResponse
func (c *ClientWithResponses) EmailCreateTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error) {
	rsp, err := c.EmailCreateTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailCreateTemplateResponse(rsp)
}

func (c *ClientWithResponses) EmailCreateTemplateWithResponse(ctx context.Context, body EmailCreateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailCreateTemplateResponse, error) {
	rsp, err := c.EmailCreateTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailCreateTemplateResponse(rsp)
}

// EmailGetTemplateByTypeWithResponse request returning *EmailGetTemplateByTypeResponse
func (c *ClientWithResponses) EmailGetTemplateByTypeWithResponse(ctx context.Context, pType string, params *EmailGetTemplateByTypeParams, reqEditors ...RequestEditorFn) (*EmailGetTemplateByTypeResponse, error) {
	rsp, err := c.EmailGetTemplateByType(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailGetTemplateByTypeResponse(rsp)
}

// EmailDeleteTemplateWithResponse request returning *EmailDeleteTemplateResponse
func (c *ClientWithResponses) EmailDeleteTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailDeleteTemplateResponse, error) {
	rsp, err := c.EmailDeleteTemplate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailDeleteTemplateResponse(rsp)
}

// EmailGetTemplateWithResponse request returning *EmailGetTemplateResponse
func (c *ClientWithResponses) EmailGetTemplateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EmailGetTemplateResponse, error) {
	rsp, err := c.EmailGetTemplate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailGetTemplateResponse(rsp)
}

// EmailUpdateTemplateWithBodyWithResponse request with arbitrary body returning *EmailUpdateTemplateResponse
func (c *ClientWithResponses) EmailUpdateTemplateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error) {
	rsp, err := c.EmailUpdateTemplateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailUpdateTemplateResponse(rsp)
}

func (c *ClientWithResponses) EmailUpdateTemplateWithResponse(ctx context.Context, id string, body EmailUpdateTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailUpdateTemplateResponse, error) {
	rsp, err := c.EmailUpdateTemplate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailUpdateTemplateResponse(rsp)
}

// OauthProviderJwksWithResponse request returning *OauthProviderJwksResponse
func (c *ClientWithResponses) OauthProviderJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderJwksResponse, error) {
	rsp, err := c.OauthProviderJwks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderJwksResponse(rsp)
}

// OauthProviderOidcConfigurationWithResponse request returning *OauthProviderOidcConfigurationResponse
func (c *ClientWithResponses) OauthProviderOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderOidcConfigurationResponse, error) {
	rsp, err := c.OauthProviderOidcConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderOidcConfigurationResponse(rsp)
}

// OauthProviderAuthorizeWithResponse request returning *OauthProviderAuthorizeResponse
func (c *ClientWithResponses) OauthProviderAuthorizeWithResponse(ctx context.Context, params *OauthProviderAuthorizeParams, reqEditors ...RequestEditorFn) (*OauthProviderAuthorizeResponse, error) {
	rsp, err := c.OauthProviderAuthorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderAuthorizeResponse(rsp)
}

// OauthProviderListClientsWithResponse request returning *OauthProviderListClientsResponse
func (c *ClientWithResponses) OauthProviderListClientsWithResponse(ctx context.Context, params *OauthProviderListClientsParams, reqEditors ...RequestEditorFn) (*OauthProviderListClientsResponse, error) {
	rsp, err := c.OauthProviderListClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderListClientsResponse(rsp)
}

// OauthProviderCreateClientWithBodyWithResponse request with arbitrary body returning *OauthProviderCreateClientResponse
func (c *ClientWithResponses) OauthProviderCreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error) {
	rsp, err := c.OauthProviderCreateClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateClientResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderCreateClientWithResponse(ctx context.Context, body OauthProviderCreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateClientResponse, error) {
	rsp, err := c.OauthProviderCreateClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateClientResponse(rsp)
}

// OauthProviderDeleteClientWithResponse request returning *OauthProviderDeleteClientResponse
func (c *ClientWithResponses) OauthProviderDeleteClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteClientResponse, error) {
	rsp, err := c.OauthProviderDeleteClient(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderDeleteClientResponse(rsp)
}

// OauthProviderGetClientWithResponse request returning *OauthProviderGetClientResponse
func (c *ClientWithResponses) OauthProviderGetClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetClientResponse, error) {
	rsp, err := c.OauthProviderGetClient(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderGetClientResponse(rsp)
}

// OauthProviderUpdateClientWithBodyWithResponse request with arbitrary body returning *OauthProviderUpdateClientResponse
func (c *ClientWithResponses) OauthProviderUpdateClientWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error) {
	rsp, err := c.OauthProviderUpdateClientWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateClientResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderUpdateClientWithResponse(ctx context.Context, id string, body OauthProviderUpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateClientResponse, error) {
	rsp, err := c.OauthProviderUpdateClient(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateClientResponse(rsp)
}

// OauthProviderRotateClientSecretWithResponse request returning *OauthProviderRotateClientSecretResponse
func (c *ClientWithResponses) OauthProviderRotateClientSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderRotateClientSecretResponse, error) {
	rsp, err := c.OauthProviderRotateClientSecret(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderRotateClientSecretResponse(rsp)
}

// OauthProviderConsentWithBodyWithResponse request with arbitrary body returning *OauthProviderConsentResponse
func (c *ClientWithResponses) OauthProviderConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error) {
	rsp, err := c.OauthProviderConsentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderConsentResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderConsentWithResponse(ctx context.Context, body OauthProviderConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderConsentResponse, error) {
	rsp, err := c.OauthProviderConsent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderConsentResponse(rsp)
}

// OauthProviderIntrospectWithResponse request returning *OauthProviderIntrospectResponse
func (c *ClientWithResponses) OauthProviderIntrospectWithResponse(ctx context.Context, params *OauthProviderIntrospectParams, reqEditors ...RequestEditorFn) (*OauthProviderIntrospectResponse, error) {
	rsp, err := c.OauthProviderIntrospect(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderIntrospectResponse(rsp)
}

// OauthProviderRevokeWithResponse request returning *OauthProviderRevokeResponse
func (c *ClientWithResponses) OauthProviderRevokeWithResponse(ctx context.Context, params *OauthProviderRevokeParams, reqEditors ...RequestEditorFn) (*OauthProviderRevokeResponse, error) {
	rsp, err := c.OauthProviderRevoke(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderRevokeResponse(rsp)
}

// OauthProviderListScopesWithResponse request returning *OauthProviderListScopesResponse
func (c *ClientWithResponses) OauthProviderListScopesWithResponse(ctx context.Context, params *OauthProviderListScopesParams, reqEditors ...RequestEditorFn) (*OauthProviderListScopesResponse, error) {
	rsp, err := c.OauthProviderListScopes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderListScopesResponse(rsp)
}

// OauthProviderCreateScopeWithBodyWithResponse request with arbitrary body returning *OauthProviderCreateScopeResponse
func (c *ClientWithResponses) OauthProviderCreateScopeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error) {
	rsp, err := c.OauthProviderCreateScopeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateScopeResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderCreateScopeWithResponse(ctx context.Context, body OauthProviderCreateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderCreateScopeResponse, error) {
	rsp, err := c.OauthProviderCreateScope(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderCreateScopeResponse(rsp)
}

// OauthProviderDeleteScopeWithResponse request returning *OauthProviderDeleteScopeResponse
func (c *ClientWithResponses) OauthProviderDeleteScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderDeleteScopeResponse, error) {
	rsp, err := c.OauthProviderDeleteScope(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderDeleteScopeResponse(rsp)
}

// OauthProviderGetScopeWithResponse request returning *OauthProviderGetScopeResponse
func (c *ClientWithResponses) OauthProviderGetScopeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OauthProviderGetScopeResponse, error) {
	rsp, err := c.OauthProviderGetScope(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderGetScopeResponse(rsp)
}

// OauthProviderUpdateScopeWithBodyWithResponse request with arbitrary body returning *OauthProviderUpdateScopeResponse
func (c *ClientWithResponses) OauthProviderUpdateScopeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error) {
	rsp, err := c.OauthProviderUpdateScopeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateScopeResponse(rsp)
}

func (c *ClientWithResponses) OauthProviderUpdateScopeWithResponse(ctx context.Context, id string, body OauthProviderUpdateScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthProviderUpdateScopeResponse, error) {
	rsp, err := c.OauthProviderUpdateScope(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUpdateScopeResponse(rsp)
}

// OauthProviderTokenWithResponse request returning *OauthProviderTokenResponse
func (c *ClientWithResponses) OauthProviderTokenWithResponse(ctx context.Context, params *OauthProviderTokenParams, reqEditors ...RequestEditorFn) (*OauthProviderTokenResponse, error) {
	rsp, err := c.OauthProviderToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderTokenResponse(rsp)
}

// OauthProviderUserinfoWithResponse request returning *OauthProviderUserinfoResponse
func (c *ClientWithResponses) OauthProviderUserinfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OauthProviderUserinfoResponse, error) {
	rsp, err := c.OauthProviderUserinfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthProviderUserinfoResponse(rsp)
}

// OrganizationsListWithResponse request returning *OrganizationsListResponse
func (c *ClientWithResponses) OrganizationsListWithResponse(ctx context.Context, params *OrganizationsListParams, reqEditors ...RequestEditorFn) (*OrganizationsListResponse, error) {
	rsp, err := c.OrganizationsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsListResponse(rsp)
}

// OrganizationsCreateWithBodyWithResponse request with arbitrary body returning *OrganizationsCreateResponse
func (c *ClientWithResponses) OrganizationsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error) {
	rsp, err := c.OrganizationsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsCreateResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsCreateWithResponse(ctx context.Context, body OrganizationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsCreateResponse, error) {
	rsp, err := c.OrganizationsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsCreateResponse(rsp)
}

// OrganizationsDeleteWithResponse request returning *OrganizationsDeleteResponse
func (c *ClientWithResponses) OrganizationsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsDeleteResponse, error) {
	rsp, err := c.OrganizationsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsDeleteResponse(rsp)
}

// OrganizationsGetWithResponse request returning *OrganizationsGetResponse
func (c *ClientWithResponses) OrganizationsGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsGetResponse, error) {
	rsp, err := c.OrganizationsGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsGetResponse(rsp)
}

// OrganizationsUpdateWithBodyWithResponse request with arbitrary body returning *OrganizationsUpdateResponse
func (c *ClientWithResponses) OrganizationsUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error) {
	rsp, err := c.OrganizationsUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsUpdateWithResponse(ctx context.Context, id string, body OrganizationsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateResponse, error) {
	rsp, err := c.OrganizationsUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateResponse(rsp)
}

// OrganizationsListFeaturesWithResponse request returning *OrganizationsListFeaturesResponse
func (c *ClientWithResponses) OrganizationsListFeaturesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OrganizationsListFeaturesResponse, error) {
	rsp, err := c.OrganizationsListFeatures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsListFeaturesResponse(rsp)
}

// OrganizationsEnableFeatureWithBodyWithResponse request with arbitrary body returning *OrganizationsEnableFeatureResponse
func (c *ClientWithResponses) OrganizationsEnableFeatureWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error) {
	rsp, err := c.OrganizationsEnableFeatureWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsEnableFeatureResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsEnableFeatureWithResponse(ctx context.Context, id string, body OrganizationsEnableFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsEnableFeatureResponse, error) {
	rsp, err := c.OrganizationsEnableFeature(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsEnableFeatureResponse(rsp)
}

// OrganizationsDisableFeatureWithResponse request returning *OrganizationsDisableFeatureResponse
func (c *ClientWithResponses) OrganizationsDisableFeatureWithResponse(ctx context.Context, id string, featureKey string, reqEditors ...RequestEditorFn) (*OrganizationsDisableFeatureResponse, error) {
	rsp, err := c.OrganizationsDisableFeature(ctx, id, featureKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsDisableFeatureResponse(rsp)
}

// OrganizationsListMembersWithResponse request returning *OrganizationsListMembersResponse
func (c *ClientWithResponses) OrganizationsListMembersWithResponse(ctx context.Context, id string, params *OrganizationsListMembersParams, reqEditors ...RequestEditorFn) (*OrganizationsListMembersResponse, error) {
	rsp, err := c.OrganizationsListMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsListMembersResponse(rsp)
}

// OrganizationsAddMemberWithBodyWithResponse request with arbitrary body returning *OrganizationsAddMemberResponse
func (c *ClientWithResponses) OrganizationsAddMemberWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error) {
	rsp, err := c.OrganizationsAddMemberWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsAddMemberResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsAddMemberWithResponse(ctx context.Context, id string, body OrganizationsAddMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsAddMemberResponse, error) {
	rsp, err := c.OrganizationsAddMember(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsAddMemberResponse(rsp)
}

// OrganizationsRemoveMemberWithResponse request returning *OrganizationsRemoveMemberResponse
func (c *ClientWithResponses) OrganizationsRemoveMemberWithResponse(ctx context.Context, id string, userId string, reqEditors ...RequestEditorFn) (*OrganizationsRemoveMemberResponse, error) {
	rsp, err := c.OrganizationsRemoveMember(ctx, id, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsRemoveMemberResponse(rsp)
}

// OrganizationsUpdateMemberWithBodyWithResponse request with arbitrary body returning *OrganizationsUpdateMemberResponse
func (c *ClientWithResponses) OrganizationsUpdateMemberWithBodyWithResponse(ctx context.Context, id string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error) {
	rsp, err := c.OrganizationsUpdateMemberWithBody(ctx, id, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateMemberResponse(rsp)
}

func (c *ClientWithResponses) OrganizationsUpdateMemberWithResponse(ctx context.Context, id string, userId string, body OrganizationsUpdateMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*OrganizationsUpdateMemberResponse, error) {
	rsp, err := c.OrganizationsUpdateMember(ctx, id, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationsUpdateMemberResponse(rsp)
}

// RbacListPermissionsWithResponse request returning *RbacListPermissionsResponse
func (c *ClientWithResponses) RbacListPermissionsWithResponse(ctx context.Context, params *RbacListPermissionsParams, reqEditors ...RequestEditorFn) (*RbacListPermissionsResponse, error) {
	rsp, err := c.RbacListPermissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacListPermissionsResponse(rsp)
}

// RbacCreatePermissionWithBodyWithResponse request with arbitrary body returning *RbacCreatePermissionResponse
func (c *ClientWithResponses) RbacCreatePermissionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error) {
	rsp, err := c.RbacCreatePermissionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreatePermissionResponse(rsp)
}

func (c *ClientWithResponses) RbacCreatePermissionWithResponse(ctx context.Context, body RbacCreatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreatePermissionResponse, error) {
	rsp, err := c.RbacCreatePermission(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreatePermissionResponse(rsp)
}

// RbacDeletePermissionWithResponse request returning *RbacDeletePermissionResponse
func (c *ClientWithResponses) RbacDeletePermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeletePermissionResponse, error) {
	rsp, err := c.RbacDeletePermission(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacDeletePermissionResponse(rsp)
}

// RbacGetPermissionWithResponse request returning *RbacGetPermissionResponse
func (c *ClientWithResponses) RbacGetPermissionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetPermissionResponse, error) {
	rsp, err := c.RbacGetPermission(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacGetPermissionResponse(rsp)
}

// RbacUpdatePermissionWithBodyWithResponse request with arbitrary body returning *RbacUpdatePermissionResponse
func (c *ClientWithResponses) RbacUpdatePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error) {
	rsp, err := c.RbacUpdatePermissionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdatePermissionResponse(rsp)
}

func (c *ClientWithResponses) RbacUpdatePermissionWithResponse(ctx context.Context, id string, body RbacUpdatePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdatePermissionResponse, error) {
	rsp, err := c.RbacUpdatePermission(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdatePermissionResponse(rsp)
}

// RbacListRolesWithResponse request returning *RbacListRolesResponse
func (c *ClientWithResponses) RbacListRolesWithResponse(ctx context.Context, params *RbacListRolesParams, reqEditors ...RequestEditorFn) (*RbacListRolesResponse, error) {
	rsp, err := c.RbacListRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacListRolesResponse(rsp)
}

// RbacCreateRoleWithBodyWithResponse request with arbitrary body returning *RbacCreateRoleResponse
func (c *ClientWithResponses) RbacCreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error) {
	rsp, err := c.RbacCreateRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) RbacCreateRoleWithResponse(ctx context.Context, body RbacCreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacCreateRoleResponse, error) {
	rsp, err := c.RbacCreateRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacCreateRoleResponse(rsp)
}

// RbacDeleteRoleWithResponse request returning *RbacDeleteRoleResponse
func (c *ClientWithResponses) RbacDeleteRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacDeleteRoleResponse, error) {
	rsp, err := c.RbacDeleteRole(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacDeleteRoleResponse(rsp)
}

// RbacGetRoleWithResponse request returning *RbacGetRoleResponse
func (c *ClientWithResponses) RbacGetRoleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacGetRoleResponse, error) {
	rsp, err := c.RbacGetRole(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacGetRoleResponse(rsp)
}

// RbacUpdateRoleWithBodyWithResponse request with arbitrary body returning *RbacUpdateRoleResponse
func (c *ClientWithResponses) RbacUpdateRoleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error) {
	rsp, err := c.RbacUpdateRoleWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) RbacUpdateRoleWithResponse(ctx context.Context, id string, body RbacUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacUpdateRoleResponse, error) {
	rsp, err := c.RbacUpdateRole(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacUpdateRoleResponse(rsp)
}

// RbacListRolePermissionsWithResponse request returning *RbacListRolePermissionsResponse
func (c *ClientWithResponses) RbacListRolePermissionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RbacListRolePermissionsResponse, error) {
	rsp, err := c.RbacListRolePermissions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacListRolePermissionsResponse(rsp)
}

// RbacAddRolePermissionWithBodyWithResponse request with arbitrary body returning *RbacAddRolePermissionResponse
func (c *ClientWithResponses) RbacAddRolePermissionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error) {
	rsp, err := c.RbacAddRolePermissionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacAddRolePermissionResponse(rsp)
}

func (c *ClientWithResponses) RbacAddRolePermissionWithResponse(ctx context.Context, id string, body RbacAddRolePermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RbacAddRolePermissionResponse, error) {
	rsp, err := c.RbacAddRolePermission(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacAddRolePermissionResponse(rsp)
}

// RbacRemoveRolePermissionWithResponse request returning *RbacRemoveRolePermissionResponse
func (c *ClientWithResponses) RbacRemoveRolePermissionWithResponse(ctx context.Context, id string, permissionId string, reqEditors ...RequestEditorFn) (*RbacRemoveRolePermissionResponse, error) {
	rsp, err := c.RbacRemoveRolePermission(ctx, id, permissionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRbacRemoveRolePermissionResponse(rsp)
}

// UsersListWithResponse request returning *UsersListResponse
func (c *ClientWithResponses) UsersListWithResponse(ctx context.Context, params *UsersListParams, reqEditors ...RequestEditorFn) (*UsersListResponse, error) {
	rsp, err := c.UsersList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersListResponse(rsp)
}

// UsersCreateWithBodyWithResponse request with arbitrary body returning *UsersCreateResponse
func (c *ClientWithResponses) UsersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) UsersCreateWithResponse(ctx context.Context, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

// UsersUpdateMeWithBodyWithResponse request with arbitrary body returning *UsersUpdateMeResponse
func (c *ClientWithResponses) UsersUpdateMeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error) {
	rsp, err := c.UsersUpdateMeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateMeResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdateMeWithResponse(ctx context.Context, body UsersUpdateMeJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateMeResponse, error) {
	rsp, err := c.UsersUpdateMe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateMeResponse(rsp)
}

// UsersUpdatePasswordWithBodyWithResponse request with arbitrary body returning *UsersUpdatePasswordResponse
func (c *ClientWithResponses) UsersUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error) {
	rsp, err := c.UsersUpdatePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePasswordResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdatePasswordWithResponse(ctx context.Context, body UsersUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePasswordResponse, error) {
	rsp, err := c.UsersUpdatePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePasswordResponse(rsp)
}

// UsersGetSessionsWithResponse request returning *UsersGetSessionsResponse
func (c *ClientWithResponses) UsersGetSessionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsersGetSessionsResponse, error) {
	rsp, err := c.UsersGetSessions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetSessionsResponse(rsp)
}

// UsersDeleteSessionWithResponse request returning *UsersDeleteSessionResponse
func (c *ClientWithResponses) UsersDeleteSessionWithResponse(ctx context.Context, sessionId string, reqEditors ...RequestEditorFn) (*UsersDeleteSessionResponse, error) {
	rsp, err := c.UsersDeleteSession(ctx, sessionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDeleteSessionResponse(rsp)
}

// UsersDeleteWithResponse request returning *UsersDeleteResponse
func (c *ClientWithResponses) UsersDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersDeleteResponse, error) {
	rsp, err := c.UsersDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDeleteResponse(rsp)
}

// UsersGetWithResponse request returning *UsersGetResponse
func (c *ClientWithResponses) UsersGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetResponse, error) {
	rsp, err := c.UsersGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetResponse(rsp)
}

// UsersUpdateWithBodyWithResponse request with arbitrary body returning *UsersUpdateResponse
func (c *ClientWithResponses) UsersUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error) {
	rsp, err := c.UsersUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdateWithResponse(ctx context.Context, id string, body UsersUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdateResponse, error) {
	rsp, err := c.UsersUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateResponse(rsp)
}

// UsersGetOrganizationsWithResponse request returning *UsersGetOrganizationsResponse
func (c *ClientWithResponses) UsersGetOrganizationsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UsersGetOrganizationsResponse, error) {
	rsp, err := c.UsersGetOrganizations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetOrganizationsResponse(rsp)
}

// WebhooksListWithResponse request returning *WebhooksListResponse
func (c *ClientWithResponses) WebhooksListWithResponse(ctx context.Context, params *WebhooksListParams, reqEditors ...RequestEditorFn) (*WebhooksListResponse, error) {
	rsp, err := c.WebhooksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListResponse(rsp)
}

// WebhooksCreateWithBodyWithResponse request with arbitrary body returning *WebhooksCreateResponse
func (c *ClientWithResponses) WebhooksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksCreateWithResponse(ctx context.Context, body WebhooksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksCreateResponse, error) {
	rsp, err := c.WebhooksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksCreateResponse(rsp)
}

// WebhooksReceiveWithResponse request returning *WebhooksReceiveResponse
func (c *ClientWithResponses) WebhooksReceiveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksReceiveResponse, error) {
	rsp, err := c.WebhooksReceive(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksReceiveResponse(rsp)
}

// WebhooksTriggerEventWithBodyWithResponse request with arbitrary body returning *WebhooksTriggerEventResponse
func (c *ClientWithResponses) WebhooksTriggerEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error) {
	rsp, err := c.WebhooksTriggerEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksTriggerEventResponse(rsp)
}

func (c *ClientWithResponses) WebhooksTriggerEventWithResponse(ctx context.Context, body WebhooksTriggerEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksTriggerEventResponse, error) {
	rsp, err := c.WebhooksTriggerEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksTriggerEventResponse(rsp)
}

// WebhooksDeleteWithResponse request returning *WebhooksDeleteResponse
func (c *ClientWithResponses) WebhooksDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksDeleteResponse, error) {
	rsp, err := c.WebhooksDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksDeleteResponse(rsp)
}

// WebhooksGetWithResponse request returning *WebhooksGetResponse
func (c *ClientWithResponses) WebhooksGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*WebhooksGetResponse, error) {
	rsp, err := c.WebhooksGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksGetResponse(rsp)
}

// WebhooksUpdateWithBodyWithResponse request with arbitrary body returning *WebhooksUpdateResponse
func (c *ClientWithResponses) WebhooksUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

func (c *ClientWithResponses) WebhooksUpdateWithResponse(ctx context.Context, id string, body WebhooksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhooksUpdateResponse, error) {
	rsp, err := c.WebhooksUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksUpdateResponse(rsp)
}

// WebhooksListEventsWithResponse request returning *WebhooksListEventsResponse
func (c *ClientWithResponses) WebhooksListEventsWithResponse(ctx context.Context, id string, params *WebhooksListEventsParams, reqEditors ...RequestEditorFn) (*WebhooksListEventsResponse, error) {
	rsp, err := c.WebhooksListEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksListEventsResponse(rsp)
}

// WebhooksReplayEventWithResponse request returning *WebhooksReplayEventResponse
func (c *ClientWithResponses) WebhooksReplayEventWithResponse(ctx context.Context, id string, eventId string, reqEditors ...RequestEditorFn) (*WebhooksReplayEventResponse, error) {
	rsp, err := c.WebhooksReplayEvent(ctx, id, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhooksReplayEventResponse(rsp)
}

// ParseHealthDebugResponse parses an HTTP response from a HealthDebugWithResponse call
func ParseHealthDebugResponse(rsp *http.Response) (*HealthDebugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthDebugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseHealthMetricsResponse parses an HTTP response from a HealthMetricsWithResponse call
func ParseHealthMetricsResponse(rsp *http.Response) (*HealthMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHealthReadyResponse parses an HTTP response from a HealthReadyWithResponse call
func ParseHealthReadyResponse(rsp *http.Response) (*HealthReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ReadyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseHealthVersionResponse parses an HTTP response from a HealthVersionWithResponse call
func ParseHealthVersionResponse(rsp *http.Response) (*HealthVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRbacCheckPermissionResponse parses an HTTP response from a RbacCheckPermissionWithResponse call
func ParseRbacCheckPermissionResponse(rsp *http.Response) (*RbacCheckPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCheckPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckPermissionResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacCheckRoleResponse parses an HTTP response from a RbacCheckRoleWithResponse call
func ParseRbacCheckRoleResponse(rsp *http.Response) (*RbacCheckRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCheckRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckRoleResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysListResponse parses an HTTP response from a ApiKeysListWithResponse call
func ParseApiKeysListResponse(rsp *http.Response) (*ApiKeysListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysCreateResponse parses an HTTP response from a ApiKeysCreateWithResponse call
func ParseApiKeysCreateResponse(rsp *http.Response) (*ApiKeysCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest APIKeyWithSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysValidateResponse parses an HTTP response from a ApiKeysValidateWithResponse call
func ParseApiKeysValidateResponse(rsp *http.Response) (*ApiKeysValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysDeleteResponse parses an HTTP response from a ApiKeysDeleteWithResponse call
func ParseApiKeysDeleteResponse(rsp *http.Response) (*ApiKeysDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysGetResponse parses an HTTP response from a ApiKeysGetWithResponse call
func ParseApiKeysGetResponse(rsp *http.Response) (*ApiKeysGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApiKeysUpdateResponse parses an HTTP response from a ApiKeysUpdateWithResponse call
func ParseApiKeysUpdateResponse(rsp *http.Response) (*ApiKeysUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiKeysUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthCheckEmailVerificationResponse parses an HTTP response from a AuthCheckEmailVerificationWithResponse call
func ParseAuthCheckEmailVerificationResponse(rsp *http.Response) (*AuthCheckEmailVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthCheckEmailVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthCsrfResponse parses an HTTP response from a AuthCsrfWithResponse call
func ParseAuthCsrfResponse(rsp *http.Response) (*AuthCsrfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthCsrfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CSRFTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthForgotPasswordResponse parses an HTTP response from a AuthForgotPasswordWithResponse call
func ParseAuthForgotPasswordResponse(rsp *http.Response) (*AuthForgotPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthForgotPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLoginResponse parses an HTTP response from a AuthLoginWithResponse call
func ParseAuthLoginResponse(rsp *http.Response) (*AuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthLogoutResponse parses an HTTP response from a AuthLogoutWithResponse call
func ParseAuthLogoutResponse(rsp *http.Response) (*AuthLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthMeResponse parses an HTTP response from a AuthMeWithResponse call
func ParseAuthMeResponse(rsp *http.Response) (*AuthMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaEnrollResponse parses an HTTP response from a MfaEnrollWithResponse call
func ParseMfaEnrollResponse(rsp *http.Response) (*MfaEnrollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaEnrollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrollResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaMethodsResponse parses an HTTP response from a MfaMethodsWithResponse call
func ParseMfaMethodsResponse(rsp *http.Response) (*MfaMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MethodsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaSendCodeResponse parses an HTTP response from a MfaSendCodeWithResponse call
func ParseMfaSendCodeResponse(rsp *http.Response) (*MfaSendCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaSendCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaUnenrollResponse parses an HTTP response from a MfaUnenrollWithResponse call
func ParseMfaUnenrollResponse(rsp *http.Response) (*MfaUnenrollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaUnenrollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMfaVerifyResponse parses an HTTP response from a MfaVerifyWithResponse call
func ParseMfaVerifyResponse(rsp *http.Response) (*MfaVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MfaVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthClientProviderCallbackResponse parses an HTTP response from a OauthClientProviderCallbackWithResponse call
func ParseOauthClientProviderCallbackResponse(rsp *http.Response) (*OauthClientProviderCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthClientProviderCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProviderCallbackResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthClientListProvidersResponse parses an HTTP response from a OauthClientListProvidersWithResponse call
func ParseOauthClientListProvidersResponse(rsp *http.Response) (*OauthClientListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthClientListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProvidersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthClientProviderAuthResponse parses an HTTP response from a OauthClientProviderAuthWithResponse call
func ParseOauthClientProviderAuthResponse(rsp *http.Response) (*OauthClientProviderAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthClientProviderAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysListResponse parses an HTTP response from a PasskeysListWithResponse call
func ParsePasskeysListResponse(rsp *http.Response) (*PasskeysListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysLoginBeginResponse parses an HTTP response from a PasskeysLoginBeginWithResponse call
func ParsePasskeysLoginBeginResponse(rsp *http.Response) (*PasskeysLoginBeginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysLoginBeginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisterBeginResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysLoginCompleteResponse parses an HTTP response from a PasskeysLoginCompleteWithResponse call
func ParsePasskeysLoginCompleteResponse(rsp *http.Response) (*PasskeysLoginCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysLoginCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginCompleteResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysRegisterBeginResponse parses an HTTP response from a PasskeysRegisterBeginWithResponse call
func ParsePasskeysRegisterBeginResponse(rsp *http.Response) (*PasskeysRegisterBeginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysRegisterBeginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisterBeginResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysRegisterCompleteResponse parses an HTTP response from a PasskeysRegisterCompleteWithResponse call
func ParsePasskeysRegisterCompleteResponse(rsp *http.Response) (*PasskeysRegisterCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysRegisterCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisteredPasskey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysDeleteResponse parses an HTTP response from a PasskeysDeleteWithResponse call
func ParsePasskeysDeleteResponse(rsp *http.Response) (*PasskeysDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasskeysUpdateResponse parses an HTTP response from a PasskeysUpdateWithResponse call
func ParsePasskeysUpdateResponse(rsp *http.Response) (*PasskeysUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeysUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessEmailResponse parses an HTTP response from a PasswordlessEmailWithResponse call
func ParsePasswordlessEmailResponse(rsp *http.Response) (*PasswordlessEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessMagicLinkResponse parses an HTTP response from a PasswordlessMagicLinkWithResponse call
func ParsePasswordlessMagicLinkResponse(rsp *http.Response) (*PasswordlessMagicLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessMagicLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MagicLinkResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessMethodsResponse parses an HTTP response from a PasswordlessMethodsWithResponse call
func ParsePasswordlessMethodsResponse(rsp *http.Response) (*PasswordlessMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MethodsResponseBody2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessSmsResponse parses an HTTP response from a PasswordlessSmsWithResponse call
func ParsePasswordlessSmsResponse(rsp *http.Response) (*PasswordlessSmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessSmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordlessVerifyResponse parses an HTTP response from a PasswordlessVerifyWithResponse call
func ParsePasswordlessVerifyResponse(rsp *http.Response) (*PasswordlessVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordlessVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRefreshTokenResponse parses an HTTP response from a AuthRefreshTokenWithResponse call
func ParseAuthRefreshTokenResponse(rsp *http.Response) (*AuthRefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRegisterResponse parses an HTTP response from a AuthRegisterWithResponse call
func ParseAuthRegisterResponse(rsp *http.Response) (*AuthRegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LoginResponse3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthResetPasswordResponse parses an HTTP response from a AuthResetPasswordWithResponse call
func ParseAuthResetPasswordResponse(rsp *http.Response) (*AuthResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthSendEmailVerificationResponse parses an HTTP response from a AuthSendEmailVerificationWithResponse call
func ParseAuthSendEmailVerificationResponse(rsp *http.Response) (*AuthSendEmailVerificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthSendEmailVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendEmailVerificationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoProviderCallbackResponse parses an HTTP response from a SsoProviderCallbackWithResponse call
func ParseSsoProviderCallbackResponse(rsp *http.Response) (*SsoProviderCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoProviderCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProviderCallbackResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoListIdentityProvidersResponse parses an HTTP response from a SsoListIdentityProvidersWithResponse call
func ParseSsoListIdentityProvidersResponse(rsp *http.Response) (*SsoListIdentityProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoListIdentityProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIdentityProvidersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoCreateIdentityProviderResponse parses an HTTP response from a SsoCreateIdentityProviderWithResponse call
func ParseSsoCreateIdentityProviderResponse(rsp *http.Response) (*SsoCreateIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoCreateIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IdentityProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoDeleteIdentityProviderResponse parses an HTTP response from a SsoDeleteIdentityProviderWithResponse call
func ParseSsoDeleteIdentityProviderResponse(rsp *http.Response) (*SsoDeleteIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoDeleteIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoGetIdentityProviderResponse parses an HTTP response from a SsoGetIdentityProviderWithResponse call
func ParseSsoGetIdentityProviderResponse(rsp *http.Response) (*SsoGetIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoGetIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoUpdateIdentityProviderResponse parses an HTTP response from a SsoUpdateIdentityProviderWithResponse call
func ParseSsoUpdateIdentityProviderResponse(rsp *http.Response) (*SsoUpdateIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoUpdateIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoListProvidersResponse parses an HTTP response from a SsoListProvidersWithResponse call
func ParseSsoListProvidersResponse(rsp *http.Response) (*SsoListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProvidersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoProviderAuthResponse parses an HTTP response from a SsoProviderAuthWithResponse call
func ParseSsoProviderAuthResponse(rsp *http.Response) (*SsoProviderAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoProviderAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoSamlAcsResponse parses an HTTP response from a SsoSamlAcsWithResponse call
func ParseSsoSamlAcsResponse(rsp *http.Response) (*SsoSamlAcsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoSamlAcsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSsoSamlMetadataResponse parses an HTTP response from a SsoSamlMetadataWithResponse call
func ParseSsoSamlMetadataResponse(rsp *http.Response) (*SsoSamlMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SsoSamlMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest SamlMetadataResponseBody
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseAuthVerifyEmailResponse parses an HTTP response from a AuthVerifyEmailWithResponse call
func ParseAuthVerifyEmailResponse(rsp *http.Response) (*AuthVerifyEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthVerifyEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailSendResponse parses an HTTP response from a EmailSendWithResponse call
func ParseEmailSendResponse(rsp *http.Response) (*EmailSendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailSendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailSendTemplateResponse parses an HTTP response from a EmailSendTemplateWithResponse call
func ParseEmailSendTemplateResponse(rsp *http.Response) (*EmailSendTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailSendTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailListTemplatesResponse parses an HTTP response from a EmailListTemplatesWithResponse call
func ParseEmailListTemplatesResponse(rsp *http.Response) (*EmailListTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTemplatesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailCreateTemplateResponse parses an HTTP response from a EmailCreateTemplateWithResponse call
func ParseEmailCreateTemplateResponse(rsp *http.Response) (*EmailCreateTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailCreateTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailGetTemplateByTypeResponse parses an HTTP response from a EmailGetTemplateByTypeWithResponse call
func ParseEmailGetTemplateByTypeResponse(rsp *http.Response) (*EmailGetTemplateByTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailGetTemplateByTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailDeleteTemplateResponse parses an HTTP response from a EmailDeleteTemplateWithResponse call
func ParseEmailDeleteTemplateResponse(rsp *http.Response) (*EmailDeleteTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailDeleteTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailGetTemplateResponse parses an HTTP response from a EmailGetTemplateWithResponse call
func ParseEmailGetTemplateResponse(rsp *http.Response) (*EmailGetTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailGetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailUpdateTemplateResponse parses an HTTP response from a EmailUpdateTemplateWithResponse call
func ParseEmailUpdateTemplateResponse(rsp *http.Response) (*EmailUpdateTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailUpdateTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmailTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderJwksResponse parses an HTTP response from a OauthProviderJwksWithResponse call
func ParseOauthProviderJwksResponse(rsp *http.Response) (*OauthProviderJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JwksResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderOidcConfigurationResponse parses an HTTP response from a OauthProviderOidcConfigurationWithResponse call
func ParseOauthProviderOidcConfigurationResponse(rsp *http.Response) (*OauthProviderOidcConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderOidcConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcConfigurationResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderAuthorizeResponse parses an HTTP response from a OauthProviderAuthorizeWithResponse call
func ParseOauthProviderAuthorizeResponse(rsp *http.Response) (*OauthProviderAuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderAuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderListClientsResponse parses an HTTP response from a OauthProviderListClientsWithResponse call
func ParseOauthProviderListClientsResponse(rsp *http.Response) (*OauthProviderListClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderListClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListClientsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderCreateClientResponse parses an HTTP response from a OauthProviderCreateClientWithResponse call
func ParseOauthProviderCreateClientResponse(rsp *http.Response) (*OauthProviderCreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderCreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OAuthClientWithSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderDeleteClientResponse parses an HTTP response from a OauthProviderDeleteClientWithResponse call
func ParseOauthProviderDeleteClientResponse(rsp *http.Response) (*OauthProviderDeleteClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderDeleteClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderGetClientResponse parses an HTTP response from a OauthProviderGetClientWithResponse call
func ParseOauthProviderGetClientResponse(rsp *http.Response) (*OauthProviderGetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderGetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderUpdateClientResponse parses an HTTP response from a OauthProviderUpdateClientWithResponse call
func ParseOauthProviderUpdateClientResponse(rsp *http.Response) (*OauthProviderUpdateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderUpdateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderRotateClientSecretResponse parses an HTTP response from a OauthProviderRotateClientSecretWithResponse call
func ParseOauthProviderRotateClientSecretResponse(rsp *http.Response) (*OauthProviderRotateClientSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderRotateClientSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RotateClientSecretResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderConsentResponse parses an HTTP response from a OauthProviderConsentWithResponse call
func ParseOauthProviderConsentResponse(rsp *http.Response) (*OauthProviderConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest ConsentResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderIntrospectResponse parses an HTTP response from a OauthProviderIntrospectWithResponse call
func ParseOauthProviderIntrospectResponse(rsp *http.Response) (*OauthProviderIntrospectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderIntrospectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntrospectResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderRevokeResponse parses an HTTP response from a OauthProviderRevokeWithResponse call
func ParseOauthProviderRevokeResponse(rsp *http.Response) (*OauthProviderRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderListScopesResponse parses an HTTP response from a OauthProviderListScopesWithResponse call
func ParseOauthProviderListScopesResponse(rsp *http.Response) (*OauthProviderListScopesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderListScopesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListScopesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderCreateScopeResponse parses an HTTP response from a OauthProviderCreateScopeWithResponse call
func ParseOauthProviderCreateScopeResponse(rsp *http.Response) (*OauthProviderCreateScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderCreateScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OAuthScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderDeleteScopeResponse parses an HTTP response from a OauthProviderDeleteScopeWithResponse call
func ParseOauthProviderDeleteScopeResponse(rsp *http.Response) (*OauthProviderDeleteScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderDeleteScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderGetScopeResponse parses an HTTP response from a OauthProviderGetScopeWithResponse call
func ParseOauthProviderGetScopeResponse(rsp *http.Response) (*OauthProviderGetScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderGetScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderUpdateScopeResponse parses an HTTP response from a OauthProviderUpdateScopeWithResponse call
func ParseOauthProviderUpdateScopeResponse(rsp *http.Response) (*OauthProviderUpdateScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderUpdateScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthScopeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderTokenResponse parses an HTTP response from a OauthProviderTokenWithResponse call
func ParseOauthProviderTokenResponse(rsp *http.Response) (*OauthProviderTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOauthProviderUserinfoResponse parses an HTTP response from a OauthProviderUserinfoWithResponse call
func ParseOauthProviderUserinfoResponse(rsp *http.Response) (*OauthProviderUserinfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthProviderUserinfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserinfoResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsListResponse parses an HTTP response from a OrganizationsListWithResponse call
func ParseOrganizationsListResponse(rsp *http.Response) (*OrganizationsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsCreateResponse parses an HTTP response from a OrganizationsCreateWithResponse call
func ParseOrganizationsCreateResponse(rsp *http.Response) (*OrganizationsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsDeleteResponse parses an HTTP response from a OrganizationsDeleteWithResponse call
func ParseOrganizationsDeleteResponse(rsp *http.Response) (*OrganizationsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsGetResponse parses an HTTP response from a OrganizationsGetWithResponse call
func ParseOrganizationsGetResponse(rsp *http.Response) (*OrganizationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsUpdateResponse parses an HTTP response from a OrganizationsUpdateWithResponse call
func ParseOrganizationsUpdateResponse(rsp *http.Response) (*OrganizationsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsListFeaturesResponse parses an HTTP response from a OrganizationsListFeaturesWithResponse call
func ParseOrganizationsListFeaturesResponse(rsp *http.Response) (*OrganizationsListFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsListFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFeaturesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsEnableFeatureResponse parses an HTTP response from a OrganizationsEnableFeatureWithResponse call
func ParseOrganizationsEnableFeatureResponse(rsp *http.Response) (*OrganizationsEnableFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsEnableFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsDisableFeatureResponse parses an HTTP response from a OrganizationsDisableFeatureWithResponse call
func ParseOrganizationsDisableFeatureResponse(rsp *http.Response) (*OrganizationsDisableFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsDisableFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsListMembersResponse parses an HTTP response from a OrganizationsListMembersWithResponse call
func ParseOrganizationsListMembersResponse(rsp *http.Response) (*OrganizationsListMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsListMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMembersResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsAddMemberResponse parses an HTTP response from a OrganizationsAddMemberWithResponse call
func ParseOrganizationsAddMemberResponse(rsp *http.Response) (*OrganizationsAddMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsAddMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsRemoveMemberResponse parses an HTTP response from a OrganizationsRemoveMemberWithResponse call
func ParseOrganizationsRemoveMemberResponse(rsp *http.Response) (*OrganizationsRemoveMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsRemoveMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrganizationsUpdateMemberResponse parses an HTTP response from a OrganizationsUpdateMemberWithResponse call
func ParseOrganizationsUpdateMemberResponse(rsp *http.Response) (*OrganizationsUpdateMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationsUpdateMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacListPermissionsResponse parses an HTTP response from a RbacListPermissionsWithResponse call
func ParseRbacListPermissionsResponse(rsp *http.Response) (*RbacListPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacListPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacCreatePermissionResponse parses an HTTP response from a RbacCreatePermissionWithResponse call
func ParseRbacCreatePermissionResponse(rsp *http.Response) (*RbacCreatePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCreatePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PermissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacDeletePermissionResponse parses an HTTP response from a RbacDeletePermissionWithResponse call
func ParseRbacDeletePermissionResponse(rsp *http.Response) (*RbacDeletePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacDeletePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacGetPermissionResponse parses an HTTP response from a RbacGetPermissionWithResponse call
func ParseRbacGetPermissionResponse(rsp *http.Response) (*RbacGetPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacGetPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacUpdatePermissionResponse parses an HTTP response from a RbacUpdatePermissionWithResponse call
func ParseRbacUpdatePermissionResponse(rsp *http.Response) (*RbacUpdatePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacUpdatePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacListRolesResponse parses an HTTP response from a RbacListRolesWithResponse call
func ParseRbacListRolesResponse(rsp *http.Response) (*RbacListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRolesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacCreateRoleResponse parses an HTTP response from a RbacCreateRoleWithResponse call
func ParseRbacCreateRoleResponse(rsp *http.Response) (*RbacCreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacCreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacDeleteRoleResponse parses an HTTP response from a RbacDeleteRoleWithResponse call
func ParseRbacDeleteRoleResponse(rsp *http.Response) (*RbacDeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacDeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacGetRoleResponse parses an HTTP response from a RbacGetRoleWithResponse call
func ParseRbacGetRoleResponse(rsp *http.Response) (*RbacGetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacGetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacUpdateRoleResponse parses an HTTP response from a RbacUpdateRoleWithResponse call
func ParseRbacUpdateRoleResponse(rsp *http.Response) (*RbacUpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacUpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacListRolePermissionsResponse parses an HTTP response from a RbacListRolePermissionsWithResponse call
func ParseRbacListRolePermissionsResponse(rsp *http.Response) (*RbacListRolePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacListRolePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRolePermissionsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacAddRolePermissionResponse parses an HTTP response from a RbacAddRolePermissionWithResponse call
func ParseRbacAddRolePermissionResponse(rsp *http.Response) (*RbacAddRolePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacAddRolePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRbacRemoveRolePermissionResponse parses an HTTP response from a RbacRemoveRolePermissionWithResponse call
func ParseRbacRemoveRolePermissionResponse(rsp *http.Response) (*RbacRemoveRolePermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RbacRemoveRolePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersListResponse parses an HTTP response from a UsersListWithResponse call
func ParseUsersListResponse(rsp *http.Response) (*UsersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody4
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersCreateResponse parses an HTTP response from a UsersCreateWithResponse call
func ParseUsersCreateResponse(rsp *http.Response) (*UsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersUpdateMeResponse parses an HTTP response from a UsersUpdateMeWithResponse call
func ParseUsersUpdateMeResponse(rsp *http.Response) (*UsersUpdateMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdateMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersUpdatePasswordResponse parses an HTTP response from a UsersUpdatePasswordWithResponse call
func ParseUsersUpdatePasswordResponse(rsp *http.Response) (*UsersUpdatePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdatePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersGetSessionsResponse parses an HTTP response from a UsersGetSessionsWithResponse call
func ParseUsersGetSessionsResponse(rsp *http.Response) (*UsersGetSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersGetSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersDeleteSessionResponse parses an HTTP response from a UsersDeleteSessionWithResponse call
func ParseUsersDeleteSessionResponse(rsp *http.Response) (*UsersDeleteSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersDeleteResponse parses an HTTP response from a UsersDeleteWithResponse call
func ParseUsersDeleteResponse(rsp *http.Response) (*UsersDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersGetResponse parses an HTTP response from a UsersGetWithResponse call
func ParseUsersGetResponse(rsp *http.Response) (*UsersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersUpdateResponse parses an HTTP response from a UsersUpdateWithResponse call
func ParseUsersUpdateResponse(rsp *http.Response) (*UsersUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUsersGetOrganizationsResponse parses an HTTP response from a UsersGetOrganizationsWithResponse call
func ParseUsersGetOrganizationsResponse(rsp *http.Response) (*UsersGetOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersGetOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOrganizationsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksListResponse parses an HTTP response from a WebhooksListWithResponse call
func ParseWebhooksListResponse(rsp *http.Response) (*WebhooksListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponseBody5
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksCreateResponse parses an HTTP response from a WebhooksCreateWithResponse call
func ParseWebhooksCreateResponse(rsp *http.Response) (*WebhooksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksReceiveResponse parses an HTTP response from a WebhooksReceiveWithResponse call
func ParseWebhooksReceiveResponse(rsp *http.Response) (*WebhooksReceiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksReceiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksTriggerEventResponse parses an HTTP response from a WebhooksTriggerEventWithResponse call
func ParseWebhooksTriggerEventResponse(rsp *http.Response) (*WebhooksTriggerEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksTriggerEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksDeleteResponse parses an HTTP response from a WebhooksDeleteWithResponse call
func ParseWebhooksDeleteResponse(rsp *http.Response) (*WebhooksDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksGetResponse parses an HTTP response from a WebhooksGetWithResponse call
func ParseWebhooksGetResponse(rsp *http.Response) (*WebhooksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksUpdateResponse parses an HTTP response from a WebhooksUpdateWithResponse call
func ParseWebhooksUpdateResponse(rsp *http.Response) (*WebhooksUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksListEventsResponse parses an HTTP response from a WebhooksListEventsWithResponse call
func ParseWebhooksListEventsResponse(rsp *http.Response) (*WebhooksListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEventsResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebhooksReplayEventResponse parses an HTTP response from a WebhooksReplayEventWithResponse call
func ParseWebhooksReplayEventResponse(rsp *http.Response) (*WebhooksReplayEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhooksReplayEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
