/**
 * Generated by orval v7.7.0 🍺
 * Do not edit manually.
 * Frank Authentication Server
 * A comprehensive authentication server with OAuth2, MFA, Passkeys, SSO, and more
 * OpenAPI spec version: 1.0.0
 */
import type {
  AuthForgotPasswordParams,
  BadRequestError,
  CSRFTokenResponse,
  ConflictError,
  ForbiddenError,
  ForgotPasswordRequest,
  InternalServerError,
  LoginRequest,
  LoginResponse2,
  LoginResponse3,
  NotFoundError,
  RefreshTokenRequest,
  RefreshTokenResponse,
  RegisterRequest,
  ResetPasswordRequest,
  SendResponseBody,
  UnauthorizedError,
  User,
  VerifyEmailRequest,
} from "../../model";

import { customInstance } from "../../mutator/custom-instance";

/**
 * Generates a CSRF token
 * @summary csrf auth
 */
export type authCsrfResponse200 = {
  data: CSRFTokenResponse;
  status: 200;
};

export type authCsrfResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authCsrfResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authCsrfResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authCsrfResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authCsrfResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authCsrfResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authCsrfResponseComposite =
  | authCsrfResponse200
  | authCsrfResponse400
  | authCsrfResponse401
  | authCsrfResponse403
  | authCsrfResponse404
  | authCsrfResponse409
  | authCsrfResponse500;

export type authCsrfResponse = authCsrfResponseComposite & {
  headers: Headers;
};

export const getAuthCsrfUrl = () => {
  return `/v1/auth/csrf-token`;
};

export const authCsrf = async (
  options?: RequestInit,
): Promise<authCsrfResponse> => {
  return customInstance<authCsrfResponse>(getAuthCsrfUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Initiate password reset process
 * @summary forgot_password auth
 */
export type authForgotPasswordResponse202 = {
  data: SendResponseBody;
  status: 202;
};

export type authForgotPasswordResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authForgotPasswordResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authForgotPasswordResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authForgotPasswordResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authForgotPasswordResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authForgotPasswordResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authForgotPasswordResponseComposite =
  | authForgotPasswordResponse202
  | authForgotPasswordResponse400
  | authForgotPasswordResponse401
  | authForgotPasswordResponse403
  | authForgotPasswordResponse404
  | authForgotPasswordResponse409
  | authForgotPasswordResponse500;

export type authForgotPasswordResponse = authForgotPasswordResponseComposite & {
  headers: Headers;
};

export const getAuthForgotPasswordUrl = (params?: AuthForgotPasswordParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/auth/forgot-password?${stringifiedParams}`
    : `/v1/auth/forgot-password`;
};

export const authForgotPassword = async (
  forgotPasswordRequest: ForgotPasswordRequest,
  params?: AuthForgotPasswordParams,
  options?: RequestInit,
): Promise<authForgotPasswordResponse> => {
  return customInstance<authForgotPasswordResponse>(
    getAuthForgotPasswordUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(forgotPasswordRequest),
    },
  );
};

/**
 * Authenticate user with email and password
 * @summary login auth
 */
export type authLoginResponse200 = {
  data: LoginResponse2;
  status: 200;
};

export type authLoginResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authLoginResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authLoginResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authLoginResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authLoginResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authLoginResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authLoginResponseComposite =
  | authLoginResponse200
  | authLoginResponse400
  | authLoginResponse401
  | authLoginResponse403
  | authLoginResponse404
  | authLoginResponse409
  | authLoginResponse500;

export type authLoginResponse = authLoginResponseComposite & {
  headers: Headers;
};

export const getAuthLoginUrl = () => {
  return `/v1/auth/login`;
};

export const authLogin = async (
  loginRequest: LoginRequest,
  options?: RequestInit,
): Promise<authLoginResponse> => {
  return customInstance<authLoginResponse>(getAuthLoginUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(loginRequest),
  });
};

/**
 * Log out the current user
 * @summary logout auth
 */
export type authLogoutResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type authLogoutResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authLogoutResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authLogoutResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authLogoutResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authLogoutResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authLogoutResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authLogoutResponseComposite =
  | authLogoutResponse200
  | authLogoutResponse400
  | authLogoutResponse401
  | authLogoutResponse403
  | authLogoutResponse404
  | authLogoutResponse409
  | authLogoutResponse500;

export type authLogoutResponse = authLogoutResponseComposite & {
  headers: Headers;
};

export const getAuthLogoutUrl = () => {
  return `/v1/auth/logout`;
};

export const authLogout = async (
  options?: RequestInit,
): Promise<authLogoutResponse> => {
  return customInstance<authLogoutResponse>(getAuthLogoutUrl(), {
    ...options,
    method: "POST",
  });
};

/**
 * Get current user info
 * @summary me auth
 */
export type authMeResponse200 = {
  data: User;
  status: 200;
};

export type authMeResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authMeResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authMeResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authMeResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authMeResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authMeResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authMeResponseComposite =
  | authMeResponse200
  | authMeResponse400
  | authMeResponse401
  | authMeResponse403
  | authMeResponse404
  | authMeResponse409
  | authMeResponse500;

export type authMeResponse = authMeResponseComposite & {
  headers: Headers;
};

export const getAuthMeUrl = () => {
  return `/v1/auth/me`;
};

export const authMe = async (
  options?: RequestInit,
): Promise<authMeResponse> => {
  return customInstance<authMeResponse>(getAuthMeUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Refresh an access token
 * @summary refresh_token auth
 */
export type authRefreshTokenResponse200 = {
  data: RefreshTokenResponse;
  status: 200;
};

export type authRefreshTokenResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authRefreshTokenResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authRefreshTokenResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authRefreshTokenResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authRefreshTokenResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authRefreshTokenResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authRefreshTokenResponseComposite =
  | authRefreshTokenResponse200
  | authRefreshTokenResponse400
  | authRefreshTokenResponse401
  | authRefreshTokenResponse403
  | authRefreshTokenResponse404
  | authRefreshTokenResponse409
  | authRefreshTokenResponse500;

export type authRefreshTokenResponse = authRefreshTokenResponseComposite & {
  headers: Headers;
};

export const getAuthRefreshTokenUrl = () => {
  return `/v1/auth/refresh`;
};

export const authRefreshToken = async (
  refreshTokenRequest: RefreshTokenRequest,
  options?: RequestInit,
): Promise<authRefreshTokenResponse> => {
  return customInstance<authRefreshTokenResponse>(getAuthRefreshTokenUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(refreshTokenRequest),
  });
};

/**
 * Register a new user
 * @summary register auth
 */
export type authRegisterResponse201 = {
  data: LoginResponse3;
  status: 201;
};

export type authRegisterResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authRegisterResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authRegisterResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authRegisterResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authRegisterResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authRegisterResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authRegisterResponseComposite =
  | authRegisterResponse201
  | authRegisterResponse400
  | authRegisterResponse401
  | authRegisterResponse403
  | authRegisterResponse404
  | authRegisterResponse409
  | authRegisterResponse500;

export type authRegisterResponse = authRegisterResponseComposite & {
  headers: Headers;
};

export const getAuthRegisterUrl = () => {
  return `/v1/auth/register`;
};

export const authRegister = async (
  registerRequest: RegisterRequest,
  options?: RequestInit,
): Promise<authRegisterResponse> => {
  return customInstance<authRegisterResponse>(getAuthRegisterUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(registerRequest),
  });
};

/**
 * Reset password using token
 * @summary reset_password auth
 */
export type authResetPasswordResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type authResetPasswordResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authResetPasswordResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authResetPasswordResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authResetPasswordResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authResetPasswordResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authResetPasswordResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authResetPasswordResponseComposite =
  | authResetPasswordResponse200
  | authResetPasswordResponse400
  | authResetPasswordResponse401
  | authResetPasswordResponse403
  | authResetPasswordResponse404
  | authResetPasswordResponse409
  | authResetPasswordResponse500;

export type authResetPasswordResponse = authResetPasswordResponseComposite & {
  headers: Headers;
};

export const getAuthResetPasswordUrl = () => {
  return `/v1/auth/reset-password`;
};

export const authResetPassword = async (
  resetPasswordRequest: ResetPasswordRequest,
  options?: RequestInit,
): Promise<authResetPasswordResponse> => {
  return customInstance<authResetPasswordResponse>(getAuthResetPasswordUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(resetPasswordRequest),
  });
};

/**
 * Verify email using token
 * @summary verify_email auth
 */
export type authVerifyEmailResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type authVerifyEmailResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authVerifyEmailResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authVerifyEmailResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authVerifyEmailResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authVerifyEmailResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authVerifyEmailResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authVerifyEmailResponseComposite =
  | authVerifyEmailResponse200
  | authVerifyEmailResponse400
  | authVerifyEmailResponse401
  | authVerifyEmailResponse403
  | authVerifyEmailResponse404
  | authVerifyEmailResponse409
  | authVerifyEmailResponse500;

export type authVerifyEmailResponse = authVerifyEmailResponseComposite & {
  headers: Headers;
};

export const getAuthVerifyEmailUrl = () => {
  return `/v1/auth/verify-email`;
};

export const authVerifyEmail = async (
  verifyEmailRequest: VerifyEmailRequest,
  options?: RequestInit,
): Promise<authVerifyEmailResponse> => {
  return customInstance<authVerifyEmailResponse>(getAuthVerifyEmailUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(verifyEmailRequest),
  });
};
