/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Frank Authentication Server
 * A comprehensive authentication server with OAuth2, MFA, Passkeys, SSO, and more
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BadRequestError,
  CreateRequestBody3,
  ForbiddenError,
  InternalServerError,
  ListEventsResponseBody,
  ListResponseBody5,
  NotFoundError,
  SendResponseBody,
  TriggerEventRequestBody,
  UnauthorizedError,
  UpdateRequestBody5,
  WebhookEventResponse,
  WebhookResponse,
  WebhookSecretResponse,
  WebhooksListEventsParams,
  WebhooksListParams,
} from "../../model";

import { customInstance } from "../../mutator/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List webhooks
 * @summary list webhooks
 */
export type webhooksListResponse200 = {
  data: ListResponseBody5;
  status: 200;
};

export type webhooksListResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksListResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksListResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksListResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksListResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksListResponseComposite =
  | webhooksListResponse200
  | webhooksListResponse400
  | webhooksListResponse401
  | webhooksListResponse403
  | webhooksListResponse404
  | webhooksListResponse500;

export type webhooksListResponse = webhooksListResponseComposite & {
  headers: Headers;
};

export const getWebhooksListUrl = (params?: WebhooksListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/webhooks?${stringifiedParams}`
    : `/v1/webhooks`;
};

export const webhooksList = async (
  params?: WebhooksListParams,
  options?: RequestInit,
): Promise<webhooksListResponse> => {
  return customInstance<webhooksListResponse>(getWebhooksListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getWebhooksListQueryKey = (params?: WebhooksListParams) => {
  return [`/v1/webhooks`, ...(params ? [params] : [])] as const;
};

export const getWebhooksListInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getWebhooksListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof webhooksList>>> = ({
    signal,
  }) => webhooksList(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof webhooksList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WebhooksListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksList>>
>;
export type WebhooksListInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useWebhooksListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params: undefined | WebhooksListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksList>>,
          TError,
          Awaited<ReturnType<typeof webhooksList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksList>>,
          TError,
          Awaited<ReturnType<typeof webhooksList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list webhooks
 */

export function useWebhooksListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWebhooksListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getWebhooksListQueryOptions = <
  TData = Awaited<ReturnType<typeof webhooksList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getWebhooksListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof webhooksList>>> = ({
    signal,
  }) => webhooksList(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof webhooksList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WebhooksListQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksList>>
>;
export type WebhooksListQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useWebhooksList<
  TData = Awaited<ReturnType<typeof webhooksList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params: undefined | WebhooksListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksList>>,
          TError,
          Awaited<ReturnType<typeof webhooksList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksList<
  TData = Awaited<ReturnType<typeof webhooksList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksList>>,
          TError,
          Awaited<ReturnType<typeof webhooksList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksList<
  TData = Awaited<ReturnType<typeof webhooksList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list webhooks
 */

export function useWebhooksList<
  TData = Awaited<ReturnType<typeof webhooksList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  params?: WebhooksListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWebhooksListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new webhook
 * @summary create webhooks
 */
export type webhooksCreateResponse201 = {
  data: WebhookSecretResponse;
  status: 201;
};

export type webhooksCreateResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksCreateResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksCreateResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksCreateResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksCreateResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksCreateResponseComposite =
  | webhooksCreateResponse201
  | webhooksCreateResponse400
  | webhooksCreateResponse401
  | webhooksCreateResponse403
  | webhooksCreateResponse404
  | webhooksCreateResponse500;

export type webhooksCreateResponse = webhooksCreateResponseComposite & {
  headers: Headers;
};

export const getWebhooksCreateUrl = () => {
  return `/v1/webhooks`;
};

export const webhooksCreate = async (
  createRequestBody3: CreateRequestBody3,
  options?: RequestInit,
): Promise<webhooksCreateResponse> => {
  return customInstance<webhooksCreateResponse>(getWebhooksCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createRequestBody3),
  });
};

export const getWebhooksCreateMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksCreate>>,
    TError,
    { data: CreateRequestBody3 },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksCreate>>,
  TError,
  { data: CreateRequestBody3 },
  TContext
> => {
  const mutationKey = ["webhooksCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksCreate>>,
    { data: CreateRequestBody3 }
  > = (props) => {
    const { data } = props ?? {};

    return webhooksCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksCreate>>
>;
export type WebhooksCreateMutationBody = CreateRequestBody3;
export type WebhooksCreateMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary create webhooks
 */
export const useWebhooksCreate = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksCreate>>,
    TError,
    { data: CreateRequestBody3 },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof webhooksCreate>>,
  TError,
  { data: CreateRequestBody3 },
  TContext
> => {
  const mutationOptions = getWebhooksCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Receive webhook callbacks from external sources
 * @summary receive webhooks
 */
export type webhooksReceiveResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type webhooksReceiveResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksReceiveResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksReceiveResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksReceiveResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksReceiveResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksReceiveResponseComposite =
  | webhooksReceiveResponse200
  | webhooksReceiveResponse400
  | webhooksReceiveResponse401
  | webhooksReceiveResponse403
  | webhooksReceiveResponse404
  | webhooksReceiveResponse500;

export type webhooksReceiveResponse = webhooksReceiveResponseComposite & {
  headers: Headers;
};

export const getWebhooksReceiveUrl = (id: string) => {
  return `/v1/webhooks/external/receive/${id}`;
};

export const webhooksReceive = async (
  id: string,
  options?: RequestInit,
): Promise<webhooksReceiveResponse> => {
  return customInstance<webhooksReceiveResponse>(getWebhooksReceiveUrl(id), {
    ...options,
    method: "POST",
  });
};

export const getWebhooksReceiveMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksReceive>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksReceive>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["webhooksReceive"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksReceive>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return webhooksReceive(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksReceiveMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksReceive>>
>;

export type WebhooksReceiveMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary receive webhooks
 */
export const useWebhooksReceive = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksReceive>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof webhooksReceive>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getWebhooksReceiveMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Manually trigger a webhook event
 * @summary trigger_event webhooks
 */
export type webhooksTriggerEventResponse200 = {
  data: WebhookEventResponse;
  status: 200;
};

export type webhooksTriggerEventResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksTriggerEventResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksTriggerEventResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksTriggerEventResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksTriggerEventResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksTriggerEventResponseComposite =
  | webhooksTriggerEventResponse200
  | webhooksTriggerEventResponse400
  | webhooksTriggerEventResponse401
  | webhooksTriggerEventResponse403
  | webhooksTriggerEventResponse404
  | webhooksTriggerEventResponse500;

export type webhooksTriggerEventResponse =
  webhooksTriggerEventResponseComposite & {
    headers: Headers;
  };

export const getWebhooksTriggerEventUrl = () => {
  return `/v1/webhooks/trigger`;
};

export const webhooksTriggerEvent = async (
  triggerEventRequestBody: TriggerEventRequestBody,
  options?: RequestInit,
): Promise<webhooksTriggerEventResponse> => {
  return customInstance<webhooksTriggerEventResponse>(
    getWebhooksTriggerEventUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(triggerEventRequestBody),
    },
  );
};

export const getWebhooksTriggerEventMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksTriggerEvent>>,
    TError,
    { data: TriggerEventRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksTriggerEvent>>,
  TError,
  { data: TriggerEventRequestBody },
  TContext
> => {
  const mutationKey = ["webhooksTriggerEvent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksTriggerEvent>>,
    { data: TriggerEventRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return webhooksTriggerEvent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksTriggerEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksTriggerEvent>>
>;
export type WebhooksTriggerEventMutationBody = TriggerEventRequestBody;
export type WebhooksTriggerEventMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary trigger_event webhooks
 */
export const useWebhooksTriggerEvent = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksTriggerEvent>>,
    TError,
    { data: TriggerEventRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof webhooksTriggerEvent>>,
  TError,
  { data: TriggerEventRequestBody },
  TContext
> => {
  const mutationOptions = getWebhooksTriggerEventMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Delete webhook
 * @summary delete webhooks
 */
export type webhooksDeleteResponse204 = {
  data: void;
  status: 204;
};

export type webhooksDeleteResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksDeleteResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksDeleteResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksDeleteResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksDeleteResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksDeleteResponseComposite =
  | webhooksDeleteResponse204
  | webhooksDeleteResponse400
  | webhooksDeleteResponse401
  | webhooksDeleteResponse403
  | webhooksDeleteResponse404
  | webhooksDeleteResponse500;

export type webhooksDeleteResponse = webhooksDeleteResponseComposite & {
  headers: Headers;
};

export const getWebhooksDeleteUrl = (id: string) => {
  return `/v1/webhooks/${id}`;
};

export const webhooksDelete = async (
  id: string,
  options?: RequestInit,
): Promise<webhooksDeleteResponse> => {
  return customInstance<webhooksDeleteResponse>(getWebhooksDeleteUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getWebhooksDeleteMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["webhooksDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return webhooksDelete(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksDelete>>
>;

export type WebhooksDeleteMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary delete webhooks
 */
export const useWebhooksDelete = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof webhooksDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getWebhooksDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get webhook by ID
 * @summary get webhooks
 */
export type webhooksGetResponse200 = {
  data: WebhookResponse;
  status: 200;
};

export type webhooksGetResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksGetResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksGetResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksGetResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksGetResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksGetResponseComposite =
  | webhooksGetResponse200
  | webhooksGetResponse400
  | webhooksGetResponse401
  | webhooksGetResponse403
  | webhooksGetResponse404
  | webhooksGetResponse500;

export type webhooksGetResponse = webhooksGetResponseComposite & {
  headers: Headers;
};

export const getWebhooksGetUrl = (id: string) => {
  return `/v1/webhooks/${id}`;
};

export const webhooksGet = async (
  id: string,
  options?: RequestInit,
): Promise<webhooksGetResponse> => {
  return customInstance<webhooksGetResponse>(getWebhooksGetUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getWebhooksGetQueryKey = (id: string) => {
  return [`/v1/webhooks/${id}`] as const;
};

export const getWebhooksGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getWebhooksGetQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof webhooksGet>>> = ({
    signal,
  }) => webhooksGet(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof webhooksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WebhooksGetInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksGet>>
>;
export type WebhooksGetInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useWebhooksGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksGet>>,
          TError,
          Awaited<ReturnType<typeof webhooksGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksGet>>,
          TError,
          Awaited<ReturnType<typeof webhooksGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get webhooks
 */

export function useWebhooksGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWebhooksGetInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getWebhooksGetQueryOptions = <
  TData = Awaited<ReturnType<typeof webhooksGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getWebhooksGetQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof webhooksGet>>> = ({
    signal,
  }) => webhooksGet(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof webhooksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WebhooksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksGet>>
>;
export type WebhooksGetQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useWebhooksGet<
  TData = Awaited<ReturnType<typeof webhooksGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksGet>>,
          TError,
          Awaited<ReturnType<typeof webhooksGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksGet<
  TData = Awaited<ReturnType<typeof webhooksGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksGet>>,
          TError,
          Awaited<ReturnType<typeof webhooksGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksGet<
  TData = Awaited<ReturnType<typeof webhooksGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get webhooks
 */

export function useWebhooksGet<
  TData = Awaited<ReturnType<typeof webhooksGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof webhooksGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWebhooksGetQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update webhook
 * @summary update webhooks
 */
export type webhooksUpdateResponse200 = {
  data: WebhookResponse;
  status: 200;
};

export type webhooksUpdateResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksUpdateResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksUpdateResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksUpdateResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksUpdateResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksUpdateResponseComposite =
  | webhooksUpdateResponse200
  | webhooksUpdateResponse400
  | webhooksUpdateResponse401
  | webhooksUpdateResponse403
  | webhooksUpdateResponse404
  | webhooksUpdateResponse500;

export type webhooksUpdateResponse = webhooksUpdateResponseComposite & {
  headers: Headers;
};

export const getWebhooksUpdateUrl = (id: string) => {
  return `/v1/webhooks/${id}`;
};

export const webhooksUpdate = async (
  id: string,
  updateRequestBody5: UpdateRequestBody5,
  options?: RequestInit,
): Promise<webhooksUpdateResponse> => {
  return customInstance<webhooksUpdateResponse>(getWebhooksUpdateUrl(id), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateRequestBody5),
  });
};

export const getWebhooksUpdateMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksUpdate>>,
    TError,
    { id: string; data: UpdateRequestBody5 },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksUpdate>>,
  TError,
  { id: string; data: UpdateRequestBody5 },
  TContext
> => {
  const mutationKey = ["webhooksUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksUpdate>>,
    { id: string; data: UpdateRequestBody5 }
  > = (props) => {
    const { id, data } = props ?? {};

    return webhooksUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksUpdate>>
>;
export type WebhooksUpdateMutationBody = UpdateRequestBody5;
export type WebhooksUpdateMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary update webhooks
 */
export const useWebhooksUpdate = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksUpdate>>,
    TError,
    { id: string; data: UpdateRequestBody5 },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof webhooksUpdate>>,
  TError,
  { id: string; data: UpdateRequestBody5 },
  TContext
> => {
  const mutationOptions = getWebhooksUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * List webhook events
 * @summary list_events webhooks
 */
export type webhooksListEventsResponse200 = {
  data: ListEventsResponseBody;
  status: 200;
};

export type webhooksListEventsResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksListEventsResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksListEventsResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksListEventsResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksListEventsResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksListEventsResponseComposite =
  | webhooksListEventsResponse200
  | webhooksListEventsResponse400
  | webhooksListEventsResponse401
  | webhooksListEventsResponse403
  | webhooksListEventsResponse404
  | webhooksListEventsResponse500;

export type webhooksListEventsResponse = webhooksListEventsResponseComposite & {
  headers: Headers;
};

export const getWebhooksListEventsUrl = (
  id: string,
  params?: WebhooksListEventsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/webhooks/${id}/events?${stringifiedParams}`
    : `/v1/webhooks/${id}/events`;
};

export const webhooksListEvents = async (
  id: string,
  params?: WebhooksListEventsParams,
  options?: RequestInit,
): Promise<webhooksListEventsResponse> => {
  return customInstance<webhooksListEventsResponse>(
    getWebhooksListEventsUrl(id, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getWebhooksListEventsQueryKey = (
  id: string,
  params?: WebhooksListEventsParams,
) => {
  return [`/v1/webhooks/${id}/events`, ...(params ? [params] : [])] as const;
};

export const getWebhooksListEventsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksListEvents>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getWebhooksListEventsQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof webhooksListEvents>>
  > = ({ signal }) =>
    webhooksListEvents(id, params, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof webhooksListEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WebhooksListEventsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksListEvents>>
>;
export type WebhooksListEventsInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useWebhooksListEventsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksListEvents>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params: undefined | WebhooksListEventsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksListEvents>>,
          TError,
          Awaited<ReturnType<typeof webhooksListEvents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksListEventsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksListEvents>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksListEvents>>,
          TError,
          Awaited<ReturnType<typeof webhooksListEvents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksListEventsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksListEvents>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list_events webhooks
 */

export function useWebhooksListEventsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof webhooksListEvents>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWebhooksListEventsInfiniteQueryOptions(
    id,
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getWebhooksListEventsQueryOptions = <
  TData = Awaited<ReturnType<typeof webhooksListEvents>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getWebhooksListEventsQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof webhooksListEvents>>
  > = ({ signal }) =>
    webhooksListEvents(id, params, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof webhooksListEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WebhooksListEventsQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksListEvents>>
>;
export type WebhooksListEventsQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useWebhooksListEvents<
  TData = Awaited<ReturnType<typeof webhooksListEvents>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params: undefined | WebhooksListEventsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksListEvents>>,
          TError,
          Awaited<ReturnType<typeof webhooksListEvents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksListEvents<
  TData = Awaited<ReturnType<typeof webhooksListEvents>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksListEvents>>,
          TError,
          Awaited<ReturnType<typeof webhooksListEvents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWebhooksListEvents<
  TData = Awaited<ReturnType<typeof webhooksListEvents>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list_events webhooks
 */

export function useWebhooksListEvents<
  TData = Awaited<ReturnType<typeof webhooksListEvents>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(
  id: string,
  params?: WebhooksListEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksListEvents>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getWebhooksListEventsQueryOptions(id, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Replay a webhook event
 * @summary replay_event webhooks
 */
export type webhooksReplayEventResponse200 = {
  data: WebhookEventResponse;
  status: 200;
};

export type webhooksReplayEventResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type webhooksReplayEventResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type webhooksReplayEventResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type webhooksReplayEventResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type webhooksReplayEventResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type webhooksReplayEventResponseComposite =
  | webhooksReplayEventResponse200
  | webhooksReplayEventResponse400
  | webhooksReplayEventResponse401
  | webhooksReplayEventResponse403
  | webhooksReplayEventResponse404
  | webhooksReplayEventResponse500;

export type webhooksReplayEventResponse =
  webhooksReplayEventResponseComposite & {
    headers: Headers;
  };

export const getWebhooksReplayEventUrl = (id: string, eventId: string) => {
  return `/v1/webhooks/${id}/events/${eventId}/replay`;
};

export const webhooksReplayEvent = async (
  id: string,
  eventId: string,
  options?: RequestInit,
): Promise<webhooksReplayEventResponse> => {
  return customInstance<webhooksReplayEventResponse>(
    getWebhooksReplayEventUrl(id, eventId),
    {
      ...options,
      method: "POST",
    },
  );
};

export const getWebhooksReplayEventMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksReplayEvent>>,
    TError,
    { id: string; eventId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksReplayEvent>>,
  TError,
  { id: string; eventId: string },
  TContext
> => {
  const mutationKey = ["webhooksReplayEvent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksReplayEvent>>,
    { id: string; eventId: string }
  > = (props) => {
    const { id, eventId } = props ?? {};

    return webhooksReplayEvent(id, eventId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksReplayEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksReplayEvent>>
>;

export type WebhooksReplayEventMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary replay_event webhooks
 */
export const useWebhooksReplayEvent = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksReplayEvent>>,
    TError,
    { id: string; eventId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof webhooksReplayEvent>>,
  TError,
  { id: string; eventId: string },
  TContext
> => {
  const mutationOptions = getWebhooksReplayEventMutationOptions(options);

  return useMutation(mutationOptions);
};
