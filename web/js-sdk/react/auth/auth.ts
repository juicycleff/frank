/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Frank Authentication Server
 * A comprehensive authentication server with OAuth2, MFA, Passkeys, SSO, and more
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthForgotPasswordParams,
  BadRequestError,
  CSRFTokenResponse,
  ConflictError,
  ForbiddenError,
  ForgotPasswordRequest,
  InternalServerError,
  LoginRequest,
  LoginResponse2,
  LoginResponse3,
  NotFoundError,
  RefreshTokenRequest,
  RefreshTokenResponse,
  RegisterRequest,
  ResetPasswordRequest,
  SendResponseBody,
  UnauthorizedError,
  User,
  VerifyEmailRequest,
} from "../../model";

import { customInstance } from "../../mutator/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Generates a CSRF token
 * @summary csrf auth
 */
export type authCsrfResponse200 = {
  data: CSRFTokenResponse;
  status: 200;
};

export type authCsrfResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authCsrfResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authCsrfResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authCsrfResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authCsrfResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authCsrfResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authCsrfResponseComposite =
  | authCsrfResponse200
  | authCsrfResponse400
  | authCsrfResponse401
  | authCsrfResponse403
  | authCsrfResponse404
  | authCsrfResponse409
  | authCsrfResponse500;

export type authCsrfResponse = authCsrfResponseComposite & {
  headers: Headers;
};

export const getAuthCsrfUrl = () => {
  return `/v1/auth/csrf-token`;
};

export const authCsrf = async (
  options?: RequestInit,
): Promise<authCsrfResponse> => {
  return customInstance<authCsrfResponse>(getAuthCsrfUrl(), {
    ...options,
    method: "GET",
  });
};

export const getAuthCsrfQueryKey = () => {
  return [`/v1/auth/csrf-token`] as const;
};

export const getAuthCsrfInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authCsrf>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthCsrfQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authCsrf>>> = ({
    signal,
  }) => authCsrf({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authCsrf>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthCsrfInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authCsrf>>
>;
export type AuthCsrfInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useAuthCsrfInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authCsrf>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof authCsrf>>,
        TError,
        Awaited<ReturnType<typeof authCsrf>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthCsrfInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authCsrf>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof authCsrf>>,
        TError,
        Awaited<ReturnType<typeof authCsrf>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthCsrfInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authCsrf>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary csrf auth
 */

export function useAuthCsrfInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authCsrf>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthCsrfInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthCsrfQueryOptions = <
  TData = Awaited<ReturnType<typeof authCsrf>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthCsrfQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authCsrf>>> = ({
    signal,
  }) => authCsrf({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authCsrf>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthCsrfQueryResult = NonNullable<
  Awaited<ReturnType<typeof authCsrf>>
>;
export type AuthCsrfQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useAuthCsrf<
  TData = Awaited<ReturnType<typeof authCsrf>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof authCsrf>>,
        TError,
        Awaited<ReturnType<typeof authCsrf>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthCsrf<
  TData = Awaited<ReturnType<typeof authCsrf>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof authCsrf>>,
        TError,
        Awaited<ReturnType<typeof authCsrf>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthCsrf<
  TData = Awaited<ReturnType<typeof authCsrf>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary csrf auth
 */

export function useAuthCsrf<
  TData = Awaited<ReturnType<typeof authCsrf>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authCsrf>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthCsrfQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Initiate password reset process
 * @summary forgot_password auth
 */
export type authForgotPasswordResponse202 = {
  data: SendResponseBody;
  status: 202;
};

export type authForgotPasswordResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authForgotPasswordResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authForgotPasswordResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authForgotPasswordResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authForgotPasswordResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authForgotPasswordResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authForgotPasswordResponseComposite =
  | authForgotPasswordResponse202
  | authForgotPasswordResponse400
  | authForgotPasswordResponse401
  | authForgotPasswordResponse403
  | authForgotPasswordResponse404
  | authForgotPasswordResponse409
  | authForgotPasswordResponse500;

export type authForgotPasswordResponse = authForgotPasswordResponseComposite & {
  headers: Headers;
};

export const getAuthForgotPasswordUrl = (params?: AuthForgotPasswordParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/auth/forgot-password?${stringifiedParams}`
    : `/v1/auth/forgot-password`;
};

export const authForgotPassword = async (
  forgotPasswordRequest: ForgotPasswordRequest,
  params?: AuthForgotPasswordParams,
  options?: RequestInit,
): Promise<authForgotPasswordResponse> => {
  return customInstance<authForgotPasswordResponse>(
    getAuthForgotPasswordUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(forgotPasswordRequest),
    },
  );
};

export const getAuthForgotPasswordMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: ForgotPasswordRequest; params?: AuthForgotPasswordParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: ForgotPasswordRequest; params?: AuthForgotPasswordParams },
  TContext
> => {
  const mutationKey = ["authForgotPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authForgotPassword>>,
    { data: ForgotPasswordRequest; params?: AuthForgotPasswordParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return authForgotPassword(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authForgotPassword>>
>;
export type AuthForgotPasswordMutationBody = ForgotPasswordRequest;
export type AuthForgotPasswordMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary forgot_password auth
 */
export const useAuthForgotPassword = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: ForgotPasswordRequest; params?: AuthForgotPasswordParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: ForgotPasswordRequest; params?: AuthForgotPasswordParams },
  TContext
> => {
  const mutationOptions = getAuthForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Authenticate user with email and password
 * @summary login auth
 */
export type authLoginResponse200 = {
  data: LoginResponse2;
  status: 200;
};

export type authLoginResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authLoginResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authLoginResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authLoginResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authLoginResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authLoginResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authLoginResponseComposite =
  | authLoginResponse200
  | authLoginResponse400
  | authLoginResponse401
  | authLoginResponse403
  | authLoginResponse404
  | authLoginResponse409
  | authLoginResponse500;

export type authLoginResponse = authLoginResponseComposite & {
  headers: Headers;
};

export const getAuthLoginUrl = () => {
  return `/v1/auth/login`;
};

export const authLogin = async (
  loginRequest: LoginRequest,
  options?: RequestInit,
): Promise<authLoginResponse> => {
  return customInstance<authLoginResponse>(getAuthLoginUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(loginRequest),
  });
};

export const getAuthLoginMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogin>>,
    TError,
    { data: LoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationKey = ["authLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogin>>,
    { data: LoginRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogin>>
>;
export type AuthLoginMutationBody = LoginRequest;
export type AuthLoginMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary login auth
 */
export const useAuthLogin = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogin>>,
    TError,
    { data: LoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationOptions = getAuthLoginMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Log out the current user
 * @summary logout auth
 */
export type authLogoutResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type authLogoutResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authLogoutResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authLogoutResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authLogoutResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authLogoutResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authLogoutResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authLogoutResponseComposite =
  | authLogoutResponse200
  | authLogoutResponse400
  | authLogoutResponse401
  | authLogoutResponse403
  | authLogoutResponse404
  | authLogoutResponse409
  | authLogoutResponse500;

export type authLogoutResponse = authLogoutResponseComposite & {
  headers: Headers;
};

export const getAuthLogoutUrl = () => {
  return `/v1/auth/logout`;
};

export const authLogout = async (
  options?: RequestInit,
): Promise<authLogoutResponse> => {
  return customInstance<authLogoutResponse>(getAuthLogoutUrl(), {
    ...options,
    method: "POST",
  });
};

export const getAuthLogoutMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authLogout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogout>>,
    void
  > = () => {
    return authLogout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogout>>
>;

export type AuthLogoutMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary logout auth
 */
export const useAuthLogout = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthLogoutMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get current user info
 * @summary me auth
 */
export type authMeResponse200 = {
  data: User;
  status: 200;
};

export type authMeResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authMeResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authMeResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authMeResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authMeResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authMeResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authMeResponseComposite =
  | authMeResponse200
  | authMeResponse400
  | authMeResponse401
  | authMeResponse403
  | authMeResponse404
  | authMeResponse409
  | authMeResponse500;

export type authMeResponse = authMeResponseComposite & {
  headers: Headers;
};

export const getAuthMeUrl = () => {
  return `/v1/auth/me`;
};

export const authMe = async (
  options?: RequestInit,
): Promise<authMeResponse> => {
  return customInstance<authMeResponse>(getAuthMeUrl(), {
    ...options,
    method: "GET",
  });
};

export const getAuthMeQueryKey = () => {
  return [`/v1/auth/me`] as const;
};

export const getAuthMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authMe>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authMe>>> = ({
    signal,
  }) => authMe({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthMeInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authMe>>
>;
export type AuthMeInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useAuthMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authMe>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof authMe>>,
        TError,
        Awaited<ReturnType<typeof authMe>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authMe>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof authMe>>,
        TError,
        Awaited<ReturnType<typeof authMe>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authMe>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary me auth
 */

export function useAuthMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authMe>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthMeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthMeQueryOptions = <
  TData = Awaited<ReturnType<typeof authMe>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authMe>>> = ({
    signal,
  }) => authMe({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthMeQueryResult = NonNullable<Awaited<ReturnType<typeof authMe>>>;
export type AuthMeQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useAuthMe<
  TData = Awaited<ReturnType<typeof authMe>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof authMe>>,
        TError,
        Awaited<ReturnType<typeof authMe>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthMe<
  TData = Awaited<ReturnType<typeof authMe>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof authMe>>,
        TError,
        Awaited<ReturnType<typeof authMe>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthMe<
  TData = Awaited<ReturnType<typeof authMe>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary me auth
 */

export function useAuthMe<
  TData = Awaited<ReturnType<typeof authMe>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthMeQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Refresh an access token
 * @summary refresh_token auth
 */
export type authRefreshTokenResponse200 = {
  data: RefreshTokenResponse;
  status: 200;
};

export type authRefreshTokenResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authRefreshTokenResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authRefreshTokenResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authRefreshTokenResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authRefreshTokenResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authRefreshTokenResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authRefreshTokenResponseComposite =
  | authRefreshTokenResponse200
  | authRefreshTokenResponse400
  | authRefreshTokenResponse401
  | authRefreshTokenResponse403
  | authRefreshTokenResponse404
  | authRefreshTokenResponse409
  | authRefreshTokenResponse500;

export type authRefreshTokenResponse = authRefreshTokenResponseComposite & {
  headers: Headers;
};

export const getAuthRefreshTokenUrl = () => {
  return `/v1/auth/refresh`;
};

export const authRefreshToken = async (
  refreshTokenRequest: RefreshTokenRequest,
  options?: RequestInit,
): Promise<authRefreshTokenResponse> => {
  return customInstance<authRefreshTokenResponse>(getAuthRefreshTokenUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(refreshTokenRequest),
  });
};

export const getAuthRefreshTokenMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefreshToken>>,
    TError,
    { data: RefreshTokenRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  { data: RefreshTokenRequest },
  TContext
> => {
  const mutationKey = ["authRefreshToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRefreshToken>>,
    { data: RefreshTokenRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authRefreshToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRefreshToken>>
>;
export type AuthRefreshTokenMutationBody = RefreshTokenRequest;
export type AuthRefreshTokenMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary refresh_token auth
 */
export const useAuthRefreshToken = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefreshToken>>,
    TError,
    { data: RefreshTokenRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  { data: RefreshTokenRequest },
  TContext
> => {
  const mutationOptions = getAuthRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Register a new user
 * @summary register auth
 */
export type authRegisterResponse201 = {
  data: LoginResponse3;
  status: 201;
};

export type authRegisterResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authRegisterResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authRegisterResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authRegisterResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authRegisterResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authRegisterResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authRegisterResponseComposite =
  | authRegisterResponse201
  | authRegisterResponse400
  | authRegisterResponse401
  | authRegisterResponse403
  | authRegisterResponse404
  | authRegisterResponse409
  | authRegisterResponse500;

export type authRegisterResponse = authRegisterResponseComposite & {
  headers: Headers;
};

export const getAuthRegisterUrl = () => {
  return `/v1/auth/register`;
};

export const authRegister = async (
  registerRequest: RegisterRequest,
  options?: RequestInit,
): Promise<authRegisterResponse> => {
  return customInstance<authRegisterResponse>(getAuthRegisterUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(registerRequest),
  });
};

export const getAuthRegisterMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegister>>,
    TError,
    { data: RegisterRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: RegisterRequest },
  TContext
> => {
  const mutationKey = ["authRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegister>>,
    { data: RegisterRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegister>>
>;
export type AuthRegisterMutationBody = RegisterRequest;
export type AuthRegisterMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary register auth
 */
export const useAuthRegister = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegister>>,
    TError,
    { data: RegisterRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: RegisterRequest },
  TContext
> => {
  const mutationOptions = getAuthRegisterMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Reset password using token
 * @summary reset_password auth
 */
export type authResetPasswordResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type authResetPasswordResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authResetPasswordResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authResetPasswordResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authResetPasswordResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authResetPasswordResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authResetPasswordResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authResetPasswordResponseComposite =
  | authResetPasswordResponse200
  | authResetPasswordResponse400
  | authResetPasswordResponse401
  | authResetPasswordResponse403
  | authResetPasswordResponse404
  | authResetPasswordResponse409
  | authResetPasswordResponse500;

export type authResetPasswordResponse = authResetPasswordResponseComposite & {
  headers: Headers;
};

export const getAuthResetPasswordUrl = () => {
  return `/v1/auth/reset-password`;
};

export const authResetPassword = async (
  resetPasswordRequest: ResetPasswordRequest,
  options?: RequestInit,
): Promise<authResetPasswordResponse> => {
  return customInstance<authResetPasswordResponse>(getAuthResetPasswordUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(resetPasswordRequest),
  });
};

export const getAuthResetPasswordMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authResetPassword>>,
    TError,
    { data: ResetPasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: ResetPasswordRequest },
  TContext
> => {
  const mutationKey = ["authResetPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authResetPassword>>,
    { data: ResetPasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authResetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authResetPassword>>
>;
export type AuthResetPasswordMutationBody = ResetPasswordRequest;
export type AuthResetPasswordMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary reset_password auth
 */
export const useAuthResetPassword = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authResetPassword>>,
    TError,
    { data: ResetPasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: ResetPasswordRequest },
  TContext
> => {
  const mutationOptions = getAuthResetPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Verify email using token
 * @summary verify_email auth
 */
export type authVerifyEmailResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type authVerifyEmailResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type authVerifyEmailResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type authVerifyEmailResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type authVerifyEmailResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type authVerifyEmailResponse409 = {
  data: ConflictError;
  status: 409;
};

export type authVerifyEmailResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type authVerifyEmailResponseComposite =
  | authVerifyEmailResponse200
  | authVerifyEmailResponse400
  | authVerifyEmailResponse401
  | authVerifyEmailResponse403
  | authVerifyEmailResponse404
  | authVerifyEmailResponse409
  | authVerifyEmailResponse500;

export type authVerifyEmailResponse = authVerifyEmailResponseComposite & {
  headers: Headers;
};

export const getAuthVerifyEmailUrl = () => {
  return `/v1/auth/verify-email`;
};

export const authVerifyEmail = async (
  verifyEmailRequest: VerifyEmailRequest,
  options?: RequestInit,
): Promise<authVerifyEmailResponse> => {
  return customInstance<authVerifyEmailResponse>(getAuthVerifyEmailUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(verifyEmailRequest),
  });
};

export const getAuthVerifyEmailMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    TError,
    { data: VerifyEmailRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { data: VerifyEmailRequest },
  TContext
> => {
  const mutationKey = ["authVerifyEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    { data: VerifyEmailRequest }
  > = (props) => {
    const { data } = props ?? {};

    return authVerifyEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthVerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authVerifyEmail>>
>;
export type AuthVerifyEmailMutationBody = VerifyEmailRequest;
export type AuthVerifyEmailMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary verify_email auth
 */
export const useAuthVerifyEmail = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    TError,
    { data: VerifyEmailRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { data: VerifyEmailRequest },
  TContext
> => {
  const mutationOptions = getAuthVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions);
};
