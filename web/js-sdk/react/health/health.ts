/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Frank Authentication Server
 * A comprehensive authentication server with OAuth2, MFA, Passkeys, SSO, and more
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  HealthResponse,
  MetricsResponseBody,
  ReadyResponse,
  VersionResponseBody,
} from "../../model";

import { customInstance } from "../../mutator/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Debug information (only available in development mode)
 * @summary debug health
 */
export type healthDebugResponse200 = {
  data: unknown;
  status: 200;
};

export type healthDebugResponseComposite = healthDebugResponse200;

export type healthDebugResponse = healthDebugResponseComposite & {
  headers: Headers;
};

export const getHealthDebugUrl = () => {
  return `/__debug`;
};

export const healthDebug = async (
  options?: RequestInit,
): Promise<healthDebugResponse> => {
  return customInstance<healthDebugResponse>(getHealthDebugUrl(), {
    ...options,
    method: "GET",
  });
};

export const getHealthDebugQueryKey = () => {
  return [`/__debug`] as const;
};

export const getHealthDebugInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthDebug>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthDebug>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthDebugQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthDebug>>> = ({
    signal,
  }) => healthDebug({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthDebug>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthDebugInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthDebug>>
>;
export type HealthDebugInfiniteQueryError = unknown;

export function useHealthDebugInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthDebug>>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthDebug>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthDebug>>,
        TError,
        Awaited<ReturnType<typeof healthDebug>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthDebugInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthDebug>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthDebug>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthDebug>>,
        TError,
        Awaited<ReturnType<typeof healthDebug>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthDebugInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthDebug>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthDebug>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary debug health
 */

export function useHealthDebugInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthDebug>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthDebug>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthDebugInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHealthDebugQueryOptions = <
  TData = Awaited<ReturnType<typeof healthDebug>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthDebug>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthDebugQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthDebug>>> = ({
    signal,
  }) => healthDebug({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthDebug>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthDebugQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthDebug>>
>;
export type HealthDebugQueryError = unknown;

export function useHealthDebug<
  TData = Awaited<ReturnType<typeof healthDebug>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthDebug>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthDebug>>,
        TError,
        Awaited<ReturnType<typeof healthDebug>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthDebug<
  TData = Awaited<ReturnType<typeof healthDebug>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthDebug>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthDebug>>,
        TError,
        Awaited<ReturnType<typeof healthDebug>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthDebug<
  TData = Awaited<ReturnType<typeof healthDebug>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthDebug>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary debug health
 */

export function useHealthDebug<
  TData = Awaited<ReturnType<typeof healthDebug>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthDebug>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthDebugQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Check system health
 * @summary check health
 */
export type healthCheckResponse200 = {
  data: HealthResponse;
  status: 200;
};

export type healthCheckResponse503 = {
  data: HealthResponse;
  status: 503;
};

export type healthCheckResponseComposite =
  | healthCheckResponse200
  | healthCheckResponse503;

export type healthCheckResponse = healthCheckResponseComposite & {
  headers: Headers;
};

export const getHealthCheckUrl = () => {
  return `/__health`;
};

export const healthCheck = async (
  options?: RequestInit,
): Promise<healthCheckResponse> => {
  return customInstance<healthCheckResponse>(getHealthCheckUrl(), {
    ...options,
    method: "GET",
  });
};

export const getHealthCheckQueryKey = () => {
  return [`/__health`] as const;
};

export const getHealthCheckInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>;
export type HealthCheckInfiniteQueryError = HealthResponse;

export function useHealthCheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>,
  TError = HealthResponse,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthCheck>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        Awaited<ReturnType<typeof healthCheck>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthCheck>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        Awaited<ReturnType<typeof healthCheck>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary check health
 */

export function useHealthCheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthCheck>>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthCheck>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthCheckInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>;
export type HealthCheckQueryError = HealthResponse;

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthResponse,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        Awaited<ReturnType<typeof healthCheck>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthCheck>>,
        TError,
        Awaited<ReturnType<typeof healthCheck>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary check health
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get system metrics
 * @summary metrics health
 */
export type healthMetricsResponse200 = {
  data: MetricsResponseBody;
  status: 200;
};

export type healthMetricsResponseComposite = healthMetricsResponse200;

export type healthMetricsResponse = healthMetricsResponseComposite & {
  headers: Headers;
};

export const getHealthMetricsUrl = () => {
  return `/__metrics`;
};

export const healthMetrics = async (
  options?: RequestInit,
): Promise<healthMetricsResponse> => {
  return customInstance<healthMetricsResponse>(getHealthMetricsUrl(), {
    ...options,
    method: "GET",
  });
};

export const getHealthMetricsQueryKey = () => {
  return [`/__metrics`] as const;
};

export const getHealthMetricsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthMetrics>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthMetrics>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthMetricsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthMetrics>>> = ({
    signal,
  }) => healthMetrics({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthMetrics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthMetricsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthMetrics>>
>;
export type HealthMetricsInfiniteQueryError = unknown;

export function useHealthMetricsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthMetrics>>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthMetrics>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthMetrics>>,
        TError,
        Awaited<ReturnType<typeof healthMetrics>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthMetricsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthMetrics>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthMetrics>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthMetrics>>,
        TError,
        Awaited<ReturnType<typeof healthMetrics>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthMetricsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthMetrics>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthMetrics>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary metrics health
 */

export function useHealthMetricsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthMetrics>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthMetrics>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthMetricsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHealthMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof healthMetrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthMetrics>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthMetricsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthMetrics>>> = ({
    signal,
  }) => healthMetrics({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthMetrics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthMetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthMetrics>>
>;
export type HealthMetricsQueryError = unknown;

export function useHealthMetrics<
  TData = Awaited<ReturnType<typeof healthMetrics>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthMetrics>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthMetrics>>,
        TError,
        Awaited<ReturnType<typeof healthMetrics>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthMetrics<
  TData = Awaited<ReturnType<typeof healthMetrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthMetrics>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthMetrics>>,
        TError,
        Awaited<ReturnType<typeof healthMetrics>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthMetrics<
  TData = Awaited<ReturnType<typeof healthMetrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthMetrics>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary metrics health
 */

export function useHealthMetrics<
  TData = Awaited<ReturnType<typeof healthMetrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthMetrics>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthMetricsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Check if the system is ready to receive traffic
 * @summary ready health
 */
export type healthReadyResponse200 = {
  data: ReadyResponse;
  status: 200;
};

export type healthReadyResponse503 = {
  data: ReadyResponse;
  status: 503;
};

export type healthReadyResponseComposite =
  | healthReadyResponse200
  | healthReadyResponse503;

export type healthReadyResponse = healthReadyResponseComposite & {
  headers: Headers;
};

export const getHealthReadyUrl = () => {
  return `/__ready`;
};

export const healthReady = async (
  options?: RequestInit,
): Promise<healthReadyResponse> => {
  return customInstance<healthReadyResponse>(getHealthReadyUrl(), {
    ...options,
    method: "GET",
  });
};

export const getHealthReadyQueryKey = () => {
  return [`/__ready`] as const;
};

export const getHealthReadyInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthReady>>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthReady>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthReadyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthReady>>> = ({
    signal,
  }) => healthReady({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthReady>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthReadyInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthReady>>
>;
export type HealthReadyInfiniteQueryError = ReadyResponse;

export function useHealthReadyInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthReady>>>,
  TError = ReadyResponse,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthReady>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthReady>>,
        TError,
        Awaited<ReturnType<typeof healthReady>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthReadyInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthReady>>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthReady>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthReady>>,
        TError,
        Awaited<ReturnType<typeof healthReady>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthReadyInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthReady>>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthReady>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ready health
 */

export function useHealthReadyInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthReady>>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthReady>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthReadyInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHealthReadyQueryOptions = <
  TData = Awaited<ReturnType<typeof healthReady>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthReady>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthReadyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthReady>>> = ({
    signal,
  }) => healthReady({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthReady>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthReadyQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthReady>>
>;
export type HealthReadyQueryError = ReadyResponse;

export function useHealthReady<
  TData = Awaited<ReturnType<typeof healthReady>>,
  TError = ReadyResponse,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthReady>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthReady>>,
        TError,
        Awaited<ReturnType<typeof healthReady>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthReady<
  TData = Awaited<ReturnType<typeof healthReady>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthReady>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthReady>>,
        TError,
        Awaited<ReturnType<typeof healthReady>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthReady<
  TData = Awaited<ReturnType<typeof healthReady>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthReady>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ready health
 */

export function useHealthReady<
  TData = Awaited<ReturnType<typeof healthReady>>,
  TError = ReadyResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthReady>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthReadyQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get system version information
 * @summary version health
 */
export type healthVersionResponse200 = {
  data: VersionResponseBody;
  status: 200;
};

export type healthVersionResponseComposite = healthVersionResponse200;

export type healthVersionResponse = healthVersionResponseComposite & {
  headers: Headers;
};

export const getHealthVersionUrl = () => {
  return `/__version`;
};

export const healthVersion = async (
  options?: RequestInit,
): Promise<healthVersionResponse> => {
  return customInstance<healthVersionResponse>(getHealthVersionUrl(), {
    ...options,
    method: "GET",
  });
};

export const getHealthVersionQueryKey = () => {
  return [`/__version`] as const;
};

export const getHealthVersionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthVersion>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthVersion>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthVersion>>> = ({
    signal,
  }) => healthVersion({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthVersion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthVersionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthVersion>>
>;
export type HealthVersionInfiniteQueryError = unknown;

export function useHealthVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthVersion>>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthVersion>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthVersion>>,
        TError,
        Awaited<ReturnType<typeof healthVersion>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthVersion>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthVersion>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthVersion>>,
        TError,
        Awaited<ReturnType<typeof healthVersion>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthVersion>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthVersion>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary version health
 */

export function useHealthVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthVersion>>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthVersion>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthVersionInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHealthVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof healthVersion>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthVersion>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthVersion>>> = ({
    signal,
  }) => healthVersion({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthVersion>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthVersion>>
>;
export type HealthVersionQueryError = unknown;

export function useHealthVersion<
  TData = Awaited<ReturnType<typeof healthVersion>>,
  TError = unknown,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthVersion>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthVersion>>,
        TError,
        Awaited<ReturnType<typeof healthVersion>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthVersion<
  TData = Awaited<ReturnType<typeof healthVersion>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthVersion>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof healthVersion>>,
        TError,
        Awaited<ReturnType<typeof healthVersion>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthVersion<
  TData = Awaited<ReturnType<typeof healthVersion>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthVersion>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary version health
 */

export function useHealthVersion<
  TData = Awaited<ReturnType<typeof healthVersion>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthVersion>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthVersionQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
