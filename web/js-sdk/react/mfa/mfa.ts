/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Frank Authentication Server
 * A comprehensive authentication server with OAuth2, MFA, Passkeys, SSO, and more
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BadRequestError,
  EnrollRequestBody,
  EnrollResponseBody,
  ForbiddenError,
  InternalServerError,
  MethodsResponseBody,
  NotFoundError,
  SendCodeRequestBody,
  SendCodeResponseBody,
  SendResponseBody,
  UnauthorizedError,
  UnenrollRequestBody,
  VerifyRequestBody,
  VerifyResponseBody,
} from "../../model";

import { customInstance } from "../../mutator/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Start MFA enrollment
 * @summary enroll mfa
 */
export type mfaEnrollResponse200 = {
  data: EnrollResponseBody;
  status: 200;
};

export type mfaEnrollResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type mfaEnrollResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type mfaEnrollResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type mfaEnrollResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type mfaEnrollResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type mfaEnrollResponseComposite =
  | mfaEnrollResponse200
  | mfaEnrollResponse400
  | mfaEnrollResponse401
  | mfaEnrollResponse403
  | mfaEnrollResponse404
  | mfaEnrollResponse500;

export type mfaEnrollResponse = mfaEnrollResponseComposite & {
  headers: Headers;
};

export const getMfaEnrollUrl = () => {
  return `/v1/auth/mfa/enroll`;
};

export const mfaEnroll = async (
  enrollRequestBody: EnrollRequestBody,
  options?: RequestInit,
): Promise<mfaEnrollResponse> => {
  return customInstance<mfaEnrollResponse>(getMfaEnrollUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(enrollRequestBody),
  });
};

export const getMfaEnrollMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaEnroll>>,
    TError,
    { data: EnrollRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mfaEnroll>>,
  TError,
  { data: EnrollRequestBody },
  TContext
> => {
  const mutationKey = ["mfaEnroll"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mfaEnroll>>,
    { data: EnrollRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return mfaEnroll(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MfaEnrollMutationResult = NonNullable<
  Awaited<ReturnType<typeof mfaEnroll>>
>;
export type MfaEnrollMutationBody = EnrollRequestBody;
export type MfaEnrollMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary enroll mfa
 */
export const useMfaEnroll = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaEnroll>>,
    TError,
    { data: EnrollRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof mfaEnroll>>,
  TError,
  { data: EnrollRequestBody },
  TContext
> => {
  const mutationOptions = getMfaEnrollMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get enabled MFA methods
 * @summary methods mfa
 */
export type mfaMethodsResponse200 = {
  data: MethodsResponseBody;
  status: 200;
};

export type mfaMethodsResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type mfaMethodsResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type mfaMethodsResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type mfaMethodsResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type mfaMethodsResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type mfaMethodsResponseComposite =
  | mfaMethodsResponse200
  | mfaMethodsResponse400
  | mfaMethodsResponse401
  | mfaMethodsResponse403
  | mfaMethodsResponse404
  | mfaMethodsResponse500;

export type mfaMethodsResponse = mfaMethodsResponseComposite & {
  headers: Headers;
};

export const getMfaMethodsUrl = () => {
  return `/v1/auth/mfa/methods`;
};

export const mfaMethods = async (
  options?: RequestInit,
): Promise<mfaMethodsResponse> => {
  return customInstance<mfaMethodsResponse>(getMfaMethodsUrl(), {
    ...options,
    method: "GET",
  });
};

export const getMfaMethodsQueryKey = () => {
  return [`/v1/auth/mfa/methods`] as const;
};

export const getMfaMethodsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof mfaMethods>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof mfaMethods>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMfaMethodsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof mfaMethods>>> = ({
    signal,
  }) => mfaMethods({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof mfaMethods>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MfaMethodsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof mfaMethods>>
>;
export type MfaMethodsInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useMfaMethodsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof mfaMethods>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof mfaMethods>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof mfaMethods>>,
        TError,
        Awaited<ReturnType<typeof mfaMethods>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMfaMethodsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof mfaMethods>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof mfaMethods>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof mfaMethods>>,
        TError,
        Awaited<ReturnType<typeof mfaMethods>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMfaMethodsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof mfaMethods>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof mfaMethods>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary methods mfa
 */

export function useMfaMethodsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof mfaMethods>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof mfaMethods>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMfaMethodsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMfaMethodsQueryOptions = <
  TData = Awaited<ReturnType<typeof mfaMethods>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof mfaMethods>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMfaMethodsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof mfaMethods>>> = ({
    signal,
  }) => mfaMethods({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof mfaMethods>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MfaMethodsQueryResult = NonNullable<
  Awaited<ReturnType<typeof mfaMethods>>
>;
export type MfaMethodsQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

export function useMfaMethods<
  TData = Awaited<ReturnType<typeof mfaMethods>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof mfaMethods>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof mfaMethods>>,
        TError,
        Awaited<ReturnType<typeof mfaMethods>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMfaMethods<
  TData = Awaited<ReturnType<typeof mfaMethods>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof mfaMethods>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof mfaMethods>>,
        TError,
        Awaited<ReturnType<typeof mfaMethods>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMfaMethods<
  TData = Awaited<ReturnType<typeof mfaMethods>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof mfaMethods>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary methods mfa
 */

export function useMfaMethods<
  TData = Awaited<ReturnType<typeof mfaMethods>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof mfaMethods>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMfaMethodsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Send verification code
 * @summary send_code mfa
 */
export type mfaSendCodeResponse200 = {
  data: SendCodeResponseBody;
  status: 200;
};

export type mfaSendCodeResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type mfaSendCodeResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type mfaSendCodeResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type mfaSendCodeResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type mfaSendCodeResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type mfaSendCodeResponseComposite =
  | mfaSendCodeResponse200
  | mfaSendCodeResponse400
  | mfaSendCodeResponse401
  | mfaSendCodeResponse403
  | mfaSendCodeResponse404
  | mfaSendCodeResponse500;

export type mfaSendCodeResponse = mfaSendCodeResponseComposite & {
  headers: Headers;
};

export const getMfaSendCodeUrl = () => {
  return `/v1/auth/mfa/send-code`;
};

export const mfaSendCode = async (
  sendCodeRequestBody: SendCodeRequestBody,
  options?: RequestInit,
): Promise<mfaSendCodeResponse> => {
  return customInstance<mfaSendCodeResponse>(getMfaSendCodeUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(sendCodeRequestBody),
  });
};

export const getMfaSendCodeMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaSendCode>>,
    TError,
    { data: SendCodeRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mfaSendCode>>,
  TError,
  { data: SendCodeRequestBody },
  TContext
> => {
  const mutationKey = ["mfaSendCode"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mfaSendCode>>,
    { data: SendCodeRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return mfaSendCode(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MfaSendCodeMutationResult = NonNullable<
  Awaited<ReturnType<typeof mfaSendCode>>
>;
export type MfaSendCodeMutationBody = SendCodeRequestBody;
export type MfaSendCodeMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary send_code mfa
 */
export const useMfaSendCode = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaSendCode>>,
    TError,
    { data: SendCodeRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof mfaSendCode>>,
  TError,
  { data: SendCodeRequestBody },
  TContext
> => {
  const mutationOptions = getMfaSendCodeMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Disable MFA method
 * @summary unenroll mfa
 */
export type mfaUnenrollResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type mfaUnenrollResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type mfaUnenrollResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type mfaUnenrollResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type mfaUnenrollResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type mfaUnenrollResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type mfaUnenrollResponseComposite =
  | mfaUnenrollResponse200
  | mfaUnenrollResponse400
  | mfaUnenrollResponse401
  | mfaUnenrollResponse403
  | mfaUnenrollResponse404
  | mfaUnenrollResponse500;

export type mfaUnenrollResponse = mfaUnenrollResponseComposite & {
  headers: Headers;
};

export const getMfaUnenrollUrl = () => {
  return `/v1/auth/mfa/unenroll`;
};

export const mfaUnenroll = async (
  unenrollRequestBody: UnenrollRequestBody,
  options?: RequestInit,
): Promise<mfaUnenrollResponse> => {
  return customInstance<mfaUnenrollResponse>(getMfaUnenrollUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(unenrollRequestBody),
  });
};

export const getMfaUnenrollMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaUnenroll>>,
    TError,
    { data: UnenrollRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mfaUnenroll>>,
  TError,
  { data: UnenrollRequestBody },
  TContext
> => {
  const mutationKey = ["mfaUnenroll"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mfaUnenroll>>,
    { data: UnenrollRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return mfaUnenroll(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MfaUnenrollMutationResult = NonNullable<
  Awaited<ReturnType<typeof mfaUnenroll>>
>;
export type MfaUnenrollMutationBody = UnenrollRequestBody;
export type MfaUnenrollMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary unenroll mfa
 */
export const useMfaUnenroll = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaUnenroll>>,
    TError,
    { data: UnenrollRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof mfaUnenroll>>,
  TError,
  { data: UnenrollRequestBody },
  TContext
> => {
  const mutationOptions = getMfaUnenrollMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Verify MFA code
 * @summary verify mfa
 */
export type mfaVerifyResponse200 = {
  data: VerifyResponseBody;
  status: 200;
};

export type mfaVerifyResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type mfaVerifyResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type mfaVerifyResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type mfaVerifyResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type mfaVerifyResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type mfaVerifyResponseComposite =
  | mfaVerifyResponse200
  | mfaVerifyResponse400
  | mfaVerifyResponse401
  | mfaVerifyResponse403
  | mfaVerifyResponse404
  | mfaVerifyResponse500;

export type mfaVerifyResponse = mfaVerifyResponseComposite & {
  headers: Headers;
};

export const getMfaVerifyUrl = () => {
  return `/v1/auth/mfa/verify`;
};

export const mfaVerify = async (
  verifyRequestBody: VerifyRequestBody,
  options?: RequestInit,
): Promise<mfaVerifyResponse> => {
  return customInstance<mfaVerifyResponse>(getMfaVerifyUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(verifyRequestBody),
  });
};

export const getMfaVerifyMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaVerify>>,
    TError,
    { data: VerifyRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof mfaVerify>>,
  TError,
  { data: VerifyRequestBody },
  TContext
> => {
  const mutationKey = ["mfaVerify"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof mfaVerify>>,
    { data: VerifyRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return mfaVerify(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MfaVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof mfaVerify>>
>;
export type MfaVerifyMutationBody = VerifyRequestBody;
export type MfaVerifyMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | InternalServerError;

/**
 * @summary verify mfa
 */
export const useMfaVerify = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof mfaVerify>>,
    TError,
    { data: VerifyRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof mfaVerify>>,
  TError,
  { data: VerifyRequestBody },
  TContext
> => {
  const mutationOptions = getMfaVerifyMutationOptions(options);

  return useMutation(mutationOptions);
};
