/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Frank Authentication Server
 * A comprehensive authentication server with OAuth2, MFA, Passkeys, SSO, and more
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BadRequestError,
  ConflictError,
  CreateUserRequest,
  ForbiddenError,
  GetOrganizationsResponseBody,
  GetUserSessionResponse,
  InternalServerError,
  ListResponseBody4,
  NotFoundError,
  SendResponseBody,
  UnauthorizedError,
  UpdatePasswordRequest,
  UpdateRequestBody4,
  UpdateUserRequest,
  User,
  UsersListParams,
} from "../../model";

import { customInstance } from "../../mutator/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List users
 * @summary list users
 */
export type usersListResponse200 = {
  data: ListResponseBody4;
  status: 200;
};

export type usersListResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersListResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersListResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersListResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersListResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersListResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersListResponseComposite =
  | usersListResponse200
  | usersListResponse400
  | usersListResponse401
  | usersListResponse403
  | usersListResponse404
  | usersListResponse409
  | usersListResponse500;

export type usersListResponse = usersListResponseComposite & {
  headers: Headers;
};

export const getUsersListUrl = (params?: UsersListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/users?${stringifiedParams}`
    : `/v1/users`;
};

export const usersList = async (
  params?: UsersListParams,
  options?: RequestInit,
): Promise<usersListResponse> => {
  return customInstance<usersListResponse>(getUsersListUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getUsersListQueryKey = (params?: UsersListParams) => {
  return [`/v1/users`, ...(params ? [params] : [])] as const;
};

export const getUsersListInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof usersList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({
    signal,
  }) => usersList(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof usersList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersList>>
>;
export type UsersListInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params: undefined | UsersListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersList>>,
          TError,
          Awaited<ReturnType<typeof usersList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersList>>,
          TError,
          Awaited<ReturnType<typeof usersList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list users
 */

export function useUsersListInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersList>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersList>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUsersListQueryOptions = <
  TData = Awaited<ReturnType<typeof usersList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({
    signal,
  }) => usersList(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersListQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersList>>
>;
export type UsersListQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersList<
  TData = Awaited<ReturnType<typeof usersList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params: undefined | UsersListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersList>>,
          TError,
          Awaited<ReturnType<typeof usersList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersList<
  TData = Awaited<ReturnType<typeof usersList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersList>>,
          TError,
          Awaited<ReturnType<typeof usersList>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersList<
  TData = Awaited<ReturnType<typeof usersList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list users
 */

export function useUsersList<
  TData = Awaited<ReturnType<typeof usersList>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  params?: UsersListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new user
 * @summary create users
 */
export type usersCreateResponse201 = {
  data: User;
  status: 201;
};

export type usersCreateResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersCreateResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersCreateResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersCreateResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersCreateResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersCreateResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersCreateResponseComposite =
  | usersCreateResponse201
  | usersCreateResponse400
  | usersCreateResponse401
  | usersCreateResponse403
  | usersCreateResponse404
  | usersCreateResponse409
  | usersCreateResponse500;

export type usersCreateResponse = usersCreateResponseComposite & {
  headers: Headers;
};

export const getUsersCreateUrl = () => {
  return `/v1/users`;
};

export const usersCreate = async (
  createUserRequest: CreateUserRequest,
  options?: RequestInit,
): Promise<usersCreateResponse> => {
  return customInstance<usersCreateResponse>(getUsersCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createUserRequest),
  });
};

export const getUsersCreateMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersCreate>>,
    TError,
    { data: CreateUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersCreate>>,
  TError,
  { data: CreateUserRequest },
  TContext
> => {
  const mutationKey = ["usersCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersCreate>>,
    { data: CreateUserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return usersCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersCreate>>
>;
export type UsersCreateMutationBody = CreateUserRequest;
export type UsersCreateMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary create users
 */
export const useUsersCreate = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersCreate>>,
    TError,
    { data: CreateUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersCreate>>,
  TError,
  { data: CreateUserRequest },
  TContext
> => {
  const mutationOptions = getUsersCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Update current user
 * @summary update_me users
 */
export type usersUpdateMeResponse200 = {
  data: User;
  status: 200;
};

export type usersUpdateMeResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersUpdateMeResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersUpdateMeResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersUpdateMeResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersUpdateMeResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersUpdateMeResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersUpdateMeResponseComposite =
  | usersUpdateMeResponse200
  | usersUpdateMeResponse400
  | usersUpdateMeResponse401
  | usersUpdateMeResponse403
  | usersUpdateMeResponse404
  | usersUpdateMeResponse409
  | usersUpdateMeResponse500;

export type usersUpdateMeResponse = usersUpdateMeResponseComposite & {
  headers: Headers;
};

export const getUsersUpdateMeUrl = () => {
  return `/v1/users/me`;
};

export const usersUpdateMe = async (
  updateUserRequest: UpdateUserRequest,
  options?: RequestInit,
): Promise<usersUpdateMeResponse> => {
  return customInstance<usersUpdateMeResponse>(getUsersUpdateMeUrl(), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateUserRequest),
  });
};

export const getUsersUpdateMeMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateMe>>,
    TError,
    { data: UpdateUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdateMe>>,
  TError,
  { data: UpdateUserRequest },
  TContext
> => {
  const mutationKey = ["usersUpdateMe"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdateMe>>,
    { data: UpdateUserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return usersUpdateMe(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdateMeMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdateMe>>
>;
export type UsersUpdateMeMutationBody = UpdateUserRequest;
export type UsersUpdateMeMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary update_me users
 */
export const useUsersUpdateMe = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateMe>>,
    TError,
    { data: UpdateUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdateMe>>,
  TError,
  { data: UpdateUserRequest },
  TContext
> => {
  const mutationOptions = getUsersUpdateMeMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Update current user password
 * @summary update_password users
 */
export type usersUpdatePasswordResponse200 = {
  data: SendResponseBody;
  status: 200;
};

export type usersUpdatePasswordResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersUpdatePasswordResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersUpdatePasswordResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersUpdatePasswordResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersUpdatePasswordResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersUpdatePasswordResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersUpdatePasswordResponseComposite =
  | usersUpdatePasswordResponse200
  | usersUpdatePasswordResponse400
  | usersUpdatePasswordResponse401
  | usersUpdatePasswordResponse403
  | usersUpdatePasswordResponse404
  | usersUpdatePasswordResponse409
  | usersUpdatePasswordResponse500;

export type usersUpdatePasswordResponse =
  usersUpdatePasswordResponseComposite & {
    headers: Headers;
  };

export const getUsersUpdatePasswordUrl = () => {
  return `/v1/users/me/password`;
};

export const usersUpdatePassword = async (
  updatePasswordRequest: UpdatePasswordRequest,
  options?: RequestInit,
): Promise<usersUpdatePasswordResponse> => {
  return customInstance<usersUpdatePasswordResponse>(
    getUsersUpdatePasswordUrl(),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(updatePasswordRequest),
    },
  );
};

export const getUsersUpdatePasswordMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdatePassword>>,
    TError,
    { data: UpdatePasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdatePassword>>,
  TError,
  { data: UpdatePasswordRequest },
  TContext
> => {
  const mutationKey = ["usersUpdatePassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdatePassword>>,
    { data: UpdatePasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return usersUpdatePassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdatePasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdatePassword>>
>;
export type UsersUpdatePasswordMutationBody = UpdatePasswordRequest;
export type UsersUpdatePasswordMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary update_password users
 */
export const useUsersUpdatePassword = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdatePassword>>,
    TError,
    { data: UpdatePasswordRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdatePassword>>,
  TError,
  { data: UpdatePasswordRequest },
  TContext
> => {
  const mutationOptions = getUsersUpdatePasswordMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get current user sessions
 * @summary get_sessions users
 */
export type usersGetSessionsResponse200 = {
  data: GetUserSessionResponse;
  status: 200;
};

export type usersGetSessionsResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersGetSessionsResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersGetSessionsResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersGetSessionsResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersGetSessionsResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersGetSessionsResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersGetSessionsResponseComposite =
  | usersGetSessionsResponse200
  | usersGetSessionsResponse400
  | usersGetSessionsResponse401
  | usersGetSessionsResponse403
  | usersGetSessionsResponse404
  | usersGetSessionsResponse409
  | usersGetSessionsResponse500;

export type usersGetSessionsResponse = usersGetSessionsResponseComposite & {
  headers: Headers;
};

export const getUsersGetSessionsUrl = () => {
  return `/v1/users/me/sessions`;
};

export const usersGetSessions = async (
  options?: RequestInit,
): Promise<usersGetSessionsResponse> => {
  return customInstance<usersGetSessionsResponse>(getUsersGetSessionsUrl(), {
    ...options,
    method: "GET",
  });
};

export const getUsersGetSessionsQueryKey = () => {
  return [`/v1/users/me/sessions`] as const;
};

export const getUsersGetSessionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetSessions>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof usersGetSessions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetSessionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetSessions>>
  > = ({ signal }) => usersGetSessions({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof usersGetSessions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetSessionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetSessions>>
>;
export type UsersGetSessionsInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersGetSessionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetSessions>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options: {
  query: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof usersGetSessions>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof usersGetSessions>>,
        TError,
        Awaited<ReturnType<typeof usersGetSessions>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetSessionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetSessions>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof usersGetSessions>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof usersGetSessions>>,
        TError,
        Awaited<ReturnType<typeof usersGetSessions>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetSessionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetSessions>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof usersGetSessions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get_sessions users
 */

export function useUsersGetSessionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetSessions>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof usersGetSessions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersGetSessionsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUsersGetSessionsQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetSessions>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetSessions>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetSessionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetSessions>>
  > = ({ signal }) => usersGetSessions({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetSessions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetSessionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetSessions>>
>;
export type UsersGetSessionsQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersGetSessions<
  TData = Awaited<ReturnType<typeof usersGetSessions>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetSessions>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof usersGetSessions>>,
        TError,
        Awaited<ReturnType<typeof usersGetSessions>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetSessions<
  TData = Awaited<ReturnType<typeof usersGetSessions>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetSessions>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof usersGetSessions>>,
        TError,
        Awaited<ReturnType<typeof usersGetSessions>>
      >,
      "initialData"
    >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetSessions<
  TData = Awaited<ReturnType<typeof usersGetSessions>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetSessions>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get_sessions users
 */

export function useUsersGetSessions<
  TData = Awaited<ReturnType<typeof usersGetSessions>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetSessions>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersGetSessionsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete user session
 * @summary delete_session users
 */
export type usersDeleteSessionResponse204 = {
  data: void;
  status: 204;
};

export type usersDeleteSessionResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersDeleteSessionResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersDeleteSessionResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersDeleteSessionResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersDeleteSessionResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersDeleteSessionResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersDeleteSessionResponseComposite =
  | usersDeleteSessionResponse204
  | usersDeleteSessionResponse400
  | usersDeleteSessionResponse401
  | usersDeleteSessionResponse403
  | usersDeleteSessionResponse404
  | usersDeleteSessionResponse409
  | usersDeleteSessionResponse500;

export type usersDeleteSessionResponse = usersDeleteSessionResponseComposite & {
  headers: Headers;
};

export const getUsersDeleteSessionUrl = (sessionId: string) => {
  return `/v1/users/me/sessions/${sessionId}`;
};

export const usersDeleteSession = async (
  sessionId: string,
  options?: RequestInit,
): Promise<usersDeleteSessionResponse> => {
  return customInstance<usersDeleteSessionResponse>(
    getUsersDeleteSessionUrl(sessionId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getUsersDeleteSessionMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteSession>>,
    TError,
    { sessionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersDeleteSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationKey = ["usersDeleteSession"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersDeleteSession>>,
    { sessionId: string }
  > = (props) => {
    const { sessionId } = props ?? {};

    return usersDeleteSession(sessionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersDeleteSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersDeleteSession>>
>;

export type UsersDeleteSessionMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary delete_session users
 */
export const useUsersDeleteSession = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteSession>>,
    TError,
    { sessionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersDeleteSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationOptions = getUsersDeleteSessionMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Delete user
 * @summary delete users
 */
export type usersDeleteResponse204 = {
  data: void;
  status: 204;
};

export type usersDeleteResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersDeleteResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersDeleteResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersDeleteResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersDeleteResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersDeleteResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersDeleteResponseComposite =
  | usersDeleteResponse204
  | usersDeleteResponse400
  | usersDeleteResponse401
  | usersDeleteResponse403
  | usersDeleteResponse404
  | usersDeleteResponse409
  | usersDeleteResponse500;

export type usersDeleteResponse = usersDeleteResponseComposite & {
  headers: Headers;
};

export const getUsersDeleteUrl = (id: string) => {
  return `/v1/users/${id}`;
};

export const usersDelete = async (
  id: string,
  options?: RequestInit,
): Promise<usersDeleteResponse> => {
  return customInstance<usersDeleteResponse>(getUsersDeleteUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getUsersDeleteMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["usersDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return usersDelete(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersDelete>>
>;

export type UsersDeleteMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary delete users
 */
export const useUsersDelete = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getUsersDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get user by ID
 * @summary get users
 */
export type usersGetResponse200 = {
  data: User;
  status: 200;
};

export type usersGetResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersGetResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersGetResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersGetResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersGetResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersGetResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersGetResponseComposite =
  | usersGetResponse200
  | usersGetResponse400
  | usersGetResponse401
  | usersGetResponse403
  | usersGetResponse404
  | usersGetResponse409
  | usersGetResponse500;

export type usersGetResponse = usersGetResponseComposite & {
  headers: Headers;
};

export const getUsersGetUrl = (id: string) => {
  return `/v1/users/${id}`;
};

export const usersGet = async (
  id: string,
  options?: RequestInit,
): Promise<usersGetResponse> => {
  return customInstance<usersGetResponse>(getUsersGetUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getUsersGetQueryKey = (id: string) => {
  return [`/v1/users/${id}`] as const;
};

export const getUsersGetInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof usersGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGet>>> = ({
    signal,
  }) => usersGet(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof usersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGet>>
>;
export type UsersGetInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGet>>,
          TError,
          Awaited<ReturnType<typeof usersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGet>>,
          TError,
          Awaited<ReturnType<typeof usersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get users
 */

export function useUsersGetInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGet>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersGetInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUsersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGet>>> = ({
    signal,
  }) => usersGet(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type UsersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGet>>
>;
export type UsersGetQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersGet<
  TData = Awaited<ReturnType<typeof usersGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGet>>,
          TError,
          Awaited<ReturnType<typeof usersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGet<
  TData = Awaited<ReturnType<typeof usersGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGet>>,
          TError,
          Awaited<ReturnType<typeof usersGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGet<
  TData = Awaited<ReturnType<typeof usersGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get users
 */

export function useUsersGet<
  TData = Awaited<ReturnType<typeof usersGet>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersGetQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update user
 * @summary update users
 */
export type usersUpdateResponse200 = {
  data: User;
  status: 200;
};

export type usersUpdateResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersUpdateResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersUpdateResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersUpdateResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersUpdateResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersUpdateResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersUpdateResponseComposite =
  | usersUpdateResponse200
  | usersUpdateResponse400
  | usersUpdateResponse401
  | usersUpdateResponse403
  | usersUpdateResponse404
  | usersUpdateResponse409
  | usersUpdateResponse500;

export type usersUpdateResponse = usersUpdateResponseComposite & {
  headers: Headers;
};

export const getUsersUpdateUrl = (id: string) => {
  return `/v1/users/${id}`;
};

export const usersUpdate = async (
  id: string,
  updateRequestBody4: UpdateRequestBody4,
  options?: RequestInit,
): Promise<usersUpdateResponse> => {
  return customInstance<usersUpdateResponse>(getUsersUpdateUrl(id), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateRequestBody4),
  });
};

export const getUsersUpdateMutationOptions = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdate>>,
    TError,
    { id: string; data: UpdateRequestBody4 },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdate>>,
  TError,
  { id: string; data: UpdateRequestBody4 },
  TContext
> => {
  const mutationKey = ["usersUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdate>>,
    { id: string; data: UpdateRequestBody4 }
  > = (props) => {
    const { id, data } = props ?? {};

    return usersUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdate>>
>;
export type UsersUpdateMutationBody = UpdateRequestBody4;
export type UsersUpdateMutationError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

/**
 * @summary update users
 */
export const useUsersUpdate = <
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdate>>,
    TError,
    { id: string; data: UpdateRequestBody4 },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdate>>,
  TError,
  { id: string; data: UpdateRequestBody4 },
  TContext
> => {
  const mutationOptions = getUsersUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get user organizations
 * @summary get_organizations users
 */
export type usersGetOrganizationsResponse200 = {
  data: GetOrganizationsResponseBody;
  status: 200;
};

export type usersGetOrganizationsResponse400 = {
  data: BadRequestError;
  status: 400;
};

export type usersGetOrganizationsResponse401 = {
  data: UnauthorizedError;
  status: 401;
};

export type usersGetOrganizationsResponse403 = {
  data: ForbiddenError;
  status: 403;
};

export type usersGetOrganizationsResponse404 = {
  data: NotFoundError;
  status: 404;
};

export type usersGetOrganizationsResponse409 = {
  data: ConflictError;
  status: 409;
};

export type usersGetOrganizationsResponse500 = {
  data: InternalServerError;
  status: 500;
};

export type usersGetOrganizationsResponseComposite =
  | usersGetOrganizationsResponse200
  | usersGetOrganizationsResponse400
  | usersGetOrganizationsResponse401
  | usersGetOrganizationsResponse403
  | usersGetOrganizationsResponse404
  | usersGetOrganizationsResponse409
  | usersGetOrganizationsResponse500;

export type usersGetOrganizationsResponse =
  usersGetOrganizationsResponseComposite & {
    headers: Headers;
  };

export const getUsersGetOrganizationsUrl = (id: string) => {
  return `/v1/users/${id}/organizations`;
};

export const usersGetOrganizations = async (
  id: string,
  options?: RequestInit,
): Promise<usersGetOrganizationsResponse> => {
  return customInstance<usersGetOrganizationsResponse>(
    getUsersGetOrganizationsUrl(id),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getUsersGetOrganizationsQueryKey = (id: string) => {
  return [`/v1/users/${id}/organizations`] as const;
};

export const getUsersGetOrganizationsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetOrganizations>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersGetOrganizationsQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetOrganizations>>
  > = ({ signal }) => usersGetOrganizations(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof usersGetOrganizations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetOrganizationsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetOrganizations>>
>;
export type UsersGetOrganizationsInfiniteQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersGetOrganizationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetOrganizations>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetOrganizations>>,
          TError,
          Awaited<ReturnType<typeof usersGetOrganizations>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetOrganizationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetOrganizations>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetOrganizations>>,
          TError,
          Awaited<ReturnType<typeof usersGetOrganizations>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetOrganizationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetOrganizations>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get_organizations users
 */

export function useUsersGetOrganizationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof usersGetOrganizations>>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersGetOrganizationsInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUsersGetOrganizationsQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetOrganizations>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersGetOrganizationsQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetOrganizations>>
  > = ({ signal }) => usersGetOrganizations(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetOrganizations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetOrganizationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetOrganizations>>
>;
export type UsersGetOrganizationsQueryError =
  | BadRequestError
  | UnauthorizedError
  | ForbiddenError
  | NotFoundError
  | ConflictError
  | InternalServerError;

export function useUsersGetOrganizations<
  TData = Awaited<ReturnType<typeof usersGetOrganizations>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetOrganizations>>,
          TError,
          Awaited<ReturnType<typeof usersGetOrganizations>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetOrganizations<
  TData = Awaited<ReturnType<typeof usersGetOrganizations>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetOrganizations>>,
          TError,
          Awaited<ReturnType<typeof usersGetOrganizations>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUsersGetOrganizations<
  TData = Awaited<ReturnType<typeof usersGetOrganizations>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get_organizations users
 */

export function useUsersGetOrganizations<
  TData = Awaited<ReturnType<typeof usersGetOrganizations>>,
  TError =
    | BadRequestError
    | UnauthorizedError
    | ForbiddenError
    | NotFoundError
    | ConflictError
    | InternalServerError,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetOrganizations>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUsersGetOrganizationsQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
