// Copyright 2022-present Wakflo
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build ignore
// +build ignore

package main

import (
	"log"

	"entgo.io/ent/schema/edge"

	// "entgo.io/contrib/entgql"
	// "entgo.io/contrib/entoas"
	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"

	// "entgo.io/ent/entc/gen"
	"github.com/flume/enthistory"
	"github.com/hedwigz/entviz"
	_ "github.com/xraph/frank/ent/runtime"
)

func main() {
	// ql, err := entgql.NewExtension(
	// 	entgql.WithConfigPath("../services/api/gqlgen.yml"),
	// 	entgql.WithSchemaGenerator(),
	// 	entgql.WithSchemaPath("../services/api/schemas/ent.graphqls"),
	// 	entgql.WithWhereInputs(true),
	// 	entgql.WithNodeDescriptor(true),
	// 	// entgql.WithRelaySpec(true),
	// )
	// if err != nil {
	// 	log.Fatalf("creating entgql extension: %v", err)
	// }

	// spec := new(ogen.Spec)
	// oas, err := entoas.NewExtension(
	//	entoas.Spec(spec),
	//	//entoas.SpecTitle("Armado"),
	//	//entoas.SpecDescription("API to manage fridges and their cooled contents. **ICY!**"),
	//	//entoas.SpecVersion("0.0.1"),
	//	entoas.SimpleModels(),
	// )
	// //oas, err := entoas.NewExtension()
	// if err != nil {
	//	log.Fatalf("creating entoas extension: %v", err)
	// }

	// ogentle, err := ogen.NewExtension(spec)
	// if err != nil {
	//	log.Fatalf("creating ogent extension: %v", err)
	// }

	opts := entc.Extensions(
		// ql,
		// ogentle,
		// oas,
		// &EncodeExtension{},
		entviz.Extension{},
		enthistory.NewHistoryExtension(
		// enthistory.WithUpdatedBy("created_by", enthistory.ValueTypeInt),
		// enthistory.WithAuditing(),
		// enthistory.WithHistoryTimeIndex(),
		),
		// ex,
	)
	moreopts := []entc.Option{
		opts,
		// entc.FeatureNames("privacy", "schema/snapshot", "sql/execquery", "intercept", "sql/upsert", "sql/modifier", "sql/lock", "entql", "sql/versioned-migration", "sql/schemaconfig", "namedges"),
	}

	err := entc.Generate("./schema", &gen.Config{
		// Hooks: []gen.Hook{
		// 	&ImportAliasHook{},
		// },
		Header: `
			// Copyright 2023-present XRaph LLC. All rights reserved.
			// This source code is licensed under the XRaph LLC license found
			// in the LICENSE file in the root directory of this source tree.
			// Code generated by ent, DO NOT EDIT.
		`,
		Features: []gen.Feature{
			gen.FeaturePrivacy,
			// gen.FeatureSchemaConfig,
			gen.FeatureSnapshot,
			gen.FeatureExecQuery,
			gen.FeatureIntercept,
			gen.FeatureUpsert,
			gen.FeatureModifier,
			gen.FeatureLock,
			gen.FeatureEntQL,
			gen.FeatureVersionedMigration,
			gen.FeatureNamedEdges,
			gen.FeatureBidiEdgeRefs,
		}}, moreopts...)
	if err != nil {
		log.Fatalf("running ent codegen: %v", err)
	}
}

// EncodeExtension is an implementation of entc.Extension that adds a MarshalJSON
// method to each generated type <T> and inlines the Edges field to the top level JSON.
type EncodeExtension struct {
	entc.DefaultExtension
}

// Templates of the extension.
func (e *EncodeExtension) Templates() []*gen.Template {
	return []*gen.Template{
		gen.MustParse(gen.NewTemplate("model/additional/jsonencode").
			Parse(`
{{ if $.Edges }}
	// MarshalJSON implements the json.Marshaler interface.
	func ({{ $.Receiver }} *{{ $.Name }}) MarshalJSON() ([]byte, error) {
		type Alias {{ $.Name }}
		return json.Marshal(&struct {
			*Alias
			{{ $.Name }}Edges
		}{
			Alias: (*Alias)({{ $.Receiver }}),
			{{ $.Name }}Edges: {{ $.Receiver }}.Edges,
		})
	}
{{ end }}
`)),
	}
}

// Hooks of the extension.
func (e *EncodeExtension) Hooks() []gen.Hook {
	return []gen.Hook{
		func(next gen.Generator) gen.Generator {
			return gen.GenerateFunc(func(g *gen.Graph) error {
				tag := edge.Annotation{StructTag: `json:"-"`}
				for _, n := range g.Nodes {
					n.Annotations.Set(tag.Name(), tag)
				}
				return next.Generate(g)
			})
		},
	}
}

var _ entc.Extension = (*EncodeExtension)(nil)
