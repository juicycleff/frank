// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/juicycleff/frank/ent/apikey"
	"github.com/juicycleff/frank/ent/emailtemplate"
	"github.com/juicycleff/frank/ent/featureflag"
	"github.com/juicycleff/frank/ent/identityprovider"
	"github.com/juicycleff/frank/ent/mfa"
	"github.com/juicycleff/frank/ent/oauthauthorization"
	"github.com/juicycleff/frank/ent/oauthclient"
	"github.com/juicycleff/frank/ent/oauthscope"
	"github.com/juicycleff/frank/ent/oauthtoken"
	"github.com/juicycleff/frank/ent/organization"
	"github.com/juicycleff/frank/ent/organizationfeature"
	"github.com/juicycleff/frank/ent/passkey"
	"github.com/juicycleff/frank/ent/permission"
	"github.com/juicycleff/frank/ent/predicate"
	"github.com/juicycleff/frank/ent/role"
	"github.com/juicycleff/frank/ent/session"
	"github.com/juicycleff/frank/ent/ssostate"
	"github.com/juicycleff/frank/ent/user"
	"github.com/juicycleff/frank/ent/verification"
	"github.com/juicycleff/frank/ent/webhook"
	"github.com/juicycleff/frank/ent/webhookevent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiKey              = "ApiKey"
	TypeEmailTemplate       = "EmailTemplate"
	TypeFeatureFlag         = "FeatureFlag"
	TypeIdentityProvider    = "IdentityProvider"
	TypeMFA                 = "MFA"
	TypeOAuthAuthorization  = "OAuthAuthorization"
	TypeOAuthClient         = "OAuthClient"
	TypeOAuthScope          = "OAuthScope"
	TypeOAuthToken          = "OAuthToken"
	TypeOrganization        = "Organization"
	TypeOrganizationFeature = "OrganizationFeature"
	TypePasskey             = "Passkey"
	TypePermission          = "Permission"
	TypeRole                = "Role"
	TypeSSOState            = "SSOState"
	TypeSession             = "Session"
	TypeUser                = "User"
	TypeVerification        = "Verification"
	TypeWebhook             = "Webhook"
	TypeWebhookEvent        = "WebhookEvent"
)

// ApiKeyMutation represents an operation that mutates the ApiKey nodes in the graph.
type ApiKeyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	key                 *string
	hashed_key          *string
	_type               *string
	active              *bool
	permissions         *[]string
	appendpermissions   []string
	scopes              *[]string
	appendscopes        []string
	metadata            *map[string]interface{}
	last_used           *time.Time
	expires_at          *time.Time
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	organization        *string
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*ApiKey, error)
	predicates          []predicate.ApiKey
}

var _ ent.Mutation = (*ApiKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*ApiKeyMutation)

// newApiKeyMutation creates new mutation for the ApiKey entity.
func newApiKeyMutation(c config, op Op, opts ...apikeyOption) *ApiKeyMutation {
	m := &ApiKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeApiKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiKeyID sets the ID field of the mutation.
func withApiKeyID(id string) apikeyOption {
	return func(m *ApiKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiKey
		)
		m.oldValue = func(ctx context.Context) (*ApiKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiKey sets the old ApiKey of the mutation.
func withApiKey(node *ApiKey) apikeyOption {
	return func(m *ApiKeyMutation) {
		m.oldValue = func(context.Context) (*ApiKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiKey entities.
func (m *ApiKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ApiKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiKeyMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *ApiKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ApiKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ApiKeyMutation) ResetKey() {
	m.key = nil
}

// SetHashedKey sets the "hashed_key" field.
func (m *ApiKeyMutation) SetHashedKey(s string) {
	m.hashed_key = &s
}

// HashedKey returns the value of the "hashed_key" field in the mutation.
func (m *ApiKeyMutation) HashedKey() (r string, exists bool) {
	v := m.hashed_key
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedKey returns the old "hashed_key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldHashedKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedKey: %w", err)
	}
	return oldValue.HashedKey, nil
}

// ResetHashedKey resets all changes to the "hashed_key" field.
func (m *ApiKeyMutation) ResetHashedKey() {
	m.hashed_key = nil
}

// SetUserID sets the "user_id" field.
func (m *ApiKeyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiKeyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApiKeyMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApiKeyMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiKeyMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, apikey.FieldUserID)
}

// SetOrganizationID sets the "organization_id" field.
func (m *ApiKeyMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ApiKeyMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *ApiKeyMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[apikey.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *ApiKeyMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ApiKeyMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, apikey.FieldOrganizationID)
}

// SetType sets the "type" field.
func (m *ApiKeyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ApiKeyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ApiKeyMutation) ResetType() {
	m._type = nil
}

// SetActive sets the "active" field.
func (m *ApiKeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ApiKeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ApiKeyMutation) ResetActive() {
	m.active = nil
}

// SetPermissions sets the "permissions" field.
func (m *ApiKeyMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *ApiKeyMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *ApiKeyMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *ApiKeyMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ClearPermissions clears the value of the "permissions" field.
func (m *ApiKeyMutation) ClearPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	m.clearedFields[apikey.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *ApiKeyMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[apikey.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *ApiKeyMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	delete(m.clearedFields, apikey.FieldPermissions)
}

// SetScopes sets the "scopes" field.
func (m *ApiKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ApiKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ApiKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ApiKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *ApiKeyMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apikey.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *ApiKeyMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ApiKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apikey.FieldScopes)
}

// SetMetadata sets the "metadata" field.
func (m *ApiKeyMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ApiKeyMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ApiKeyMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[apikey.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ApiKeyMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[apikey.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ApiKeyMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, apikey.FieldMetadata)
}

// SetLastUsed sets the "last_used" field.
func (m *ApiKeyMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *ApiKeyMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *ApiKeyMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[apikey.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *ApiKeyMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *ApiKeyMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, apikey.FieldLastUsed)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ApiKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ApiKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ApiKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ApiKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ApiKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiKeyMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ApiKeyMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[apikey.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ApiKeyMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ApiKeyMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ApiKeyMutation builder.
func (m *ApiKeyMutation) Where(ps ...predicate.ApiKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiKey).
func (m *ApiKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiKeyMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.hashed_key != nil {
		fields = append(fields, apikey.FieldHashedKey)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, apikey.FieldOrganizationID)
	}
	if m._type != nil {
		fields = append(fields, apikey.FieldType)
	}
	if m.active != nil {
		fields = append(fields, apikey.FieldActive)
	}
	if m.permissions != nil {
		fields = append(fields, apikey.FieldPermissions)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.metadata != nil {
		fields = append(fields, apikey.FieldMetadata)
	}
	if m.last_used != nil {
		fields = append(fields, apikey.FieldLastUsed)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldHashedKey:
		return m.HashedKey()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldOrganizationID:
		return m.OrganizationID()
	case apikey.FieldType:
		return m.GetType()
	case apikey.FieldActive:
		return m.Active()
	case apikey.FieldPermissions:
		return m.Permissions()
	case apikey.FieldScopes:
		return m.Scopes()
	case apikey.FieldMetadata:
		return m.Metadata()
	case apikey.FieldLastUsed:
		return m.LastUsed()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldHashedKey:
		return m.OldHashedKey(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case apikey.FieldType:
		return m.OldType(ctx)
	case apikey.FieldActive:
		return m.OldActive(ctx)
	case apikey.FieldPermissions:
		return m.OldPermissions(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	case apikey.FieldMetadata:
		return m.OldMetadata(ctx)
	case apikey.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldHashedKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedKey(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case apikey.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case apikey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case apikey.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apikey.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case apikey.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldUserID) {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.FieldCleared(apikey.FieldOrganizationID) {
		fields = append(fields, apikey.FieldOrganizationID)
	}
	if m.FieldCleared(apikey.FieldPermissions) {
		fields = append(fields, apikey.FieldPermissions)
	}
	if m.FieldCleared(apikey.FieldScopes) {
		fields = append(fields, apikey.FieldScopes)
	}
	if m.FieldCleared(apikey.FieldMetadata) {
		fields = append(fields, apikey.FieldMetadata)
	}
	if m.FieldCleared(apikey.FieldLastUsed) {
		fields = append(fields, apikey.FieldLastUsed)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ClearUserID()
		return nil
	case apikey.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case apikey.FieldPermissions:
		m.ClearPermissions()
		return nil
	case apikey.FieldScopes:
		m.ClearScopes()
		return nil
	case apikey.FieldMetadata:
		m.ClearMetadata()
		return nil
	case apikey.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ApiKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldHashedKey:
		m.ResetHashedKey()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case apikey.FieldType:
		m.ResetType()
		return nil
	case apikey.FieldActive:
		m.ResetActive()
		return nil
	case apikey.FieldPermissions:
		m.ResetPermissions()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	case apikey.FieldMetadata:
		m.ResetMetadata()
		return nil
	case apikey.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, apikey.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, apikey.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ApiKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ApiKey edge %s", name)
}

// EmailTemplateMutation represents an operation that mutates the EmailTemplate nodes in the graph.
type EmailTemplateMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	subject         *string
	_type           *string
	html_content    *string
	text_content    *string
	organization_id *string
	active          *bool
	system          *bool
	locale          *string
	metadata        *map[string]interface{}
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*EmailTemplate, error)
	predicates      []predicate.EmailTemplate
}

var _ ent.Mutation = (*EmailTemplateMutation)(nil)

// emailtemplateOption allows management of the mutation configuration using functional options.
type emailtemplateOption func(*EmailTemplateMutation)

// newEmailTemplateMutation creates new mutation for the EmailTemplate entity.
func newEmailTemplateMutation(c config, op Op, opts ...emailtemplateOption) *EmailTemplateMutation {
	m := &EmailTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailTemplateID sets the ID field of the mutation.
func withEmailTemplateID(id string) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailTemplate
		)
		m.oldValue = func(ctx context.Context) (*EmailTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailTemplate sets the old EmailTemplate of the mutation.
func withEmailTemplate(node *EmailTemplate) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		m.oldValue = func(context.Context) (*EmailTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailTemplate entities.
func (m *EmailTemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailTemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailTemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EmailTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailTemplateMutation) ResetName() {
	m.name = nil
}

// SetSubject sets the "subject" field.
func (m *EmailTemplateMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailTemplateMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailTemplateMutation) ResetSubject() {
	m.subject = nil
}

// SetType sets the "type" field.
func (m *EmailTemplateMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EmailTemplateMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EmailTemplateMutation) ResetType() {
	m._type = nil
}

// SetHTMLContent sets the "html_content" field.
func (m *EmailTemplateMutation) SetHTMLContent(s string) {
	m.html_content = &s
}

// HTMLContent returns the value of the "html_content" field in the mutation.
func (m *EmailTemplateMutation) HTMLContent() (r string, exists bool) {
	v := m.html_content
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLContent returns the old "html_content" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldHTMLContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLContent: %w", err)
	}
	return oldValue.HTMLContent, nil
}

// ResetHTMLContent resets all changes to the "html_content" field.
func (m *EmailTemplateMutation) ResetHTMLContent() {
	m.html_content = nil
}

// SetTextContent sets the "text_content" field.
func (m *EmailTemplateMutation) SetTextContent(s string) {
	m.text_content = &s
}

// TextContent returns the value of the "text_content" field in the mutation.
func (m *EmailTemplateMutation) TextContent() (r string, exists bool) {
	v := m.text_content
	if v == nil {
		return
	}
	return *v, true
}

// OldTextContent returns the old "text_content" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldTextContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextContent: %w", err)
	}
	return oldValue.TextContent, nil
}

// ClearTextContent clears the value of the "text_content" field.
func (m *EmailTemplateMutation) ClearTextContent() {
	m.text_content = nil
	m.clearedFields[emailtemplate.FieldTextContent] = struct{}{}
}

// TextContentCleared returns if the "text_content" field was cleared in this mutation.
func (m *EmailTemplateMutation) TextContentCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldTextContent]
	return ok
}

// ResetTextContent resets all changes to the "text_content" field.
func (m *EmailTemplateMutation) ResetTextContent() {
	m.text_content = nil
	delete(m.clearedFields, emailtemplate.FieldTextContent)
}

// SetOrganizationID sets the "organization_id" field.
func (m *EmailTemplateMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EmailTemplateMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *EmailTemplateMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[emailtemplate.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *EmailTemplateMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EmailTemplateMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, emailtemplate.FieldOrganizationID)
}

// SetActive sets the "active" field.
func (m *EmailTemplateMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *EmailTemplateMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *EmailTemplateMutation) ResetActive() {
	m.active = nil
}

// SetSystem sets the "system" field.
func (m *EmailTemplateMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *EmailTemplateMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *EmailTemplateMutation) ResetSystem() {
	m.system = nil
}

// SetLocale sets the "locale" field.
func (m *EmailTemplateMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *EmailTemplateMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *EmailTemplateMutation) ResetLocale() {
	m.locale = nil
}

// SetMetadata sets the "metadata" field.
func (m *EmailTemplateMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EmailTemplateMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EmailTemplateMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[emailtemplate.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EmailTemplateMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EmailTemplateMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, emailtemplate.FieldMetadata)
}

// Where appends a list predicates to the EmailTemplateMutation builder.
func (m *EmailTemplateMutation) Where(ps ...predicate.EmailTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailTemplate).
func (m *EmailTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailTemplateMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, emailtemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailtemplate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, emailtemplate.FieldName)
	}
	if m.subject != nil {
		fields = append(fields, emailtemplate.FieldSubject)
	}
	if m._type != nil {
		fields = append(fields, emailtemplate.FieldType)
	}
	if m.html_content != nil {
		fields = append(fields, emailtemplate.FieldHTMLContent)
	}
	if m.text_content != nil {
		fields = append(fields, emailtemplate.FieldTextContent)
	}
	if m.organization_id != nil {
		fields = append(fields, emailtemplate.FieldOrganizationID)
	}
	if m.active != nil {
		fields = append(fields, emailtemplate.FieldActive)
	}
	if m.system != nil {
		fields = append(fields, emailtemplate.FieldSystem)
	}
	if m.locale != nil {
		fields = append(fields, emailtemplate.FieldLocale)
	}
	if m.metadata != nil {
		fields = append(fields, emailtemplate.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailtemplate.FieldCreatedAt:
		return m.CreatedAt()
	case emailtemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailtemplate.FieldName:
		return m.Name()
	case emailtemplate.FieldSubject:
		return m.Subject()
	case emailtemplate.FieldType:
		return m.GetType()
	case emailtemplate.FieldHTMLContent:
		return m.HTMLContent()
	case emailtemplate.FieldTextContent:
		return m.TextContent()
	case emailtemplate.FieldOrganizationID:
		return m.OrganizationID()
	case emailtemplate.FieldActive:
		return m.Active()
	case emailtemplate.FieldSystem:
		return m.System()
	case emailtemplate.FieldLocale:
		return m.Locale()
	case emailtemplate.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailtemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailtemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailtemplate.FieldName:
		return m.OldName(ctx)
	case emailtemplate.FieldSubject:
		return m.OldSubject(ctx)
	case emailtemplate.FieldType:
		return m.OldType(ctx)
	case emailtemplate.FieldHTMLContent:
		return m.OldHTMLContent(ctx)
	case emailtemplate.FieldTextContent:
		return m.OldTextContent(ctx)
	case emailtemplate.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case emailtemplate.FieldActive:
		return m.OldActive(ctx)
	case emailtemplate.FieldSystem:
		return m.OldSystem(ctx)
	case emailtemplate.FieldLocale:
		return m.OldLocale(ctx)
	case emailtemplate.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown EmailTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailtemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailtemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailtemplate.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case emailtemplate.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case emailtemplate.FieldHTMLContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLContent(v)
		return nil
	case emailtemplate.FieldTextContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextContent(v)
		return nil
	case emailtemplate.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case emailtemplate.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case emailtemplate.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case emailtemplate.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case emailtemplate.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailtemplate.FieldTextContent) {
		fields = append(fields, emailtemplate.FieldTextContent)
	}
	if m.FieldCleared(emailtemplate.FieldOrganizationID) {
		fields = append(fields, emailtemplate.FieldOrganizationID)
	}
	if m.FieldCleared(emailtemplate.FieldMetadata) {
		fields = append(fields, emailtemplate.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ClearField(name string) error {
	switch name {
	case emailtemplate.FieldTextContent:
		m.ClearTextContent()
		return nil
	case emailtemplate.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case emailtemplate.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ResetField(name string) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailtemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailtemplate.FieldName:
		m.ResetName()
		return nil
	case emailtemplate.FieldSubject:
		m.ResetSubject()
		return nil
	case emailtemplate.FieldType:
		m.ResetType()
		return nil
	case emailtemplate.FieldHTMLContent:
		m.ResetHTMLContent()
		return nil
	case emailtemplate.FieldTextContent:
		m.ResetTextContent()
		return nil
	case emailtemplate.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case emailtemplate.FieldActive:
		m.ResetActive()
		return nil
	case emailtemplate.FieldSystem:
		m.ResetSystem()
		return nil
	case emailtemplate.FieldLocale:
		m.ResetLocale()
		return nil
	case emailtemplate.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmailTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmailTemplate edge %s", name)
}

// FeatureFlagMutation represents an operation that mutates the FeatureFlag nodes in the graph.
type FeatureFlagMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	key                  *string
	description          *string
	enabled              *bool
	is_premium           *bool
	component            *featureflag.Component
	clearedFields        map[string]struct{}
	organizations        map[string]struct{}
	removedorganizations map[string]struct{}
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*FeatureFlag, error)
	predicates           []predicate.FeatureFlag
}

var _ ent.Mutation = (*FeatureFlagMutation)(nil)

// featureflagOption allows management of the mutation configuration using functional options.
type featureflagOption func(*FeatureFlagMutation)

// newFeatureFlagMutation creates new mutation for the FeatureFlag entity.
func newFeatureFlagMutation(c config, op Op, opts ...featureflagOption) *FeatureFlagMutation {
	m := &FeatureFlagMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureFlagID sets the ID field of the mutation.
func withFeatureFlagID(id string) featureflagOption {
	return func(m *FeatureFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureFlag
		)
		m.oldValue = func(ctx context.Context) (*FeatureFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureFlag sets the old FeatureFlag of the mutation.
func withFeatureFlag(node *FeatureFlag) featureflagOption {
	return func(m *FeatureFlagMutation) {
		m.oldValue = func(context.Context) (*FeatureFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureFlag entities.
func (m *FeatureFlagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureFlagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureFlagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureFlagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureFlagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureFlagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureFlagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureFlagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureFlagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FeatureFlagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureFlagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureFlagMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *FeatureFlagMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *FeatureFlagMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *FeatureFlagMutation) ResetKey() {
	m.key = nil
}

// SetDescription sets the "description" field.
func (m *FeatureFlagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureFlagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeatureFlagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[featureflag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeatureFlagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[featureflag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureFlagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, featureflag.FieldDescription)
}

// SetEnabled sets the "enabled" field.
func (m *FeatureFlagMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FeatureFlagMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FeatureFlagMutation) ResetEnabled() {
	m.enabled = nil
}

// SetIsPremium sets the "is_premium" field.
func (m *FeatureFlagMutation) SetIsPremium(b bool) {
	m.is_premium = &b
}

// IsPremium returns the value of the "is_premium" field in the mutation.
func (m *FeatureFlagMutation) IsPremium() (r bool, exists bool) {
	v := m.is_premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_premium" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_premium" field.
func (m *FeatureFlagMutation) ResetIsPremium() {
	m.is_premium = nil
}

// SetComponent sets the "component" field.
func (m *FeatureFlagMutation) SetComponent(f featureflag.Component) {
	m.component = &f
}

// Component returns the value of the "component" field in the mutation.
func (m *FeatureFlagMutation) Component() (r featureflag.Component, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldComponent(ctx context.Context) (v featureflag.Component, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent resets all changes to the "component" field.
func (m *FeatureFlagMutation) ResetComponent() {
	m.component = nil
}

// AddOrganizationIDs adds the "organizations" edge to the OrganizationFeature entity by ids.
func (m *FeatureFlagMutation) AddOrganizationIDs(ids ...string) {
	if m.organizations == nil {
		m.organizations = make(map[string]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the OrganizationFeature entity.
func (m *FeatureFlagMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the OrganizationFeature entity was cleared.
func (m *FeatureFlagMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the OrganizationFeature entity by IDs.
func (m *FeatureFlagMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the OrganizationFeature entity.
func (m *FeatureFlagMutation) RemovedOrganizationsIDs() (ids []string) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *FeatureFlagMutation) OrganizationsIDs() (ids []string) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *FeatureFlagMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the FeatureFlagMutation builder.
func (m *FeatureFlagMutation) Where(ps ...predicate.FeatureFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureFlag).
func (m *FeatureFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureFlagMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, featureflag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featureflag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, featureflag.FieldName)
	}
	if m.key != nil {
		fields = append(fields, featureflag.FieldKey)
	}
	if m.description != nil {
		fields = append(fields, featureflag.FieldDescription)
	}
	if m.enabled != nil {
		fields = append(fields, featureflag.FieldEnabled)
	}
	if m.is_premium != nil {
		fields = append(fields, featureflag.FieldIsPremium)
	}
	if m.component != nil {
		fields = append(fields, featureflag.FieldComponent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featureflag.FieldCreatedAt:
		return m.CreatedAt()
	case featureflag.FieldUpdatedAt:
		return m.UpdatedAt()
	case featureflag.FieldName:
		return m.Name()
	case featureflag.FieldKey:
		return m.Key()
	case featureflag.FieldDescription:
		return m.Description()
	case featureflag.FieldEnabled:
		return m.Enabled()
	case featureflag.FieldIsPremium:
		return m.IsPremium()
	case featureflag.FieldComponent:
		return m.Component()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featureflag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featureflag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case featureflag.FieldName:
		return m.OldName(ctx)
	case featureflag.FieldKey:
		return m.OldKey(ctx)
	case featureflag.FieldDescription:
		return m.OldDescription(ctx)
	case featureflag.FieldEnabled:
		return m.OldEnabled(ctx)
	case featureflag.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case featureflag.FieldComponent:
		return m.OldComponent(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featureflag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featureflag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case featureflag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case featureflag.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case featureflag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case featureflag.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case featureflag.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case featureflag.FieldComponent:
		v, ok := value.(featureflag.Component)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureFlagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureFlagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureFlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featureflag.FieldDescription) {
		fields = append(fields, featureflag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ClearField(name string) error {
	switch name {
	case featureflag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ResetField(name string) error {
	switch name {
	case featureflag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featureflag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case featureflag.FieldName:
		m.ResetName()
		return nil
	case featureflag.FieldKey:
		m.ResetKey()
		return nil
	case featureflag.FieldDescription:
		m.ResetDescription()
		return nil
	case featureflag.FieldEnabled:
		m.ResetEnabled()
		return nil
	case featureflag.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case featureflag.FieldComponent:
		m.ResetComponent()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organizations != nil {
		edges = append(edges, featureflag.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureFlagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featureflag.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganizations != nil {
		edges = append(edges, featureflag.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureFlagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featureflag.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganizations {
		edges = append(edges, featureflag.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureFlagMutation) EdgeCleared(name string) bool {
	switch name {
	case featureflag.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureFlagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureFlagMutation) ResetEdge(name string) error {
	switch name {
	case featureflag.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag edge %s", name)
}

// IdentityProviderMutation represents an operation that mutates the IdentityProvider nodes in the graph.
type IdentityProviderMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	name                   *string
	provider_type          *string
	client_id              *string
	client_secret          *string
	issuer                 *string
	authorization_endpoint *string
	token_endpoint         *string
	userinfo_endpoint      *string
	jwks_uri               *string
	metadata_url           *string
	redirect_uri           *string
	certificate            *string
	private_key            *string
	active                 *bool
	primary                *bool
	domains                *[]string
	appenddomains          []string
	attributes_mapping     *map[string]string
	metadata               *map[string]interface{}
	clearedFields          map[string]struct{}
	organization           *string
	clearedorganization    bool
	done                   bool
	oldValue               func(context.Context) (*IdentityProvider, error)
	predicates             []predicate.IdentityProvider
}

var _ ent.Mutation = (*IdentityProviderMutation)(nil)

// identityproviderOption allows management of the mutation configuration using functional options.
type identityproviderOption func(*IdentityProviderMutation)

// newIdentityProviderMutation creates new mutation for the IdentityProvider entity.
func newIdentityProviderMutation(c config, op Op, opts ...identityproviderOption) *IdentityProviderMutation {
	m := &IdentityProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentityProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityProviderID sets the ID field of the mutation.
func withIdentityProviderID(id string) identityproviderOption {
	return func(m *IdentityProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *IdentityProvider
		)
		m.oldValue = func(ctx context.Context) (*IdentityProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdentityProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentityProvider sets the old IdentityProvider of the mutation.
func withIdentityProvider(node *IdentityProvider) identityproviderOption {
	return func(m *IdentityProviderMutation) {
		m.oldValue = func(context.Context) (*IdentityProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdentityProvider entities.
func (m *IdentityProviderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityProviderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityProviderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdentityProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IdentityProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdentityProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdentityProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IdentityProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IdentityProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IdentityProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *IdentityProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IdentityProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IdentityProviderMutation) ResetName() {
	m.name = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *IdentityProviderMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *IdentityProviderMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *IdentityProviderMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetProviderType sets the "provider_type" field.
func (m *IdentityProviderMutation) SetProviderType(s string) {
	m.provider_type = &s
}

// ProviderType returns the value of the "provider_type" field in the mutation.
func (m *IdentityProviderMutation) ProviderType() (r string, exists bool) {
	v := m.provider_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderType returns the old "provider_type" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldProviderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderType: %w", err)
	}
	return oldValue.ProviderType, nil
}

// ResetProviderType resets all changes to the "provider_type" field.
func (m *IdentityProviderMutation) ResetProviderType() {
	m.provider_type = nil
}

// SetClientID sets the "client_id" field.
func (m *IdentityProviderMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *IdentityProviderMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *IdentityProviderMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[identityprovider.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *IdentityProviderMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *IdentityProviderMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, identityprovider.FieldClientID)
}

// SetClientSecret sets the "client_secret" field.
func (m *IdentityProviderMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *IdentityProviderMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *IdentityProviderMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[identityprovider.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *IdentityProviderMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *IdentityProviderMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, identityprovider.FieldClientSecret)
}

// SetIssuer sets the "issuer" field.
func (m *IdentityProviderMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *IdentityProviderMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ClearIssuer clears the value of the "issuer" field.
func (m *IdentityProviderMutation) ClearIssuer() {
	m.issuer = nil
	m.clearedFields[identityprovider.FieldIssuer] = struct{}{}
}

// IssuerCleared returns if the "issuer" field was cleared in this mutation.
func (m *IdentityProviderMutation) IssuerCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldIssuer]
	return ok
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *IdentityProviderMutation) ResetIssuer() {
	m.issuer = nil
	delete(m.clearedFields, identityprovider.FieldIssuer)
}

// SetAuthorizationEndpoint sets the "authorization_endpoint" field.
func (m *IdentityProviderMutation) SetAuthorizationEndpoint(s string) {
	m.authorization_endpoint = &s
}

// AuthorizationEndpoint returns the value of the "authorization_endpoint" field in the mutation.
func (m *IdentityProviderMutation) AuthorizationEndpoint() (r string, exists bool) {
	v := m.authorization_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationEndpoint returns the old "authorization_endpoint" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldAuthorizationEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationEndpoint: %w", err)
	}
	return oldValue.AuthorizationEndpoint, nil
}

// ClearAuthorizationEndpoint clears the value of the "authorization_endpoint" field.
func (m *IdentityProviderMutation) ClearAuthorizationEndpoint() {
	m.authorization_endpoint = nil
	m.clearedFields[identityprovider.FieldAuthorizationEndpoint] = struct{}{}
}

// AuthorizationEndpointCleared returns if the "authorization_endpoint" field was cleared in this mutation.
func (m *IdentityProviderMutation) AuthorizationEndpointCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldAuthorizationEndpoint]
	return ok
}

// ResetAuthorizationEndpoint resets all changes to the "authorization_endpoint" field.
func (m *IdentityProviderMutation) ResetAuthorizationEndpoint() {
	m.authorization_endpoint = nil
	delete(m.clearedFields, identityprovider.FieldAuthorizationEndpoint)
}

// SetTokenEndpoint sets the "token_endpoint" field.
func (m *IdentityProviderMutation) SetTokenEndpoint(s string) {
	m.token_endpoint = &s
}

// TokenEndpoint returns the value of the "token_endpoint" field in the mutation.
func (m *IdentityProviderMutation) TokenEndpoint() (r string, exists bool) {
	v := m.token_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenEndpoint returns the old "token_endpoint" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldTokenEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenEndpoint: %w", err)
	}
	return oldValue.TokenEndpoint, nil
}

// ClearTokenEndpoint clears the value of the "token_endpoint" field.
func (m *IdentityProviderMutation) ClearTokenEndpoint() {
	m.token_endpoint = nil
	m.clearedFields[identityprovider.FieldTokenEndpoint] = struct{}{}
}

// TokenEndpointCleared returns if the "token_endpoint" field was cleared in this mutation.
func (m *IdentityProviderMutation) TokenEndpointCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldTokenEndpoint]
	return ok
}

// ResetTokenEndpoint resets all changes to the "token_endpoint" field.
func (m *IdentityProviderMutation) ResetTokenEndpoint() {
	m.token_endpoint = nil
	delete(m.clearedFields, identityprovider.FieldTokenEndpoint)
}

// SetUserinfoEndpoint sets the "userinfo_endpoint" field.
func (m *IdentityProviderMutation) SetUserinfoEndpoint(s string) {
	m.userinfo_endpoint = &s
}

// UserinfoEndpoint returns the value of the "userinfo_endpoint" field in the mutation.
func (m *IdentityProviderMutation) UserinfoEndpoint() (r string, exists bool) {
	v := m.userinfo_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldUserinfoEndpoint returns the old "userinfo_endpoint" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldUserinfoEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserinfoEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserinfoEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserinfoEndpoint: %w", err)
	}
	return oldValue.UserinfoEndpoint, nil
}

// ClearUserinfoEndpoint clears the value of the "userinfo_endpoint" field.
func (m *IdentityProviderMutation) ClearUserinfoEndpoint() {
	m.userinfo_endpoint = nil
	m.clearedFields[identityprovider.FieldUserinfoEndpoint] = struct{}{}
}

// UserinfoEndpointCleared returns if the "userinfo_endpoint" field was cleared in this mutation.
func (m *IdentityProviderMutation) UserinfoEndpointCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldUserinfoEndpoint]
	return ok
}

// ResetUserinfoEndpoint resets all changes to the "userinfo_endpoint" field.
func (m *IdentityProviderMutation) ResetUserinfoEndpoint() {
	m.userinfo_endpoint = nil
	delete(m.clearedFields, identityprovider.FieldUserinfoEndpoint)
}

// SetJwksURI sets the "jwks_uri" field.
func (m *IdentityProviderMutation) SetJwksURI(s string) {
	m.jwks_uri = &s
}

// JwksURI returns the value of the "jwks_uri" field in the mutation.
func (m *IdentityProviderMutation) JwksURI() (r string, exists bool) {
	v := m.jwks_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldJwksURI returns the old "jwks_uri" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldJwksURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJwksURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJwksURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJwksURI: %w", err)
	}
	return oldValue.JwksURI, nil
}

// ClearJwksURI clears the value of the "jwks_uri" field.
func (m *IdentityProviderMutation) ClearJwksURI() {
	m.jwks_uri = nil
	m.clearedFields[identityprovider.FieldJwksURI] = struct{}{}
}

// JwksURICleared returns if the "jwks_uri" field was cleared in this mutation.
func (m *IdentityProviderMutation) JwksURICleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldJwksURI]
	return ok
}

// ResetJwksURI resets all changes to the "jwks_uri" field.
func (m *IdentityProviderMutation) ResetJwksURI() {
	m.jwks_uri = nil
	delete(m.clearedFields, identityprovider.FieldJwksURI)
}

// SetMetadataURL sets the "metadata_url" field.
func (m *IdentityProviderMutation) SetMetadataURL(s string) {
	m.metadata_url = &s
}

// MetadataURL returns the value of the "metadata_url" field in the mutation.
func (m *IdentityProviderMutation) MetadataURL() (r string, exists bool) {
	v := m.metadata_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataURL returns the old "metadata_url" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldMetadataURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataURL: %w", err)
	}
	return oldValue.MetadataURL, nil
}

// ClearMetadataURL clears the value of the "metadata_url" field.
func (m *IdentityProviderMutation) ClearMetadataURL() {
	m.metadata_url = nil
	m.clearedFields[identityprovider.FieldMetadataURL] = struct{}{}
}

// MetadataURLCleared returns if the "metadata_url" field was cleared in this mutation.
func (m *IdentityProviderMutation) MetadataURLCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldMetadataURL]
	return ok
}

// ResetMetadataURL resets all changes to the "metadata_url" field.
func (m *IdentityProviderMutation) ResetMetadataURL() {
	m.metadata_url = nil
	delete(m.clearedFields, identityprovider.FieldMetadataURL)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *IdentityProviderMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *IdentityProviderMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *IdentityProviderMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[identityprovider.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *IdentityProviderMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *IdentityProviderMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, identityprovider.FieldRedirectURI)
}

// SetCertificate sets the "certificate" field.
func (m *IdentityProviderMutation) SetCertificate(s string) {
	m.certificate = &s
}

// Certificate returns the value of the "certificate" field in the mutation.
func (m *IdentityProviderMutation) Certificate() (r string, exists bool) {
	v := m.certificate
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificate returns the old "certificate" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldCertificate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificate: %w", err)
	}
	return oldValue.Certificate, nil
}

// ClearCertificate clears the value of the "certificate" field.
func (m *IdentityProviderMutation) ClearCertificate() {
	m.certificate = nil
	m.clearedFields[identityprovider.FieldCertificate] = struct{}{}
}

// CertificateCleared returns if the "certificate" field was cleared in this mutation.
func (m *IdentityProviderMutation) CertificateCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldCertificate]
	return ok
}

// ResetCertificate resets all changes to the "certificate" field.
func (m *IdentityProviderMutation) ResetCertificate() {
	m.certificate = nil
	delete(m.clearedFields, identityprovider.FieldCertificate)
}

// SetPrivateKey sets the "private_key" field.
func (m *IdentityProviderMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *IdentityProviderMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ClearPrivateKey clears the value of the "private_key" field.
func (m *IdentityProviderMutation) ClearPrivateKey() {
	m.private_key = nil
	m.clearedFields[identityprovider.FieldPrivateKey] = struct{}{}
}

// PrivateKeyCleared returns if the "private_key" field was cleared in this mutation.
func (m *IdentityProviderMutation) PrivateKeyCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldPrivateKey]
	return ok
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *IdentityProviderMutation) ResetPrivateKey() {
	m.private_key = nil
	delete(m.clearedFields, identityprovider.FieldPrivateKey)
}

// SetActive sets the "active" field.
func (m *IdentityProviderMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *IdentityProviderMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *IdentityProviderMutation) ResetActive() {
	m.active = nil
}

// SetPrimary sets the "primary" field.
func (m *IdentityProviderMutation) SetPrimary(b bool) {
	m.primary = &b
}

// Primary returns the value of the "primary" field in the mutation.
func (m *IdentityProviderMutation) Primary() (r bool, exists bool) {
	v := m.primary
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimary returns the old "primary" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimary: %w", err)
	}
	return oldValue.Primary, nil
}

// ResetPrimary resets all changes to the "primary" field.
func (m *IdentityProviderMutation) ResetPrimary() {
	m.primary = nil
}

// SetDomains sets the "domains" field.
func (m *IdentityProviderMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *IdentityProviderMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *IdentityProviderMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *IdentityProviderMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *IdentityProviderMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[identityprovider.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *IdentityProviderMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *IdentityProviderMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, identityprovider.FieldDomains)
}

// SetAttributesMapping sets the "attributes_mapping" field.
func (m *IdentityProviderMutation) SetAttributesMapping(value map[string]string) {
	m.attributes_mapping = &value
}

// AttributesMapping returns the value of the "attributes_mapping" field in the mutation.
func (m *IdentityProviderMutation) AttributesMapping() (r map[string]string, exists bool) {
	v := m.attributes_mapping
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributesMapping returns the old "attributes_mapping" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldAttributesMapping(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributesMapping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributesMapping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributesMapping: %w", err)
	}
	return oldValue.AttributesMapping, nil
}

// ClearAttributesMapping clears the value of the "attributes_mapping" field.
func (m *IdentityProviderMutation) ClearAttributesMapping() {
	m.attributes_mapping = nil
	m.clearedFields[identityprovider.FieldAttributesMapping] = struct{}{}
}

// AttributesMappingCleared returns if the "attributes_mapping" field was cleared in this mutation.
func (m *IdentityProviderMutation) AttributesMappingCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldAttributesMapping]
	return ok
}

// ResetAttributesMapping resets all changes to the "attributes_mapping" field.
func (m *IdentityProviderMutation) ResetAttributesMapping() {
	m.attributes_mapping = nil
	delete(m.clearedFields, identityprovider.FieldAttributesMapping)
}

// SetMetadata sets the "metadata" field.
func (m *IdentityProviderMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *IdentityProviderMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the IdentityProvider entity.
// If the IdentityProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityProviderMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *IdentityProviderMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[identityprovider.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *IdentityProviderMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[identityprovider.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *IdentityProviderMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, identityprovider.FieldMetadata)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *IdentityProviderMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[identityprovider.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *IdentityProviderMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *IdentityProviderMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *IdentityProviderMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the IdentityProviderMutation builder.
func (m *IdentityProviderMutation) Where(ps ...predicate.IdentityProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentityProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentityProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdentityProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentityProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentityProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdentityProvider).
func (m *IdentityProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityProviderMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, identityprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, identityprovider.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, identityprovider.FieldName)
	}
	if m.organization != nil {
		fields = append(fields, identityprovider.FieldOrganizationID)
	}
	if m.provider_type != nil {
		fields = append(fields, identityprovider.FieldProviderType)
	}
	if m.client_id != nil {
		fields = append(fields, identityprovider.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, identityprovider.FieldClientSecret)
	}
	if m.issuer != nil {
		fields = append(fields, identityprovider.FieldIssuer)
	}
	if m.authorization_endpoint != nil {
		fields = append(fields, identityprovider.FieldAuthorizationEndpoint)
	}
	if m.token_endpoint != nil {
		fields = append(fields, identityprovider.FieldTokenEndpoint)
	}
	if m.userinfo_endpoint != nil {
		fields = append(fields, identityprovider.FieldUserinfoEndpoint)
	}
	if m.jwks_uri != nil {
		fields = append(fields, identityprovider.FieldJwksURI)
	}
	if m.metadata_url != nil {
		fields = append(fields, identityprovider.FieldMetadataURL)
	}
	if m.redirect_uri != nil {
		fields = append(fields, identityprovider.FieldRedirectURI)
	}
	if m.certificate != nil {
		fields = append(fields, identityprovider.FieldCertificate)
	}
	if m.private_key != nil {
		fields = append(fields, identityprovider.FieldPrivateKey)
	}
	if m.active != nil {
		fields = append(fields, identityprovider.FieldActive)
	}
	if m.primary != nil {
		fields = append(fields, identityprovider.FieldPrimary)
	}
	if m.domains != nil {
		fields = append(fields, identityprovider.FieldDomains)
	}
	if m.attributes_mapping != nil {
		fields = append(fields, identityprovider.FieldAttributesMapping)
	}
	if m.metadata != nil {
		fields = append(fields, identityprovider.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identityprovider.FieldCreatedAt:
		return m.CreatedAt()
	case identityprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case identityprovider.FieldName:
		return m.Name()
	case identityprovider.FieldOrganizationID:
		return m.OrganizationID()
	case identityprovider.FieldProviderType:
		return m.ProviderType()
	case identityprovider.FieldClientID:
		return m.ClientID()
	case identityprovider.FieldClientSecret:
		return m.ClientSecret()
	case identityprovider.FieldIssuer:
		return m.Issuer()
	case identityprovider.FieldAuthorizationEndpoint:
		return m.AuthorizationEndpoint()
	case identityprovider.FieldTokenEndpoint:
		return m.TokenEndpoint()
	case identityprovider.FieldUserinfoEndpoint:
		return m.UserinfoEndpoint()
	case identityprovider.FieldJwksURI:
		return m.JwksURI()
	case identityprovider.FieldMetadataURL:
		return m.MetadataURL()
	case identityprovider.FieldRedirectURI:
		return m.RedirectURI()
	case identityprovider.FieldCertificate:
		return m.Certificate()
	case identityprovider.FieldPrivateKey:
		return m.PrivateKey()
	case identityprovider.FieldActive:
		return m.Active()
	case identityprovider.FieldPrimary:
		return m.Primary()
	case identityprovider.FieldDomains:
		return m.Domains()
	case identityprovider.FieldAttributesMapping:
		return m.AttributesMapping()
	case identityprovider.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identityprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case identityprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case identityprovider.FieldName:
		return m.OldName(ctx)
	case identityprovider.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case identityprovider.FieldProviderType:
		return m.OldProviderType(ctx)
	case identityprovider.FieldClientID:
		return m.OldClientID(ctx)
	case identityprovider.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case identityprovider.FieldIssuer:
		return m.OldIssuer(ctx)
	case identityprovider.FieldAuthorizationEndpoint:
		return m.OldAuthorizationEndpoint(ctx)
	case identityprovider.FieldTokenEndpoint:
		return m.OldTokenEndpoint(ctx)
	case identityprovider.FieldUserinfoEndpoint:
		return m.OldUserinfoEndpoint(ctx)
	case identityprovider.FieldJwksURI:
		return m.OldJwksURI(ctx)
	case identityprovider.FieldMetadataURL:
		return m.OldMetadataURL(ctx)
	case identityprovider.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case identityprovider.FieldCertificate:
		return m.OldCertificate(ctx)
	case identityprovider.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case identityprovider.FieldActive:
		return m.OldActive(ctx)
	case identityprovider.FieldPrimary:
		return m.OldPrimary(ctx)
	case identityprovider.FieldDomains:
		return m.OldDomains(ctx)
	case identityprovider.FieldAttributesMapping:
		return m.OldAttributesMapping(ctx)
	case identityprovider.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown IdentityProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identityprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case identityprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case identityprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case identityprovider.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case identityprovider.FieldProviderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderType(v)
		return nil
	case identityprovider.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case identityprovider.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case identityprovider.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case identityprovider.FieldAuthorizationEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationEndpoint(v)
		return nil
	case identityprovider.FieldTokenEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenEndpoint(v)
		return nil
	case identityprovider.FieldUserinfoEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserinfoEndpoint(v)
		return nil
	case identityprovider.FieldJwksURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJwksURI(v)
		return nil
	case identityprovider.FieldMetadataURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataURL(v)
		return nil
	case identityprovider.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case identityprovider.FieldCertificate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificate(v)
		return nil
	case identityprovider.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case identityprovider.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case identityprovider.FieldPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimary(v)
		return nil
	case identityprovider.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case identityprovider.FieldAttributesMapping:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributesMapping(v)
		return nil
	case identityprovider.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IdentityProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(identityprovider.FieldClientID) {
		fields = append(fields, identityprovider.FieldClientID)
	}
	if m.FieldCleared(identityprovider.FieldClientSecret) {
		fields = append(fields, identityprovider.FieldClientSecret)
	}
	if m.FieldCleared(identityprovider.FieldIssuer) {
		fields = append(fields, identityprovider.FieldIssuer)
	}
	if m.FieldCleared(identityprovider.FieldAuthorizationEndpoint) {
		fields = append(fields, identityprovider.FieldAuthorizationEndpoint)
	}
	if m.FieldCleared(identityprovider.FieldTokenEndpoint) {
		fields = append(fields, identityprovider.FieldTokenEndpoint)
	}
	if m.FieldCleared(identityprovider.FieldUserinfoEndpoint) {
		fields = append(fields, identityprovider.FieldUserinfoEndpoint)
	}
	if m.FieldCleared(identityprovider.FieldJwksURI) {
		fields = append(fields, identityprovider.FieldJwksURI)
	}
	if m.FieldCleared(identityprovider.FieldMetadataURL) {
		fields = append(fields, identityprovider.FieldMetadataURL)
	}
	if m.FieldCleared(identityprovider.FieldRedirectURI) {
		fields = append(fields, identityprovider.FieldRedirectURI)
	}
	if m.FieldCleared(identityprovider.FieldCertificate) {
		fields = append(fields, identityprovider.FieldCertificate)
	}
	if m.FieldCleared(identityprovider.FieldPrivateKey) {
		fields = append(fields, identityprovider.FieldPrivateKey)
	}
	if m.FieldCleared(identityprovider.FieldDomains) {
		fields = append(fields, identityprovider.FieldDomains)
	}
	if m.FieldCleared(identityprovider.FieldAttributesMapping) {
		fields = append(fields, identityprovider.FieldAttributesMapping)
	}
	if m.FieldCleared(identityprovider.FieldMetadata) {
		fields = append(fields, identityprovider.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityProviderMutation) ClearField(name string) error {
	switch name {
	case identityprovider.FieldClientID:
		m.ClearClientID()
		return nil
	case identityprovider.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case identityprovider.FieldIssuer:
		m.ClearIssuer()
		return nil
	case identityprovider.FieldAuthorizationEndpoint:
		m.ClearAuthorizationEndpoint()
		return nil
	case identityprovider.FieldTokenEndpoint:
		m.ClearTokenEndpoint()
		return nil
	case identityprovider.FieldUserinfoEndpoint:
		m.ClearUserinfoEndpoint()
		return nil
	case identityprovider.FieldJwksURI:
		m.ClearJwksURI()
		return nil
	case identityprovider.FieldMetadataURL:
		m.ClearMetadataURL()
		return nil
	case identityprovider.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	case identityprovider.FieldCertificate:
		m.ClearCertificate()
		return nil
	case identityprovider.FieldPrivateKey:
		m.ClearPrivateKey()
		return nil
	case identityprovider.FieldDomains:
		m.ClearDomains()
		return nil
	case identityprovider.FieldAttributesMapping:
		m.ClearAttributesMapping()
		return nil
	case identityprovider.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityProviderMutation) ResetField(name string) error {
	switch name {
	case identityprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case identityprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case identityprovider.FieldName:
		m.ResetName()
		return nil
	case identityprovider.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case identityprovider.FieldProviderType:
		m.ResetProviderType()
		return nil
	case identityprovider.FieldClientID:
		m.ResetClientID()
		return nil
	case identityprovider.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case identityprovider.FieldIssuer:
		m.ResetIssuer()
		return nil
	case identityprovider.FieldAuthorizationEndpoint:
		m.ResetAuthorizationEndpoint()
		return nil
	case identityprovider.FieldTokenEndpoint:
		m.ResetTokenEndpoint()
		return nil
	case identityprovider.FieldUserinfoEndpoint:
		m.ResetUserinfoEndpoint()
		return nil
	case identityprovider.FieldJwksURI:
		m.ResetJwksURI()
		return nil
	case identityprovider.FieldMetadataURL:
		m.ResetMetadataURL()
		return nil
	case identityprovider.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case identityprovider.FieldCertificate:
		m.ResetCertificate()
		return nil
	case identityprovider.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case identityprovider.FieldActive:
		m.ResetActive()
		return nil
	case identityprovider.FieldPrimary:
		m.ResetPrimary()
		return nil
	case identityprovider.FieldDomains:
		m.ResetDomains()
		return nil
	case identityprovider.FieldAttributesMapping:
		m.ResetAttributesMapping()
		return nil
	case identityprovider.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, identityprovider.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identityprovider.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, identityprovider.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case identityprovider.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityProviderMutation) ClearEdge(name string) error {
	switch name {
	case identityprovider.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityProviderMutation) ResetEdge(name string) error {
	switch name {
	case identityprovider.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown IdentityProvider edge %s", name)
}

// MFAMutation represents an operation that mutates the MFA nodes in the graph.
type MFAMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	method             *string
	secret             *string
	verified           *bool
	active             *bool
	backup_codes       *[]string
	appendbackup_codes []string
	phone_number       *string
	email              *string
	last_used          *time.Time
	metadata           *map[string]interface{}
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*MFA, error)
	predicates         []predicate.MFA
}

var _ ent.Mutation = (*MFAMutation)(nil)

// mfaOption allows management of the mutation configuration using functional options.
type mfaOption func(*MFAMutation)

// newMFAMutation creates new mutation for the MFA entity.
func newMFAMutation(c config, op Op, opts ...mfaOption) *MFAMutation {
	m := &MFAMutation{
		config:        c,
		op:            op,
		typ:           TypeMFA,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMFAID sets the ID field of the mutation.
func withMFAID(id string) mfaOption {
	return func(m *MFAMutation) {
		var (
			err   error
			once  sync.Once
			value *MFA
		)
		m.oldValue = func(ctx context.Context) (*MFA, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MFA.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMFA sets the old MFA of the mutation.
func withMFA(node *MFA) mfaOption {
	return func(m *MFAMutation) {
		m.oldValue = func(context.Context) (*MFA, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MFAMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MFAMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MFA entities.
func (m *MFAMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MFAMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MFAMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MFA.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MFAMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MFAMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MFAMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MFAMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MFAMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MFAMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MFAMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MFAMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MFAMutation) ResetUserID() {
	m.user = nil
}

// SetMethod sets the "method" field.
func (m *MFAMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *MFAMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *MFAMutation) ResetMethod() {
	m.method = nil
}

// SetSecret sets the "secret" field.
func (m *MFAMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *MFAMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *MFAMutation) ResetSecret() {
	m.secret = nil
}

// SetVerified sets the "verified" field.
func (m *MFAMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *MFAMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *MFAMutation) ResetVerified() {
	m.verified = nil
}

// SetActive sets the "active" field.
func (m *MFAMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *MFAMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *MFAMutation) ResetActive() {
	m.active = nil
}

// SetBackupCodes sets the "backup_codes" field.
func (m *MFAMutation) SetBackupCodes(s []string) {
	m.backup_codes = &s
	m.appendbackup_codes = nil
}

// BackupCodes returns the value of the "backup_codes" field in the mutation.
func (m *MFAMutation) BackupCodes() (r []string, exists bool) {
	v := m.backup_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupCodes returns the old "backup_codes" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldBackupCodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupCodes: %w", err)
	}
	return oldValue.BackupCodes, nil
}

// AppendBackupCodes adds s to the "backup_codes" field.
func (m *MFAMutation) AppendBackupCodes(s []string) {
	m.appendbackup_codes = append(m.appendbackup_codes, s...)
}

// AppendedBackupCodes returns the list of values that were appended to the "backup_codes" field in this mutation.
func (m *MFAMutation) AppendedBackupCodes() ([]string, bool) {
	if len(m.appendbackup_codes) == 0 {
		return nil, false
	}
	return m.appendbackup_codes, true
}

// ClearBackupCodes clears the value of the "backup_codes" field.
func (m *MFAMutation) ClearBackupCodes() {
	m.backup_codes = nil
	m.appendbackup_codes = nil
	m.clearedFields[mfa.FieldBackupCodes] = struct{}{}
}

// BackupCodesCleared returns if the "backup_codes" field was cleared in this mutation.
func (m *MFAMutation) BackupCodesCleared() bool {
	_, ok := m.clearedFields[mfa.FieldBackupCodes]
	return ok
}

// ResetBackupCodes resets all changes to the "backup_codes" field.
func (m *MFAMutation) ResetBackupCodes() {
	m.backup_codes = nil
	m.appendbackup_codes = nil
	delete(m.clearedFields, mfa.FieldBackupCodes)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *MFAMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *MFAMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *MFAMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[mfa.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *MFAMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[mfa.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *MFAMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, mfa.FieldPhoneNumber)
}

// SetEmail sets the "email" field.
func (m *MFAMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MFAMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MFAMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[mfa.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MFAMutation) EmailCleared() bool {
	_, ok := m.clearedFields[mfa.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MFAMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, mfa.FieldEmail)
}

// SetLastUsed sets the "last_used" field.
func (m *MFAMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *MFAMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *MFAMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[mfa.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *MFAMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[mfa.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *MFAMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, mfa.FieldLastUsed)
}

// SetMetadata sets the "metadata" field.
func (m *MFAMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MFAMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the MFA entity.
// If the MFA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFAMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MFAMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[mfa.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MFAMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[mfa.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MFAMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, mfa.FieldMetadata)
}

// ClearUser clears the "user" edge to the User entity.
func (m *MFAMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mfa.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MFAMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MFAMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MFAMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MFAMutation builder.
func (m *MFAMutation) Where(ps ...predicate.MFA) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MFAMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MFAMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MFA, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MFAMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MFAMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MFA).
func (m *MFAMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MFAMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, mfa.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mfa.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, mfa.FieldUserID)
	}
	if m.method != nil {
		fields = append(fields, mfa.FieldMethod)
	}
	if m.secret != nil {
		fields = append(fields, mfa.FieldSecret)
	}
	if m.verified != nil {
		fields = append(fields, mfa.FieldVerified)
	}
	if m.active != nil {
		fields = append(fields, mfa.FieldActive)
	}
	if m.backup_codes != nil {
		fields = append(fields, mfa.FieldBackupCodes)
	}
	if m.phone_number != nil {
		fields = append(fields, mfa.FieldPhoneNumber)
	}
	if m.email != nil {
		fields = append(fields, mfa.FieldEmail)
	}
	if m.last_used != nil {
		fields = append(fields, mfa.FieldLastUsed)
	}
	if m.metadata != nil {
		fields = append(fields, mfa.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MFAMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mfa.FieldCreatedAt:
		return m.CreatedAt()
	case mfa.FieldUpdatedAt:
		return m.UpdatedAt()
	case mfa.FieldUserID:
		return m.UserID()
	case mfa.FieldMethod:
		return m.Method()
	case mfa.FieldSecret:
		return m.Secret()
	case mfa.FieldVerified:
		return m.Verified()
	case mfa.FieldActive:
		return m.Active()
	case mfa.FieldBackupCodes:
		return m.BackupCodes()
	case mfa.FieldPhoneNumber:
		return m.PhoneNumber()
	case mfa.FieldEmail:
		return m.Email()
	case mfa.FieldLastUsed:
		return m.LastUsed()
	case mfa.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MFAMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mfa.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mfa.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mfa.FieldUserID:
		return m.OldUserID(ctx)
	case mfa.FieldMethod:
		return m.OldMethod(ctx)
	case mfa.FieldSecret:
		return m.OldSecret(ctx)
	case mfa.FieldVerified:
		return m.OldVerified(ctx)
	case mfa.FieldActive:
		return m.OldActive(ctx)
	case mfa.FieldBackupCodes:
		return m.OldBackupCodes(ctx)
	case mfa.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case mfa.FieldEmail:
		return m.OldEmail(ctx)
	case mfa.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case mfa.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown MFA field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFAMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mfa.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mfa.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mfa.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mfa.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case mfa.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case mfa.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case mfa.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case mfa.FieldBackupCodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupCodes(v)
		return nil
	case mfa.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case mfa.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case mfa.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case mfa.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown MFA field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MFAMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MFAMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFAMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MFA numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MFAMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mfa.FieldBackupCodes) {
		fields = append(fields, mfa.FieldBackupCodes)
	}
	if m.FieldCleared(mfa.FieldPhoneNumber) {
		fields = append(fields, mfa.FieldPhoneNumber)
	}
	if m.FieldCleared(mfa.FieldEmail) {
		fields = append(fields, mfa.FieldEmail)
	}
	if m.FieldCleared(mfa.FieldLastUsed) {
		fields = append(fields, mfa.FieldLastUsed)
	}
	if m.FieldCleared(mfa.FieldMetadata) {
		fields = append(fields, mfa.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MFAMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MFAMutation) ClearField(name string) error {
	switch name {
	case mfa.FieldBackupCodes:
		m.ClearBackupCodes()
		return nil
	case mfa.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case mfa.FieldEmail:
		m.ClearEmail()
		return nil
	case mfa.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case mfa.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown MFA nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MFAMutation) ResetField(name string) error {
	switch name {
	case mfa.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mfa.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mfa.FieldUserID:
		m.ResetUserID()
		return nil
	case mfa.FieldMethod:
		m.ResetMethod()
		return nil
	case mfa.FieldSecret:
		m.ResetSecret()
		return nil
	case mfa.FieldVerified:
		m.ResetVerified()
		return nil
	case mfa.FieldActive:
		m.ResetActive()
		return nil
	case mfa.FieldBackupCodes:
		m.ResetBackupCodes()
		return nil
	case mfa.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case mfa.FieldEmail:
		m.ResetEmail()
		return nil
	case mfa.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case mfa.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown MFA field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MFAMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, mfa.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MFAMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mfa.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MFAMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MFAMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MFAMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, mfa.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MFAMutation) EdgeCleared(name string) bool {
	switch name {
	case mfa.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MFAMutation) ClearEdge(name string) error {
	switch name {
	case mfa.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MFA unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MFAMutation) ResetEdge(name string) error {
	switch name {
	case mfa.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown MFA edge %s", name)
}

// OAuthAuthorizationMutation represents an operation that mutates the OAuthAuthorization nodes in the graph.
type OAuthAuthorizationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	organization_id       *string
	code                  *string
	code_challenge        *string
	code_challenge_method *string
	redirect_uri          *string
	scope_names           *[]string
	appendscope_names     []string
	used                  *bool
	used_at               *time.Time
	expires_at            *time.Time
	state                 *string
	nonce                 *string
	clearedFields         map[string]struct{}
	client                *string
	clearedclient         bool
	user                  *string
	cleareduser           bool
	scopes                map[string]struct{}
	removedscopes         map[string]struct{}
	clearedscopes         bool
	done                  bool
	oldValue              func(context.Context) (*OAuthAuthorization, error)
	predicates            []predicate.OAuthAuthorization
}

var _ ent.Mutation = (*OAuthAuthorizationMutation)(nil)

// oauthauthorizationOption allows management of the mutation configuration using functional options.
type oauthauthorizationOption func(*OAuthAuthorizationMutation)

// newOAuthAuthorizationMutation creates new mutation for the OAuthAuthorization entity.
func newOAuthAuthorizationMutation(c config, op Op, opts ...oauthauthorizationOption) *OAuthAuthorizationMutation {
	m := &OAuthAuthorizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthAuthorization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthAuthorizationID sets the ID field of the mutation.
func withOAuthAuthorizationID(id string) oauthauthorizationOption {
	return func(m *OAuthAuthorizationMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthAuthorization
		)
		m.oldValue = func(ctx context.Context) (*OAuthAuthorization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthAuthorization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthAuthorization sets the old OAuthAuthorization of the mutation.
func withOAuthAuthorization(node *OAuthAuthorization) oauthauthorizationOption {
	return func(m *OAuthAuthorizationMutation) {
		m.oldValue = func(context.Context) (*OAuthAuthorization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthAuthorizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthAuthorizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthAuthorization entities.
func (m *OAuthAuthorizationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthAuthorizationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthAuthorizationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthAuthorization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthAuthorizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthAuthorizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthAuthorizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthAuthorizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthAuthorizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthAuthorizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClientID sets the "client_id" field.
func (m *OAuthAuthorizationMutation) SetClientID(s string) {
	m.client = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthAuthorizationMutation) ClientID() (r string, exists bool) {
	v := m.client
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthAuthorizationMutation) ResetClientID() {
	m.client = nil
}

// SetUserID sets the "user_id" field.
func (m *OAuthAuthorizationMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OAuthAuthorizationMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OAuthAuthorizationMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OAuthAuthorizationMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OAuthAuthorizationMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OAuthAuthorizationMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[oauthauthorization.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OAuthAuthorizationMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, oauthauthorization.FieldOrganizationID)
}

// SetCode sets the "code" field.
func (m *OAuthAuthorizationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OAuthAuthorizationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *OAuthAuthorizationMutation) ClearCode() {
	m.code = nil
	m.clearedFields[oauthauthorization.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) CodeCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *OAuthAuthorizationMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, oauthauthorization.FieldCode)
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *OAuthAuthorizationMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *OAuthAuthorizationMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ClearCodeChallenge clears the value of the "code_challenge" field.
func (m *OAuthAuthorizationMutation) ClearCodeChallenge() {
	m.code_challenge = nil
	m.clearedFields[oauthauthorization.FieldCodeChallenge] = struct{}{}
}

// CodeChallengeCleared returns if the "code_challenge" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) CodeChallengeCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldCodeChallenge]
	return ok
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *OAuthAuthorizationMutation) ResetCodeChallenge() {
	m.code_challenge = nil
	delete(m.clearedFields, oauthauthorization.FieldCodeChallenge)
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *OAuthAuthorizationMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *OAuthAuthorizationMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ClearCodeChallengeMethod clears the value of the "code_challenge_method" field.
func (m *OAuthAuthorizationMutation) ClearCodeChallengeMethod() {
	m.code_challenge_method = nil
	m.clearedFields[oauthauthorization.FieldCodeChallengeMethod] = struct{}{}
}

// CodeChallengeMethodCleared returns if the "code_challenge_method" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) CodeChallengeMethodCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldCodeChallengeMethod]
	return ok
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *OAuthAuthorizationMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
	delete(m.clearedFields, oauthauthorization.FieldCodeChallengeMethod)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *OAuthAuthorizationMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *OAuthAuthorizationMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *OAuthAuthorizationMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetScopeNames sets the "scope_names" field.
func (m *OAuthAuthorizationMutation) SetScopeNames(s []string) {
	m.scope_names = &s
	m.appendscope_names = nil
}

// ScopeNames returns the value of the "scope_names" field in the mutation.
func (m *OAuthAuthorizationMutation) ScopeNames() (r []string, exists bool) {
	v := m.scope_names
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeNames returns the old "scope_names" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldScopeNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeNames: %w", err)
	}
	return oldValue.ScopeNames, nil
}

// AppendScopeNames adds s to the "scope_names" field.
func (m *OAuthAuthorizationMutation) AppendScopeNames(s []string) {
	m.appendscope_names = append(m.appendscope_names, s...)
}

// AppendedScopeNames returns the list of values that were appended to the "scope_names" field in this mutation.
func (m *OAuthAuthorizationMutation) AppendedScopeNames() ([]string, bool) {
	if len(m.appendscope_names) == 0 {
		return nil, false
	}
	return m.appendscope_names, true
}

// ClearScopeNames clears the value of the "scope_names" field.
func (m *OAuthAuthorizationMutation) ClearScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	m.clearedFields[oauthauthorization.FieldScopeNames] = struct{}{}
}

// ScopeNamesCleared returns if the "scope_names" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) ScopeNamesCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldScopeNames]
	return ok
}

// ResetScopeNames resets all changes to the "scope_names" field.
func (m *OAuthAuthorizationMutation) ResetScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	delete(m.clearedFields, oauthauthorization.FieldScopeNames)
}

// SetUsed sets the "used" field.
func (m *OAuthAuthorizationMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *OAuthAuthorizationMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *OAuthAuthorizationMutation) ResetUsed() {
	m.used = nil
}

// SetUsedAt sets the "used_at" field.
func (m *OAuthAuthorizationMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *OAuthAuthorizationMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *OAuthAuthorizationMutation) ResetUsedAt() {
	m.used_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OAuthAuthorizationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OAuthAuthorizationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OAuthAuthorizationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetState sets the "state" field.
func (m *OAuthAuthorizationMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *OAuthAuthorizationMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *OAuthAuthorizationMutation) ClearState() {
	m.state = nil
	m.clearedFields[oauthauthorization.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) StateCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *OAuthAuthorizationMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, oauthauthorization.FieldState)
}

// SetNonce sets the "nonce" field.
func (m *OAuthAuthorizationMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *OAuthAuthorizationMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the OAuthAuthorization entity.
// If the OAuthAuthorization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthAuthorizationMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ClearNonce clears the value of the "nonce" field.
func (m *OAuthAuthorizationMutation) ClearNonce() {
	m.nonce = nil
	m.clearedFields[oauthauthorization.FieldNonce] = struct{}{}
}

// NonceCleared returns if the "nonce" field was cleared in this mutation.
func (m *OAuthAuthorizationMutation) NonceCleared() bool {
	_, ok := m.clearedFields[oauthauthorization.FieldNonce]
	return ok
}

// ResetNonce resets all changes to the "nonce" field.
func (m *OAuthAuthorizationMutation) ResetNonce() {
	m.nonce = nil
	delete(m.clearedFields, oauthauthorization.FieldNonce)
}

// ClearClient clears the "client" edge to the OAuthClient entity.
func (m *OAuthAuthorizationMutation) ClearClient() {
	m.clearedclient = true
	m.clearedFields[oauthauthorization.FieldClientID] = struct{}{}
}

// ClientCleared reports if the "client" edge to the OAuthClient entity was cleared.
func (m *OAuthAuthorizationMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *OAuthAuthorizationMutation) ClientIDs() (ids []string) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *OAuthAuthorizationMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OAuthAuthorizationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oauthauthorization.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OAuthAuthorizationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OAuthAuthorizationMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OAuthAuthorizationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddScopeIDs adds the "scopes" edge to the OAuthScope entity by ids.
func (m *OAuthAuthorizationMutation) AddScopeIDs(ids ...string) {
	if m.scopes == nil {
		m.scopes = make(map[string]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the OAuthScope entity.
func (m *OAuthAuthorizationMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the OAuthScope entity was cleared.
func (m *OAuthAuthorizationMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the OAuthScope entity by IDs.
func (m *OAuthAuthorizationMutation) RemoveScopeIDs(ids ...string) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the OAuthScope entity.
func (m *OAuthAuthorizationMutation) RemovedScopesIDs() (ids []string) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *OAuthAuthorizationMutation) ScopesIDs() (ids []string) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *OAuthAuthorizationMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// Where appends a list predicates to the OAuthAuthorizationMutation builder.
func (m *OAuthAuthorizationMutation) Where(ps ...predicate.OAuthAuthorization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthAuthorizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthAuthorizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthAuthorization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthAuthorizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthAuthorizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthAuthorization).
func (m *OAuthAuthorizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthAuthorizationMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, oauthauthorization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthauthorization.FieldUpdatedAt)
	}
	if m.client != nil {
		fields = append(fields, oauthauthorization.FieldClientID)
	}
	if m.user != nil {
		fields = append(fields, oauthauthorization.FieldUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, oauthauthorization.FieldOrganizationID)
	}
	if m.code != nil {
		fields = append(fields, oauthauthorization.FieldCode)
	}
	if m.code_challenge != nil {
		fields = append(fields, oauthauthorization.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, oauthauthorization.FieldCodeChallengeMethod)
	}
	if m.redirect_uri != nil {
		fields = append(fields, oauthauthorization.FieldRedirectURI)
	}
	if m.scope_names != nil {
		fields = append(fields, oauthauthorization.FieldScopeNames)
	}
	if m.used != nil {
		fields = append(fields, oauthauthorization.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, oauthauthorization.FieldUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, oauthauthorization.FieldExpiresAt)
	}
	if m.state != nil {
		fields = append(fields, oauthauthorization.FieldState)
	}
	if m.nonce != nil {
		fields = append(fields, oauthauthorization.FieldNonce)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthAuthorizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		return m.CreatedAt()
	case oauthauthorization.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthauthorization.FieldClientID:
		return m.ClientID()
	case oauthauthorization.FieldUserID:
		return m.UserID()
	case oauthauthorization.FieldOrganizationID:
		return m.OrganizationID()
	case oauthauthorization.FieldCode:
		return m.Code()
	case oauthauthorization.FieldCodeChallenge:
		return m.CodeChallenge()
	case oauthauthorization.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case oauthauthorization.FieldRedirectURI:
		return m.RedirectURI()
	case oauthauthorization.FieldScopeNames:
		return m.ScopeNames()
	case oauthauthorization.FieldUsed:
		return m.Used()
	case oauthauthorization.FieldUsedAt:
		return m.UsedAt()
	case oauthauthorization.FieldExpiresAt:
		return m.ExpiresAt()
	case oauthauthorization.FieldState:
		return m.State()
	case oauthauthorization.FieldNonce:
		return m.Nonce()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthAuthorizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthauthorization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthauthorization.FieldClientID:
		return m.OldClientID(ctx)
	case oauthauthorization.FieldUserID:
		return m.OldUserID(ctx)
	case oauthauthorization.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case oauthauthorization.FieldCode:
		return m.OldCode(ctx)
	case oauthauthorization.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case oauthauthorization.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case oauthauthorization.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case oauthauthorization.FieldScopeNames:
		return m.OldScopeNames(ctx)
	case oauthauthorization.FieldUsed:
		return m.OldUsed(ctx)
	case oauthauthorization.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case oauthauthorization.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case oauthauthorization.FieldState:
		return m.OldState(ctx)
	case oauthauthorization.FieldNonce:
		return m.OldNonce(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthAuthorization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthAuthorizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthauthorization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthauthorization.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthauthorization.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthauthorization.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case oauthauthorization.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case oauthauthorization.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case oauthauthorization.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case oauthauthorization.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case oauthauthorization.FieldScopeNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeNames(v)
		return nil
	case oauthauthorization.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case oauthauthorization.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case oauthauthorization.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case oauthauthorization.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case oauthauthorization.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthAuthorizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthAuthorizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthAuthorizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthAuthorization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthAuthorizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthauthorization.FieldOrganizationID) {
		fields = append(fields, oauthauthorization.FieldOrganizationID)
	}
	if m.FieldCleared(oauthauthorization.FieldCode) {
		fields = append(fields, oauthauthorization.FieldCode)
	}
	if m.FieldCleared(oauthauthorization.FieldCodeChallenge) {
		fields = append(fields, oauthauthorization.FieldCodeChallenge)
	}
	if m.FieldCleared(oauthauthorization.FieldCodeChallengeMethod) {
		fields = append(fields, oauthauthorization.FieldCodeChallengeMethod)
	}
	if m.FieldCleared(oauthauthorization.FieldScopeNames) {
		fields = append(fields, oauthauthorization.FieldScopeNames)
	}
	if m.FieldCleared(oauthauthorization.FieldState) {
		fields = append(fields, oauthauthorization.FieldState)
	}
	if m.FieldCleared(oauthauthorization.FieldNonce) {
		fields = append(fields, oauthauthorization.FieldNonce)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthAuthorizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthAuthorizationMutation) ClearField(name string) error {
	switch name {
	case oauthauthorization.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case oauthauthorization.FieldCode:
		m.ClearCode()
		return nil
	case oauthauthorization.FieldCodeChallenge:
		m.ClearCodeChallenge()
		return nil
	case oauthauthorization.FieldCodeChallengeMethod:
		m.ClearCodeChallengeMethod()
		return nil
	case oauthauthorization.FieldScopeNames:
		m.ClearScopeNames()
		return nil
	case oauthauthorization.FieldState:
		m.ClearState()
		return nil
	case oauthauthorization.FieldNonce:
		m.ClearNonce()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthAuthorizationMutation) ResetField(name string) error {
	switch name {
	case oauthauthorization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthauthorization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthauthorization.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthauthorization.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthauthorization.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case oauthauthorization.FieldCode:
		m.ResetCode()
		return nil
	case oauthauthorization.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case oauthauthorization.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case oauthauthorization.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case oauthauthorization.FieldScopeNames:
		m.ResetScopeNames()
		return nil
	case oauthauthorization.FieldUsed:
		m.ResetUsed()
		return nil
	case oauthauthorization.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case oauthauthorization.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case oauthauthorization.FieldState:
		m.ResetState()
		return nil
	case oauthauthorization.FieldNonce:
		m.ResetNonce()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthAuthorizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.client != nil {
		edges = append(edges, oauthauthorization.EdgeClient)
	}
	if m.user != nil {
		edges = append(edges, oauthauthorization.EdgeUser)
	}
	if m.scopes != nil {
		edges = append(edges, oauthauthorization.EdgeScopes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthAuthorizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthauthorization.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case oauthauthorization.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oauthauthorization.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthAuthorizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedscopes != nil {
		edges = append(edges, oauthauthorization.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthAuthorizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthauthorization.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthAuthorizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclient {
		edges = append(edges, oauthauthorization.EdgeClient)
	}
	if m.cleareduser {
		edges = append(edges, oauthauthorization.EdgeUser)
	}
	if m.clearedscopes {
		edges = append(edges, oauthauthorization.EdgeScopes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthAuthorizationMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthauthorization.EdgeClient:
		return m.clearedclient
	case oauthauthorization.EdgeUser:
		return m.cleareduser
	case oauthauthorization.EdgeScopes:
		return m.clearedscopes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthAuthorizationMutation) ClearEdge(name string) error {
	switch name {
	case oauthauthorization.EdgeClient:
		m.ClearClient()
		return nil
	case oauthauthorization.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthAuthorizationMutation) ResetEdge(name string) error {
	switch name {
	case oauthauthorization.EdgeClient:
		m.ResetClient()
		return nil
	case oauthauthorization.EdgeUser:
		m.ResetUser()
		return nil
	case oauthauthorization.EdgeScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OAuthAuthorization edge %s", name)
}

// OAuthClientMutation represents an operation that mutates the OAuthClient nodes in the graph.
type OAuthClientMutation struct {
	config
	op                              Op
	typ                             string
	id                              *string
	created_at                      *time.Time
	updated_at                      *time.Time
	client_id                       *string
	client_secret                   *string
	client_name                     *string
	client_description              *string
	client_uri                      *string
	logo_uri                        *string
	redirect_uris                   *[]string
	appendredirect_uris             []string
	post_logout_redirect_uris       *[]string
	appendpost_logout_redirect_uris []string
	public                          *bool
	active                          *bool
	allowed_cors_origins            *[]string
	appendallowed_cors_origins      []string
	allowed_grant_types             *[]string
	appendallowed_grant_types       []string
	token_expiry_seconds            *int
	addtoken_expiry_seconds         *int
	refresh_token_expiry_seconds    *int
	addrefresh_token_expiry_seconds *int
	auth_code_expiry_seconds        *int
	addauth_code_expiry_seconds     *int
	requires_pkce                   *bool
	requires_consent                *bool
	clearedFields                   map[string]struct{}
	organization                    *string
	clearedorganization             bool
	tokens                          map[string]struct{}
	removedtokens                   map[string]struct{}
	clearedtokens                   bool
	authorizations                  map[string]struct{}
	removedauthorizations           map[string]struct{}
	clearedauthorizations           bool
	scopes                          map[string]struct{}
	removedscopes                   map[string]struct{}
	clearedscopes                   bool
	done                            bool
	oldValue                        func(context.Context) (*OAuthClient, error)
	predicates                      []predicate.OAuthClient
}

var _ ent.Mutation = (*OAuthClientMutation)(nil)

// oauthclientOption allows management of the mutation configuration using functional options.
type oauthclientOption func(*OAuthClientMutation)

// newOAuthClientMutation creates new mutation for the OAuthClient entity.
func newOAuthClientMutation(c config, op Op, opts ...oauthclientOption) *OAuthClientMutation {
	m := &OAuthClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthClientID sets the ID field of the mutation.
func withOAuthClientID(id string) oauthclientOption {
	return func(m *OAuthClientMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthClient
		)
		m.oldValue = func(ctx context.Context) (*OAuthClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthClient sets the old OAuthClient of the mutation.
func withOAuthClient(node *OAuthClient) oauthclientOption {
	return func(m *OAuthClientMutation) {
		m.oldValue = func(context.Context) (*OAuthClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthClient entities.
func (m *OAuthClientMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthClientMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthClientMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClientID sets the "client_id" field.
func (m *OAuthClientMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthClientMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthClientMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OAuthClientMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OAuthClientMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OAuthClientMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetClientName sets the "client_name" field.
func (m *OAuthClientMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *OAuthClientMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *OAuthClientMutation) ResetClientName() {
	m.client_name = nil
}

// SetClientDescription sets the "client_description" field.
func (m *OAuthClientMutation) SetClientDescription(s string) {
	m.client_description = &s
}

// ClientDescription returns the value of the "client_description" field in the mutation.
func (m *OAuthClientMutation) ClientDescription() (r string, exists bool) {
	v := m.client_description
	if v == nil {
		return
	}
	return *v, true
}

// OldClientDescription returns the old "client_description" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientDescription: %w", err)
	}
	return oldValue.ClientDescription, nil
}

// ClearClientDescription clears the value of the "client_description" field.
func (m *OAuthClientMutation) ClearClientDescription() {
	m.client_description = nil
	m.clearedFields[oauthclient.FieldClientDescription] = struct{}{}
}

// ClientDescriptionCleared returns if the "client_description" field was cleared in this mutation.
func (m *OAuthClientMutation) ClientDescriptionCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldClientDescription]
	return ok
}

// ResetClientDescription resets all changes to the "client_description" field.
func (m *OAuthClientMutation) ResetClientDescription() {
	m.client_description = nil
	delete(m.clearedFields, oauthclient.FieldClientDescription)
}

// SetClientURI sets the "client_uri" field.
func (m *OAuthClientMutation) SetClientURI(s string) {
	m.client_uri = &s
}

// ClientURI returns the value of the "client_uri" field in the mutation.
func (m *OAuthClientMutation) ClientURI() (r string, exists bool) {
	v := m.client_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldClientURI returns the old "client_uri" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientURI: %w", err)
	}
	return oldValue.ClientURI, nil
}

// ClearClientURI clears the value of the "client_uri" field.
func (m *OAuthClientMutation) ClearClientURI() {
	m.client_uri = nil
	m.clearedFields[oauthclient.FieldClientURI] = struct{}{}
}

// ClientURICleared returns if the "client_uri" field was cleared in this mutation.
func (m *OAuthClientMutation) ClientURICleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldClientURI]
	return ok
}

// ResetClientURI resets all changes to the "client_uri" field.
func (m *OAuthClientMutation) ResetClientURI() {
	m.client_uri = nil
	delete(m.clearedFields, oauthclient.FieldClientURI)
}

// SetLogoURI sets the "logo_uri" field.
func (m *OAuthClientMutation) SetLogoURI(s string) {
	m.logo_uri = &s
}

// LogoURI returns the value of the "logo_uri" field in the mutation.
func (m *OAuthClientMutation) LogoURI() (r string, exists bool) {
	v := m.logo_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURI returns the old "logo_uri" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldLogoURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURI: %w", err)
	}
	return oldValue.LogoURI, nil
}

// ClearLogoURI clears the value of the "logo_uri" field.
func (m *OAuthClientMutation) ClearLogoURI() {
	m.logo_uri = nil
	m.clearedFields[oauthclient.FieldLogoURI] = struct{}{}
}

// LogoURICleared returns if the "logo_uri" field was cleared in this mutation.
func (m *OAuthClientMutation) LogoURICleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldLogoURI]
	return ok
}

// ResetLogoURI resets all changes to the "logo_uri" field.
func (m *OAuthClientMutation) ResetLogoURI() {
	m.logo_uri = nil
	delete(m.clearedFields, oauthclient.FieldLogoURI)
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *OAuthClientMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *OAuthClientMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *OAuthClientMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *OAuthClientMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *OAuthClientMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
}

// SetPostLogoutRedirectUris sets the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) SetPostLogoutRedirectUris(s []string) {
	m.post_logout_redirect_uris = &s
	m.appendpost_logout_redirect_uris = nil
}

// PostLogoutRedirectUris returns the value of the "post_logout_redirect_uris" field in the mutation.
func (m *OAuthClientMutation) PostLogoutRedirectUris() (r []string, exists bool) {
	v := m.post_logout_redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldPostLogoutRedirectUris returns the old "post_logout_redirect_uris" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldPostLogoutRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostLogoutRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostLogoutRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostLogoutRedirectUris: %w", err)
	}
	return oldValue.PostLogoutRedirectUris, nil
}

// AppendPostLogoutRedirectUris adds s to the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) AppendPostLogoutRedirectUris(s []string) {
	m.appendpost_logout_redirect_uris = append(m.appendpost_logout_redirect_uris, s...)
}

// AppendedPostLogoutRedirectUris returns the list of values that were appended to the "post_logout_redirect_uris" field in this mutation.
func (m *OAuthClientMutation) AppendedPostLogoutRedirectUris() ([]string, bool) {
	if len(m.appendpost_logout_redirect_uris) == 0 {
		return nil, false
	}
	return m.appendpost_logout_redirect_uris, true
}

// ClearPostLogoutRedirectUris clears the value of the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) ClearPostLogoutRedirectUris() {
	m.post_logout_redirect_uris = nil
	m.appendpost_logout_redirect_uris = nil
	m.clearedFields[oauthclient.FieldPostLogoutRedirectUris] = struct{}{}
}

// PostLogoutRedirectUrisCleared returns if the "post_logout_redirect_uris" field was cleared in this mutation.
func (m *OAuthClientMutation) PostLogoutRedirectUrisCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldPostLogoutRedirectUris]
	return ok
}

// ResetPostLogoutRedirectUris resets all changes to the "post_logout_redirect_uris" field.
func (m *OAuthClientMutation) ResetPostLogoutRedirectUris() {
	m.post_logout_redirect_uris = nil
	m.appendpost_logout_redirect_uris = nil
	delete(m.clearedFields, oauthclient.FieldPostLogoutRedirectUris)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OAuthClientMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OAuthClientMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OAuthClientMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[oauthclient.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OAuthClientMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OAuthClientMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, oauthclient.FieldOrganizationID)
}

// SetPublic sets the "public" field.
func (m *OAuthClientMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *OAuthClientMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *OAuthClientMutation) ResetPublic() {
	m.public = nil
}

// SetActive sets the "active" field.
func (m *OAuthClientMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OAuthClientMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OAuthClientMutation) ResetActive() {
	m.active = nil
}

// SetAllowedCorsOrigins sets the "allowed_cors_origins" field.
func (m *OAuthClientMutation) SetAllowedCorsOrigins(s []string) {
	m.allowed_cors_origins = &s
	m.appendallowed_cors_origins = nil
}

// AllowedCorsOrigins returns the value of the "allowed_cors_origins" field in the mutation.
func (m *OAuthClientMutation) AllowedCorsOrigins() (r []string, exists bool) {
	v := m.allowed_cors_origins
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCorsOrigins returns the old "allowed_cors_origins" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAllowedCorsOrigins(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCorsOrigins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCorsOrigins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCorsOrigins: %w", err)
	}
	return oldValue.AllowedCorsOrigins, nil
}

// AppendAllowedCorsOrigins adds s to the "allowed_cors_origins" field.
func (m *OAuthClientMutation) AppendAllowedCorsOrigins(s []string) {
	m.appendallowed_cors_origins = append(m.appendallowed_cors_origins, s...)
}

// AppendedAllowedCorsOrigins returns the list of values that were appended to the "allowed_cors_origins" field in this mutation.
func (m *OAuthClientMutation) AppendedAllowedCorsOrigins() ([]string, bool) {
	if len(m.appendallowed_cors_origins) == 0 {
		return nil, false
	}
	return m.appendallowed_cors_origins, true
}

// ClearAllowedCorsOrigins clears the value of the "allowed_cors_origins" field.
func (m *OAuthClientMutation) ClearAllowedCorsOrigins() {
	m.allowed_cors_origins = nil
	m.appendallowed_cors_origins = nil
	m.clearedFields[oauthclient.FieldAllowedCorsOrigins] = struct{}{}
}

// AllowedCorsOriginsCleared returns if the "allowed_cors_origins" field was cleared in this mutation.
func (m *OAuthClientMutation) AllowedCorsOriginsCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldAllowedCorsOrigins]
	return ok
}

// ResetAllowedCorsOrigins resets all changes to the "allowed_cors_origins" field.
func (m *OAuthClientMutation) ResetAllowedCorsOrigins() {
	m.allowed_cors_origins = nil
	m.appendallowed_cors_origins = nil
	delete(m.clearedFields, oauthclient.FieldAllowedCorsOrigins)
}

// SetAllowedGrantTypes sets the "allowed_grant_types" field.
func (m *OAuthClientMutation) SetAllowedGrantTypes(s []string) {
	m.allowed_grant_types = &s
	m.appendallowed_grant_types = nil
}

// AllowedGrantTypes returns the value of the "allowed_grant_types" field in the mutation.
func (m *OAuthClientMutation) AllowedGrantTypes() (r []string, exists bool) {
	v := m.allowed_grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedGrantTypes returns the old "allowed_grant_types" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAllowedGrantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedGrantTypes: %w", err)
	}
	return oldValue.AllowedGrantTypes, nil
}

// AppendAllowedGrantTypes adds s to the "allowed_grant_types" field.
func (m *OAuthClientMutation) AppendAllowedGrantTypes(s []string) {
	m.appendallowed_grant_types = append(m.appendallowed_grant_types, s...)
}

// AppendedAllowedGrantTypes returns the list of values that were appended to the "allowed_grant_types" field in this mutation.
func (m *OAuthClientMutation) AppendedAllowedGrantTypes() ([]string, bool) {
	if len(m.appendallowed_grant_types) == 0 {
		return nil, false
	}
	return m.appendallowed_grant_types, true
}

// ResetAllowedGrantTypes resets all changes to the "allowed_grant_types" field.
func (m *OAuthClientMutation) ResetAllowedGrantTypes() {
	m.allowed_grant_types = nil
	m.appendallowed_grant_types = nil
}

// SetTokenExpirySeconds sets the "token_expiry_seconds" field.
func (m *OAuthClientMutation) SetTokenExpirySeconds(i int) {
	m.token_expiry_seconds = &i
	m.addtoken_expiry_seconds = nil
}

// TokenExpirySeconds returns the value of the "token_expiry_seconds" field in the mutation.
func (m *OAuthClientMutation) TokenExpirySeconds() (r int, exists bool) {
	v := m.token_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpirySeconds returns the old "token_expiry_seconds" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldTokenExpirySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpirySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpirySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpirySeconds: %w", err)
	}
	return oldValue.TokenExpirySeconds, nil
}

// AddTokenExpirySeconds adds i to the "token_expiry_seconds" field.
func (m *OAuthClientMutation) AddTokenExpirySeconds(i int) {
	if m.addtoken_expiry_seconds != nil {
		*m.addtoken_expiry_seconds += i
	} else {
		m.addtoken_expiry_seconds = &i
	}
}

// AddedTokenExpirySeconds returns the value that was added to the "token_expiry_seconds" field in this mutation.
func (m *OAuthClientMutation) AddedTokenExpirySeconds() (r int, exists bool) {
	v := m.addtoken_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenExpirySeconds resets all changes to the "token_expiry_seconds" field.
func (m *OAuthClientMutation) ResetTokenExpirySeconds() {
	m.token_expiry_seconds = nil
	m.addtoken_expiry_seconds = nil
}

// SetRefreshTokenExpirySeconds sets the "refresh_token_expiry_seconds" field.
func (m *OAuthClientMutation) SetRefreshTokenExpirySeconds(i int) {
	m.refresh_token_expiry_seconds = &i
	m.addrefresh_token_expiry_seconds = nil
}

// RefreshTokenExpirySeconds returns the value of the "refresh_token_expiry_seconds" field in the mutation.
func (m *OAuthClientMutation) RefreshTokenExpirySeconds() (r int, exists bool) {
	v := m.refresh_token_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenExpirySeconds returns the old "refresh_token_expiry_seconds" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRefreshTokenExpirySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenExpirySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenExpirySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenExpirySeconds: %w", err)
	}
	return oldValue.RefreshTokenExpirySeconds, nil
}

// AddRefreshTokenExpirySeconds adds i to the "refresh_token_expiry_seconds" field.
func (m *OAuthClientMutation) AddRefreshTokenExpirySeconds(i int) {
	if m.addrefresh_token_expiry_seconds != nil {
		*m.addrefresh_token_expiry_seconds += i
	} else {
		m.addrefresh_token_expiry_seconds = &i
	}
}

// AddedRefreshTokenExpirySeconds returns the value that was added to the "refresh_token_expiry_seconds" field in this mutation.
func (m *OAuthClientMutation) AddedRefreshTokenExpirySeconds() (r int, exists bool) {
	v := m.addrefresh_token_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefreshTokenExpirySeconds resets all changes to the "refresh_token_expiry_seconds" field.
func (m *OAuthClientMutation) ResetRefreshTokenExpirySeconds() {
	m.refresh_token_expiry_seconds = nil
	m.addrefresh_token_expiry_seconds = nil
}

// SetAuthCodeExpirySeconds sets the "auth_code_expiry_seconds" field.
func (m *OAuthClientMutation) SetAuthCodeExpirySeconds(i int) {
	m.auth_code_expiry_seconds = &i
	m.addauth_code_expiry_seconds = nil
}

// AuthCodeExpirySeconds returns the value of the "auth_code_expiry_seconds" field in the mutation.
func (m *OAuthClientMutation) AuthCodeExpirySeconds() (r int, exists bool) {
	v := m.auth_code_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthCodeExpirySeconds returns the old "auth_code_expiry_seconds" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAuthCodeExpirySeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthCodeExpirySeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthCodeExpirySeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthCodeExpirySeconds: %w", err)
	}
	return oldValue.AuthCodeExpirySeconds, nil
}

// AddAuthCodeExpirySeconds adds i to the "auth_code_expiry_seconds" field.
func (m *OAuthClientMutation) AddAuthCodeExpirySeconds(i int) {
	if m.addauth_code_expiry_seconds != nil {
		*m.addauth_code_expiry_seconds += i
	} else {
		m.addauth_code_expiry_seconds = &i
	}
}

// AddedAuthCodeExpirySeconds returns the value that was added to the "auth_code_expiry_seconds" field in this mutation.
func (m *OAuthClientMutation) AddedAuthCodeExpirySeconds() (r int, exists bool) {
	v := m.addauth_code_expiry_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthCodeExpirySeconds resets all changes to the "auth_code_expiry_seconds" field.
func (m *OAuthClientMutation) ResetAuthCodeExpirySeconds() {
	m.auth_code_expiry_seconds = nil
	m.addauth_code_expiry_seconds = nil
}

// SetRequiresPkce sets the "requires_pkce" field.
func (m *OAuthClientMutation) SetRequiresPkce(b bool) {
	m.requires_pkce = &b
}

// RequiresPkce returns the value of the "requires_pkce" field in the mutation.
func (m *OAuthClientMutation) RequiresPkce() (r bool, exists bool) {
	v := m.requires_pkce
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresPkce returns the old "requires_pkce" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRequiresPkce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresPkce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresPkce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresPkce: %w", err)
	}
	return oldValue.RequiresPkce, nil
}

// ResetRequiresPkce resets all changes to the "requires_pkce" field.
func (m *OAuthClientMutation) ResetRequiresPkce() {
	m.requires_pkce = nil
}

// SetRequiresConsent sets the "requires_consent" field.
func (m *OAuthClientMutation) SetRequiresConsent(b bool) {
	m.requires_consent = &b
}

// RequiresConsent returns the value of the "requires_consent" field in the mutation.
func (m *OAuthClientMutation) RequiresConsent() (r bool, exists bool) {
	v := m.requires_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresConsent returns the old "requires_consent" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRequiresConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresConsent: %w", err)
	}
	return oldValue.RequiresConsent, nil
}

// ResetRequiresConsent resets all changes to the "requires_consent" field.
func (m *OAuthClientMutation) ResetRequiresConsent() {
	m.requires_consent = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OAuthClientMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[oauthclient.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OAuthClientMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OAuthClientMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OAuthClientMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddTokenIDs adds the "tokens" edge to the OAuthToken entity by ids.
func (m *OAuthClientMutation) AddTokenIDs(ids ...string) {
	if m.tokens == nil {
		m.tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the OAuthToken entity.
func (m *OAuthClientMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the OAuthToken entity was cleared.
func (m *OAuthClientMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the OAuthToken entity by IDs.
func (m *OAuthClientMutation) RemoveTokenIDs(ids ...string) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the OAuthToken entity.
func (m *OAuthClientMutation) RemovedTokensIDs() (ids []string) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *OAuthClientMutation) TokensIDs() (ids []string) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *OAuthClientMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddAuthorizationIDs adds the "authorizations" edge to the OAuthAuthorization entity by ids.
func (m *OAuthClientMutation) AddAuthorizationIDs(ids ...string) {
	if m.authorizations == nil {
		m.authorizations = make(map[string]struct{})
	}
	for i := range ids {
		m.authorizations[ids[i]] = struct{}{}
	}
}

// ClearAuthorizations clears the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthClientMutation) ClearAuthorizations() {
	m.clearedauthorizations = true
}

// AuthorizationsCleared reports if the "authorizations" edge to the OAuthAuthorization entity was cleared.
func (m *OAuthClientMutation) AuthorizationsCleared() bool {
	return m.clearedauthorizations
}

// RemoveAuthorizationIDs removes the "authorizations" edge to the OAuthAuthorization entity by IDs.
func (m *OAuthClientMutation) RemoveAuthorizationIDs(ids ...string) {
	if m.removedauthorizations == nil {
		m.removedauthorizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.authorizations, ids[i])
		m.removedauthorizations[ids[i]] = struct{}{}
	}
}

// RemovedAuthorizations returns the removed IDs of the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthClientMutation) RemovedAuthorizationsIDs() (ids []string) {
	for id := range m.removedauthorizations {
		ids = append(ids, id)
	}
	return
}

// AuthorizationsIDs returns the "authorizations" edge IDs in the mutation.
func (m *OAuthClientMutation) AuthorizationsIDs() (ids []string) {
	for id := range m.authorizations {
		ids = append(ids, id)
	}
	return
}

// ResetAuthorizations resets all changes to the "authorizations" edge.
func (m *OAuthClientMutation) ResetAuthorizations() {
	m.authorizations = nil
	m.clearedauthorizations = false
	m.removedauthorizations = nil
}

// AddScopeIDs adds the "scopes" edge to the OAuthScope entity by ids.
func (m *OAuthClientMutation) AddScopeIDs(ids ...string) {
	if m.scopes == nil {
		m.scopes = make(map[string]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the OAuthScope entity.
func (m *OAuthClientMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the OAuthScope entity was cleared.
func (m *OAuthClientMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the OAuthScope entity by IDs.
func (m *OAuthClientMutation) RemoveScopeIDs(ids ...string) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the OAuthScope entity.
func (m *OAuthClientMutation) RemovedScopesIDs() (ids []string) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *OAuthClientMutation) ScopesIDs() (ids []string) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *OAuthClientMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// Where appends a list predicates to the OAuthClientMutation builder.
func (m *OAuthClientMutation) Where(ps ...predicate.OAuthClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthClient).
func (m *OAuthClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthClientMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, oauthclient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthclient.FieldUpdatedAt)
	}
	if m.client_id != nil {
		fields = append(fields, oauthclient.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthclient.FieldClientSecret)
	}
	if m.client_name != nil {
		fields = append(fields, oauthclient.FieldClientName)
	}
	if m.client_description != nil {
		fields = append(fields, oauthclient.FieldClientDescription)
	}
	if m.client_uri != nil {
		fields = append(fields, oauthclient.FieldClientURI)
	}
	if m.logo_uri != nil {
		fields = append(fields, oauthclient.FieldLogoURI)
	}
	if m.redirect_uris != nil {
		fields = append(fields, oauthclient.FieldRedirectUris)
	}
	if m.post_logout_redirect_uris != nil {
		fields = append(fields, oauthclient.FieldPostLogoutRedirectUris)
	}
	if m.organization != nil {
		fields = append(fields, oauthclient.FieldOrganizationID)
	}
	if m.public != nil {
		fields = append(fields, oauthclient.FieldPublic)
	}
	if m.active != nil {
		fields = append(fields, oauthclient.FieldActive)
	}
	if m.allowed_cors_origins != nil {
		fields = append(fields, oauthclient.FieldAllowedCorsOrigins)
	}
	if m.allowed_grant_types != nil {
		fields = append(fields, oauthclient.FieldAllowedGrantTypes)
	}
	if m.token_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldTokenExpirySeconds)
	}
	if m.refresh_token_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldRefreshTokenExpirySeconds)
	}
	if m.auth_code_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldAuthCodeExpirySeconds)
	}
	if m.requires_pkce != nil {
		fields = append(fields, oauthclient.FieldRequiresPkce)
	}
	if m.requires_consent != nil {
		fields = append(fields, oauthclient.FieldRequiresConsent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldCreatedAt:
		return m.CreatedAt()
	case oauthclient.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthclient.FieldClientID:
		return m.ClientID()
	case oauthclient.FieldClientSecret:
		return m.ClientSecret()
	case oauthclient.FieldClientName:
		return m.ClientName()
	case oauthclient.FieldClientDescription:
		return m.ClientDescription()
	case oauthclient.FieldClientURI:
		return m.ClientURI()
	case oauthclient.FieldLogoURI:
		return m.LogoURI()
	case oauthclient.FieldRedirectUris:
		return m.RedirectUris()
	case oauthclient.FieldPostLogoutRedirectUris:
		return m.PostLogoutRedirectUris()
	case oauthclient.FieldOrganizationID:
		return m.OrganizationID()
	case oauthclient.FieldPublic:
		return m.Public()
	case oauthclient.FieldActive:
		return m.Active()
	case oauthclient.FieldAllowedCorsOrigins:
		return m.AllowedCorsOrigins()
	case oauthclient.FieldAllowedGrantTypes:
		return m.AllowedGrantTypes()
	case oauthclient.FieldTokenExpirySeconds:
		return m.TokenExpirySeconds()
	case oauthclient.FieldRefreshTokenExpirySeconds:
		return m.RefreshTokenExpirySeconds()
	case oauthclient.FieldAuthCodeExpirySeconds:
		return m.AuthCodeExpirySeconds()
	case oauthclient.FieldRequiresPkce:
		return m.RequiresPkce()
	case oauthclient.FieldRequiresConsent:
		return m.RequiresConsent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthclient.FieldClientID:
		return m.OldClientID(ctx)
	case oauthclient.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthclient.FieldClientName:
		return m.OldClientName(ctx)
	case oauthclient.FieldClientDescription:
		return m.OldClientDescription(ctx)
	case oauthclient.FieldClientURI:
		return m.OldClientURI(ctx)
	case oauthclient.FieldLogoURI:
		return m.OldLogoURI(ctx)
	case oauthclient.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case oauthclient.FieldPostLogoutRedirectUris:
		return m.OldPostLogoutRedirectUris(ctx)
	case oauthclient.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case oauthclient.FieldPublic:
		return m.OldPublic(ctx)
	case oauthclient.FieldActive:
		return m.OldActive(ctx)
	case oauthclient.FieldAllowedCorsOrigins:
		return m.OldAllowedCorsOrigins(ctx)
	case oauthclient.FieldAllowedGrantTypes:
		return m.OldAllowedGrantTypes(ctx)
	case oauthclient.FieldTokenExpirySeconds:
		return m.OldTokenExpirySeconds(ctx)
	case oauthclient.FieldRefreshTokenExpirySeconds:
		return m.OldRefreshTokenExpirySeconds(ctx)
	case oauthclient.FieldAuthCodeExpirySeconds:
		return m.OldAuthCodeExpirySeconds(ctx)
	case oauthclient.FieldRequiresPkce:
		return m.OldRequiresPkce(ctx)
	case oauthclient.FieldRequiresConsent:
		return m.OldRequiresConsent(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthclient.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthclient.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthclient.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case oauthclient.FieldClientDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientDescription(v)
		return nil
	case oauthclient.FieldClientURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientURI(v)
		return nil
	case oauthclient.FieldLogoURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURI(v)
		return nil
	case oauthclient.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case oauthclient.FieldPostLogoutRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostLogoutRedirectUris(v)
		return nil
	case oauthclient.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case oauthclient.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case oauthclient.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case oauthclient.FieldAllowedCorsOrigins:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCorsOrigins(v)
		return nil
	case oauthclient.FieldAllowedGrantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedGrantTypes(v)
		return nil
	case oauthclient.FieldTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldRefreshTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldAuthCodeExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthCodeExpirySeconds(v)
		return nil
	case oauthclient.FieldRequiresPkce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresPkce(v)
		return nil
	case oauthclient.FieldRequiresConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresConsent(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthClientMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldTokenExpirySeconds)
	}
	if m.addrefresh_token_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldRefreshTokenExpirySeconds)
	}
	if m.addauth_code_expiry_seconds != nil {
		fields = append(fields, oauthclient.FieldAuthCodeExpirySeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldTokenExpirySeconds:
		return m.AddedTokenExpirySeconds()
	case oauthclient.FieldRefreshTokenExpirySeconds:
		return m.AddedRefreshTokenExpirySeconds()
	case oauthclient.FieldAuthCodeExpirySeconds:
		return m.AddedAuthCodeExpirySeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldRefreshTokenExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTokenExpirySeconds(v)
		return nil
	case oauthclient.FieldAuthCodeExpirySeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthCodeExpirySeconds(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthclient.FieldClientDescription) {
		fields = append(fields, oauthclient.FieldClientDescription)
	}
	if m.FieldCleared(oauthclient.FieldClientURI) {
		fields = append(fields, oauthclient.FieldClientURI)
	}
	if m.FieldCleared(oauthclient.FieldLogoURI) {
		fields = append(fields, oauthclient.FieldLogoURI)
	}
	if m.FieldCleared(oauthclient.FieldPostLogoutRedirectUris) {
		fields = append(fields, oauthclient.FieldPostLogoutRedirectUris)
	}
	if m.FieldCleared(oauthclient.FieldOrganizationID) {
		fields = append(fields, oauthclient.FieldOrganizationID)
	}
	if m.FieldCleared(oauthclient.FieldAllowedCorsOrigins) {
		fields = append(fields, oauthclient.FieldAllowedCorsOrigins)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthClientMutation) ClearField(name string) error {
	switch name {
	case oauthclient.FieldClientDescription:
		m.ClearClientDescription()
		return nil
	case oauthclient.FieldClientURI:
		m.ClearClientURI()
		return nil
	case oauthclient.FieldLogoURI:
		m.ClearLogoURI()
		return nil
	case oauthclient.FieldPostLogoutRedirectUris:
		m.ClearPostLogoutRedirectUris()
		return nil
	case oauthclient.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case oauthclient.FieldAllowedCorsOrigins:
		m.ClearAllowedCorsOrigins()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthClientMutation) ResetField(name string) error {
	switch name {
	case oauthclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthclient.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthclient.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthclient.FieldClientName:
		m.ResetClientName()
		return nil
	case oauthclient.FieldClientDescription:
		m.ResetClientDescription()
		return nil
	case oauthclient.FieldClientURI:
		m.ResetClientURI()
		return nil
	case oauthclient.FieldLogoURI:
		m.ResetLogoURI()
		return nil
	case oauthclient.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case oauthclient.FieldPostLogoutRedirectUris:
		m.ResetPostLogoutRedirectUris()
		return nil
	case oauthclient.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case oauthclient.FieldPublic:
		m.ResetPublic()
		return nil
	case oauthclient.FieldActive:
		m.ResetActive()
		return nil
	case oauthclient.FieldAllowedCorsOrigins:
		m.ResetAllowedCorsOrigins()
		return nil
	case oauthclient.FieldAllowedGrantTypes:
		m.ResetAllowedGrantTypes()
		return nil
	case oauthclient.FieldTokenExpirySeconds:
		m.ResetTokenExpirySeconds()
		return nil
	case oauthclient.FieldRefreshTokenExpirySeconds:
		m.ResetRefreshTokenExpirySeconds()
		return nil
	case oauthclient.FieldAuthCodeExpirySeconds:
		m.ResetAuthCodeExpirySeconds()
		return nil
	case oauthclient.FieldRequiresPkce:
		m.ResetRequiresPkce()
		return nil
	case oauthclient.FieldRequiresConsent:
		m.ResetRequiresConsent()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, oauthclient.EdgeOrganization)
	}
	if m.tokens != nil {
		edges = append(edges, oauthclient.EdgeTokens)
	}
	if m.authorizations != nil {
		edges = append(edges, oauthclient.EdgeAuthorizations)
	}
	if m.scopes != nil {
		edges = append(edges, oauthclient.EdgeScopes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthclient.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case oauthclient.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.authorizations))
		for id := range m.authorizations {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtokens != nil {
		edges = append(edges, oauthclient.EdgeTokens)
	}
	if m.removedauthorizations != nil {
		edges = append(edges, oauthclient.EdgeAuthorizations)
	}
	if m.removedscopes != nil {
		edges = append(edges, oauthclient.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthClientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthclient.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.removedauthorizations))
		for id := range m.removedauthorizations {
			ids = append(ids, id)
		}
		return ids
	case oauthclient.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, oauthclient.EdgeOrganization)
	}
	if m.clearedtokens {
		edges = append(edges, oauthclient.EdgeTokens)
	}
	if m.clearedauthorizations {
		edges = append(edges, oauthclient.EdgeAuthorizations)
	}
	if m.clearedscopes {
		edges = append(edges, oauthclient.EdgeScopes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthClientMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthclient.EdgeOrganization:
		return m.clearedorganization
	case oauthclient.EdgeTokens:
		return m.clearedtokens
	case oauthclient.EdgeAuthorizations:
		return m.clearedauthorizations
	case oauthclient.EdgeScopes:
		return m.clearedscopes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthClientMutation) ClearEdge(name string) error {
	switch name {
	case oauthclient.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthClientMutation) ResetEdge(name string) error {
	switch name {
	case oauthclient.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case oauthclient.EdgeTokens:
		m.ResetTokens()
		return nil
	case oauthclient.EdgeAuthorizations:
		m.ResetAuthorizations()
		return nil
	case oauthclient.EdgeScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient edge %s", name)
}

// OAuthScopeMutation represents an operation that mutates the OAuthScope nodes in the graph.
type OAuthScopeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	description           *string
	default_scope         *bool
	public                *bool
	clearedFields         map[string]struct{}
	clients               map[string]struct{}
	removedclients        map[string]struct{}
	clearedclients        bool
	tokens                map[string]struct{}
	removedtokens         map[string]struct{}
	clearedtokens         bool
	authorizations        map[string]struct{}
	removedauthorizations map[string]struct{}
	clearedauthorizations bool
	done                  bool
	oldValue              func(context.Context) (*OAuthScope, error)
	predicates            []predicate.OAuthScope
}

var _ ent.Mutation = (*OAuthScopeMutation)(nil)

// oauthscopeOption allows management of the mutation configuration using functional options.
type oauthscopeOption func(*OAuthScopeMutation)

// newOAuthScopeMutation creates new mutation for the OAuthScope entity.
func newOAuthScopeMutation(c config, op Op, opts ...oauthscopeOption) *OAuthScopeMutation {
	m := &OAuthScopeMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthScope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthScopeID sets the ID field of the mutation.
func withOAuthScopeID(id string) oauthscopeOption {
	return func(m *OAuthScopeMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthScope
		)
		m.oldValue = func(ctx context.Context) (*OAuthScope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthScope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthScope sets the old OAuthScope of the mutation.
func withOAuthScope(node *OAuthScope) oauthscopeOption {
	return func(m *OAuthScopeMutation) {
		m.oldValue = func(context.Context) (*OAuthScope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthScopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthScopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthScope entities.
func (m *OAuthScopeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthScopeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthScopeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthScope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthScopeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthScopeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthScopeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthScopeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthScopeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthScopeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *OAuthScopeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OAuthScopeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OAuthScopeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OAuthScopeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OAuthScopeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OAuthScopeMutation) ResetDescription() {
	m.description = nil
}

// SetDefaultScope sets the "default_scope" field.
func (m *OAuthScopeMutation) SetDefaultScope(b bool) {
	m.default_scope = &b
}

// DefaultScope returns the value of the "default_scope" field in the mutation.
func (m *OAuthScopeMutation) DefaultScope() (r bool, exists bool) {
	v := m.default_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultScope returns the old "default_scope" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldDefaultScope(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultScope: %w", err)
	}
	return oldValue.DefaultScope, nil
}

// ResetDefaultScope resets all changes to the "default_scope" field.
func (m *OAuthScopeMutation) ResetDefaultScope() {
	m.default_scope = nil
}

// SetPublic sets the "public" field.
func (m *OAuthScopeMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *OAuthScopeMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the OAuthScope entity.
// If the OAuthScope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthScopeMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *OAuthScopeMutation) ResetPublic() {
	m.public = nil
}

// AddClientIDs adds the "clients" edge to the OAuthClient entity by ids.
func (m *OAuthScopeMutation) AddClientIDs(ids ...string) {
	if m.clients == nil {
		m.clients = make(map[string]struct{})
	}
	for i := range ids {
		m.clients[ids[i]] = struct{}{}
	}
}

// ClearClients clears the "clients" edge to the OAuthClient entity.
func (m *OAuthScopeMutation) ClearClients() {
	m.clearedclients = true
}

// ClientsCleared reports if the "clients" edge to the OAuthClient entity was cleared.
func (m *OAuthScopeMutation) ClientsCleared() bool {
	return m.clearedclients
}

// RemoveClientIDs removes the "clients" edge to the OAuthClient entity by IDs.
func (m *OAuthScopeMutation) RemoveClientIDs(ids ...string) {
	if m.removedclients == nil {
		m.removedclients = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.clients, ids[i])
		m.removedclients[ids[i]] = struct{}{}
	}
}

// RemovedClients returns the removed IDs of the "clients" edge to the OAuthClient entity.
func (m *OAuthScopeMutation) RemovedClientsIDs() (ids []string) {
	for id := range m.removedclients {
		ids = append(ids, id)
	}
	return
}

// ClientsIDs returns the "clients" edge IDs in the mutation.
func (m *OAuthScopeMutation) ClientsIDs() (ids []string) {
	for id := range m.clients {
		ids = append(ids, id)
	}
	return
}

// ResetClients resets all changes to the "clients" edge.
func (m *OAuthScopeMutation) ResetClients() {
	m.clients = nil
	m.clearedclients = false
	m.removedclients = nil
}

// AddTokenIDs adds the "tokens" edge to the OAuthToken entity by ids.
func (m *OAuthScopeMutation) AddTokenIDs(ids ...string) {
	if m.tokens == nil {
		m.tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the OAuthToken entity.
func (m *OAuthScopeMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the OAuthToken entity was cleared.
func (m *OAuthScopeMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the OAuthToken entity by IDs.
func (m *OAuthScopeMutation) RemoveTokenIDs(ids ...string) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the OAuthToken entity.
func (m *OAuthScopeMutation) RemovedTokensIDs() (ids []string) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *OAuthScopeMutation) TokensIDs() (ids []string) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *OAuthScopeMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddAuthorizationIDs adds the "authorizations" edge to the OAuthAuthorization entity by ids.
func (m *OAuthScopeMutation) AddAuthorizationIDs(ids ...string) {
	if m.authorizations == nil {
		m.authorizations = make(map[string]struct{})
	}
	for i := range ids {
		m.authorizations[ids[i]] = struct{}{}
	}
}

// ClearAuthorizations clears the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthScopeMutation) ClearAuthorizations() {
	m.clearedauthorizations = true
}

// AuthorizationsCleared reports if the "authorizations" edge to the OAuthAuthorization entity was cleared.
func (m *OAuthScopeMutation) AuthorizationsCleared() bool {
	return m.clearedauthorizations
}

// RemoveAuthorizationIDs removes the "authorizations" edge to the OAuthAuthorization entity by IDs.
func (m *OAuthScopeMutation) RemoveAuthorizationIDs(ids ...string) {
	if m.removedauthorizations == nil {
		m.removedauthorizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.authorizations, ids[i])
		m.removedauthorizations[ids[i]] = struct{}{}
	}
}

// RemovedAuthorizations returns the removed IDs of the "authorizations" edge to the OAuthAuthorization entity.
func (m *OAuthScopeMutation) RemovedAuthorizationsIDs() (ids []string) {
	for id := range m.removedauthorizations {
		ids = append(ids, id)
	}
	return
}

// AuthorizationsIDs returns the "authorizations" edge IDs in the mutation.
func (m *OAuthScopeMutation) AuthorizationsIDs() (ids []string) {
	for id := range m.authorizations {
		ids = append(ids, id)
	}
	return
}

// ResetAuthorizations resets all changes to the "authorizations" edge.
func (m *OAuthScopeMutation) ResetAuthorizations() {
	m.authorizations = nil
	m.clearedauthorizations = false
	m.removedauthorizations = nil
}

// Where appends a list predicates to the OAuthScopeMutation builder.
func (m *OAuthScopeMutation) Where(ps ...predicate.OAuthScope) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthScopeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthScopeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthScope, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthScopeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthScopeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthScope).
func (m *OAuthScopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthScopeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, oauthscope.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthscope.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, oauthscope.FieldName)
	}
	if m.description != nil {
		fields = append(fields, oauthscope.FieldDescription)
	}
	if m.default_scope != nil {
		fields = append(fields, oauthscope.FieldDefaultScope)
	}
	if m.public != nil {
		fields = append(fields, oauthscope.FieldPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthScopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthscope.FieldCreatedAt:
		return m.CreatedAt()
	case oauthscope.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthscope.FieldName:
		return m.Name()
	case oauthscope.FieldDescription:
		return m.Description()
	case oauthscope.FieldDefaultScope:
		return m.DefaultScope()
	case oauthscope.FieldPublic:
		return m.Public()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthScopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthscope.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthscope.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthscope.FieldName:
		return m.OldName(ctx)
	case oauthscope.FieldDescription:
		return m.OldDescription(ctx)
	case oauthscope.FieldDefaultScope:
		return m.OldDefaultScope(ctx)
	case oauthscope.FieldPublic:
		return m.OldPublic(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthScope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthScopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthscope.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthscope.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthscope.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthscope.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case oauthscope.FieldDefaultScope:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultScope(v)
		return nil
	case oauthscope.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthScope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthScopeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthScopeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthScopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthScope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthScopeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthScopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthScopeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OAuthScope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthScopeMutation) ResetField(name string) error {
	switch name {
	case oauthscope.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthscope.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthscope.FieldName:
		m.ResetName()
		return nil
	case oauthscope.FieldDescription:
		m.ResetDescription()
		return nil
	case oauthscope.FieldDefaultScope:
		m.ResetDefaultScope()
		return nil
	case oauthscope.FieldPublic:
		m.ResetPublic()
		return nil
	}
	return fmt.Errorf("unknown OAuthScope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthScopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clients != nil {
		edges = append(edges, oauthscope.EdgeClients)
	}
	if m.tokens != nil {
		edges = append(edges, oauthscope.EdgeTokens)
	}
	if m.authorizations != nil {
		edges = append(edges, oauthscope.EdgeAuthorizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthScopeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthscope.EdgeClients:
		ids := make([]ent.Value, 0, len(m.clients))
		for id := range m.clients {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.authorizations))
		for id := range m.authorizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthScopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedclients != nil {
		edges = append(edges, oauthscope.EdgeClients)
	}
	if m.removedtokens != nil {
		edges = append(edges, oauthscope.EdgeTokens)
	}
	if m.removedauthorizations != nil {
		edges = append(edges, oauthscope.EdgeAuthorizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthScopeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthscope.EdgeClients:
		ids := make([]ent.Value, 0, len(m.removedclients))
		for id := range m.removedclients {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case oauthscope.EdgeAuthorizations:
		ids := make([]ent.Value, 0, len(m.removedauthorizations))
		for id := range m.removedauthorizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthScopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclients {
		edges = append(edges, oauthscope.EdgeClients)
	}
	if m.clearedtokens {
		edges = append(edges, oauthscope.EdgeTokens)
	}
	if m.clearedauthorizations {
		edges = append(edges, oauthscope.EdgeAuthorizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthScopeMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthscope.EdgeClients:
		return m.clearedclients
	case oauthscope.EdgeTokens:
		return m.clearedtokens
	case oauthscope.EdgeAuthorizations:
		return m.clearedauthorizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthScopeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthScope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthScopeMutation) ResetEdge(name string) error {
	switch name {
	case oauthscope.EdgeClients:
		m.ResetClients()
		return nil
	case oauthscope.EdgeTokens:
		m.ResetTokens()
		return nil
	case oauthscope.EdgeAuthorizations:
		m.ResetAuthorizations()
		return nil
	}
	return fmt.Errorf("unknown OAuthScope edge %s", name)
}

// OAuthTokenMutation represents an operation that mutates the OAuthToken nodes in the graph.
type OAuthTokenMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	access_token             *string
	refresh_token            *string
	token_type               *string
	organization_id          *string
	scope_names              *[]string
	appendscope_names        []string
	expires_in               *int
	addexpires_in            *int
	expires_at               *time.Time
	refresh_token_expires_at *time.Time
	revoked                  *bool
	revoked_at               *time.Time
	ip_address               *string
	user_agent               *string
	clearedFields            map[string]struct{}
	client                   *string
	clearedclient            bool
	user                     *string
	cleareduser              bool
	scopes                   map[string]struct{}
	removedscopes            map[string]struct{}
	clearedscopes            bool
	done                     bool
	oldValue                 func(context.Context) (*OAuthToken, error)
	predicates               []predicate.OAuthToken
}

var _ ent.Mutation = (*OAuthTokenMutation)(nil)

// oauthtokenOption allows management of the mutation configuration using functional options.
type oauthtokenOption func(*OAuthTokenMutation)

// newOAuthTokenMutation creates new mutation for the OAuthToken entity.
func newOAuthTokenMutation(c config, op Op, opts ...oauthtokenOption) *OAuthTokenMutation {
	m := &OAuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthTokenID sets the ID field of the mutation.
func withOAuthTokenID(id string) oauthtokenOption {
	return func(m *OAuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthToken
		)
		m.oldValue = func(ctx context.Context) (*OAuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthToken sets the old OAuthToken of the mutation.
func withOAuthToken(node *OAuthToken) oauthtokenOption {
	return func(m *OAuthTokenMutation) {
		m.oldValue = func(context.Context) (*OAuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthToken entities.
func (m *OAuthTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAccessToken sets the "access_token" field.
func (m *OAuthTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *OAuthTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *OAuthTokenMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *OAuthTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *OAuthTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *OAuthTokenMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[oauthtoken.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *OAuthTokenMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *OAuthTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, oauthtoken.FieldRefreshToken)
}

// SetTokenType sets the "token_type" field.
func (m *OAuthTokenMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *OAuthTokenMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *OAuthTokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetClientID sets the "client_id" field.
func (m *OAuthTokenMutation) SetClientID(s string) {
	m.client = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthTokenMutation) ClientID() (r string, exists bool) {
	v := m.client
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthTokenMutation) ResetClientID() {
	m.client = nil
}

// SetUserID sets the "user_id" field.
func (m *OAuthTokenMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OAuthTokenMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OAuthTokenMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OAuthTokenMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OAuthTokenMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OAuthTokenMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[oauthtoken.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OAuthTokenMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OAuthTokenMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, oauthtoken.FieldOrganizationID)
}

// SetScopeNames sets the "scope_names" field.
func (m *OAuthTokenMutation) SetScopeNames(s []string) {
	m.scope_names = &s
	m.appendscope_names = nil
}

// ScopeNames returns the value of the "scope_names" field in the mutation.
func (m *OAuthTokenMutation) ScopeNames() (r []string, exists bool) {
	v := m.scope_names
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeNames returns the old "scope_names" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldScopeNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeNames: %w", err)
	}
	return oldValue.ScopeNames, nil
}

// AppendScopeNames adds s to the "scope_names" field.
func (m *OAuthTokenMutation) AppendScopeNames(s []string) {
	m.appendscope_names = append(m.appendscope_names, s...)
}

// AppendedScopeNames returns the list of values that were appended to the "scope_names" field in this mutation.
func (m *OAuthTokenMutation) AppendedScopeNames() ([]string, bool) {
	if len(m.appendscope_names) == 0 {
		return nil, false
	}
	return m.appendscope_names, true
}

// ClearScopeNames clears the value of the "scope_names" field.
func (m *OAuthTokenMutation) ClearScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	m.clearedFields[oauthtoken.FieldScopeNames] = struct{}{}
}

// ScopeNamesCleared returns if the "scope_names" field was cleared in this mutation.
func (m *OAuthTokenMutation) ScopeNamesCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldScopeNames]
	return ok
}

// ResetScopeNames resets all changes to the "scope_names" field.
func (m *OAuthTokenMutation) ResetScopeNames() {
	m.scope_names = nil
	m.appendscope_names = nil
	delete(m.clearedFields, oauthtoken.FieldScopeNames)
}

// SetExpiresIn sets the "expires_in" field.
func (m *OAuthTokenMutation) SetExpiresIn(i int) {
	m.expires_in = &i
	m.addexpires_in = nil
}

// ExpiresIn returns the value of the "expires_in" field in the mutation.
func (m *OAuthTokenMutation) ExpiresIn() (r int, exists bool) {
	v := m.expires_in
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresIn returns the old "expires_in" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldExpiresIn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresIn: %w", err)
	}
	return oldValue.ExpiresIn, nil
}

// AddExpiresIn adds i to the "expires_in" field.
func (m *OAuthTokenMutation) AddExpiresIn(i int) {
	if m.addexpires_in != nil {
		*m.addexpires_in += i
	} else {
		m.addexpires_in = &i
	}
}

// AddedExpiresIn returns the value that was added to the "expires_in" field in this mutation.
func (m *OAuthTokenMutation) AddedExpiresIn() (r int, exists bool) {
	v := m.addexpires_in
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresIn resets all changes to the "expires_in" field.
func (m *OAuthTokenMutation) ResetExpiresIn() {
	m.expires_in = nil
	m.addexpires_in = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OAuthTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OAuthTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OAuthTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRefreshTokenExpiresAt sets the "refresh_token_expires_at" field.
func (m *OAuthTokenMutation) SetRefreshTokenExpiresAt(t time.Time) {
	m.refresh_token_expires_at = &t
}

// RefreshTokenExpiresAt returns the value of the "refresh_token_expires_at" field in the mutation.
func (m *OAuthTokenMutation) RefreshTokenExpiresAt() (r time.Time, exists bool) {
	v := m.refresh_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenExpiresAt returns the old "refresh_token_expires_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRefreshTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenExpiresAt: %w", err)
	}
	return oldValue.RefreshTokenExpiresAt, nil
}

// ClearRefreshTokenExpiresAt clears the value of the "refresh_token_expires_at" field.
func (m *OAuthTokenMutation) ClearRefreshTokenExpiresAt() {
	m.refresh_token_expires_at = nil
	m.clearedFields[oauthtoken.FieldRefreshTokenExpiresAt] = struct{}{}
}

// RefreshTokenExpiresAtCleared returns if the "refresh_token_expires_at" field was cleared in this mutation.
func (m *OAuthTokenMutation) RefreshTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRefreshTokenExpiresAt]
	return ok
}

// ResetRefreshTokenExpiresAt resets all changes to the "refresh_token_expires_at" field.
func (m *OAuthTokenMutation) ResetRefreshTokenExpiresAt() {
	m.refresh_token_expires_at = nil
	delete(m.clearedFields, oauthtoken.FieldRefreshTokenExpiresAt)
}

// SetRevoked sets the "revoked" field.
func (m *OAuthTokenMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *OAuthTokenMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *OAuthTokenMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *OAuthTokenMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *OAuthTokenMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *OAuthTokenMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[oauthtoken.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *OAuthTokenMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *OAuthTokenMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, oauthtoken.FieldRevokedAt)
}

// SetIPAddress sets the "ip_address" field.
func (m *OAuthTokenMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *OAuthTokenMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *OAuthTokenMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[oauthtoken.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *OAuthTokenMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *OAuthTokenMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, oauthtoken.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *OAuthTokenMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *OAuthTokenMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the OAuthToken entity.
// If the OAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthTokenMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *OAuthTokenMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[oauthtoken.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *OAuthTokenMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[oauthtoken.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *OAuthTokenMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, oauthtoken.FieldUserAgent)
}

// ClearClient clears the "client" edge to the OAuthClient entity.
func (m *OAuthTokenMutation) ClearClient() {
	m.clearedclient = true
	m.clearedFields[oauthtoken.FieldClientID] = struct{}{}
}

// ClientCleared reports if the "client" edge to the OAuthClient entity was cleared.
func (m *OAuthTokenMutation) ClientCleared() bool {
	return m.clearedclient
}

// ClientIDs returns the "client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientID instead. It exists only for internal usage by the builders.
func (m *OAuthTokenMutation) ClientIDs() (ids []string) {
	if id := m.client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClient resets all changes to the "client" edge.
func (m *OAuthTokenMutation) ResetClient() {
	m.client = nil
	m.clearedclient = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OAuthTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[oauthtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OAuthTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OAuthTokenMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OAuthTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddScopeIDs adds the "scopes" edge to the OAuthScope entity by ids.
func (m *OAuthTokenMutation) AddScopeIDs(ids ...string) {
	if m.scopes == nil {
		m.scopes = make(map[string]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the OAuthScope entity.
func (m *OAuthTokenMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the OAuthScope entity was cleared.
func (m *OAuthTokenMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the OAuthScope entity by IDs.
func (m *OAuthTokenMutation) RemoveScopeIDs(ids ...string) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the OAuthScope entity.
func (m *OAuthTokenMutation) RemovedScopesIDs() (ids []string) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *OAuthTokenMutation) ScopesIDs() (ids []string) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *OAuthTokenMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// Where appends a list predicates to the OAuthTokenMutation builder.
func (m *OAuthTokenMutation) Where(ps ...predicate.OAuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthToken).
func (m *OAuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, oauthtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthtoken.FieldUpdatedAt)
	}
	if m.access_token != nil {
		fields = append(fields, oauthtoken.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauthtoken.FieldRefreshToken)
	}
	if m.token_type != nil {
		fields = append(fields, oauthtoken.FieldTokenType)
	}
	if m.client != nil {
		fields = append(fields, oauthtoken.FieldClientID)
	}
	if m.user != nil {
		fields = append(fields, oauthtoken.FieldUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, oauthtoken.FieldOrganizationID)
	}
	if m.scope_names != nil {
		fields = append(fields, oauthtoken.FieldScopeNames)
	}
	if m.expires_in != nil {
		fields = append(fields, oauthtoken.FieldExpiresIn)
	}
	if m.expires_at != nil {
		fields = append(fields, oauthtoken.FieldExpiresAt)
	}
	if m.refresh_token_expires_at != nil {
		fields = append(fields, oauthtoken.FieldRefreshTokenExpiresAt)
	}
	if m.revoked != nil {
		fields = append(fields, oauthtoken.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, oauthtoken.FieldRevokedAt)
	}
	if m.ip_address != nil {
		fields = append(fields, oauthtoken.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, oauthtoken.FieldUserAgent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthtoken.FieldCreatedAt:
		return m.CreatedAt()
	case oauthtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthtoken.FieldAccessToken:
		return m.AccessToken()
	case oauthtoken.FieldRefreshToken:
		return m.RefreshToken()
	case oauthtoken.FieldTokenType:
		return m.TokenType()
	case oauthtoken.FieldClientID:
		return m.ClientID()
	case oauthtoken.FieldUserID:
		return m.UserID()
	case oauthtoken.FieldOrganizationID:
		return m.OrganizationID()
	case oauthtoken.FieldScopeNames:
		return m.ScopeNames()
	case oauthtoken.FieldExpiresIn:
		return m.ExpiresIn()
	case oauthtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case oauthtoken.FieldRefreshTokenExpiresAt:
		return m.RefreshTokenExpiresAt()
	case oauthtoken.FieldRevoked:
		return m.Revoked()
	case oauthtoken.FieldRevokedAt:
		return m.RevokedAt()
	case oauthtoken.FieldIPAddress:
		return m.IPAddress()
	case oauthtoken.FieldUserAgent:
		return m.UserAgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthtoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case oauthtoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case oauthtoken.FieldTokenType:
		return m.OldTokenType(ctx)
	case oauthtoken.FieldClientID:
		return m.OldClientID(ctx)
	case oauthtoken.FieldUserID:
		return m.OldUserID(ctx)
	case oauthtoken.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case oauthtoken.FieldScopeNames:
		return m.OldScopeNames(ctx)
	case oauthtoken.FieldExpiresIn:
		return m.OldExpiresIn(ctx)
	case oauthtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case oauthtoken.FieldRefreshTokenExpiresAt:
		return m.OldRefreshTokenExpiresAt(ctx)
	case oauthtoken.FieldRevoked:
		return m.OldRevoked(ctx)
	case oauthtoken.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case oauthtoken.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case oauthtoken.FieldUserAgent:
		return m.OldUserAgent(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthtoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case oauthtoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case oauthtoken.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case oauthtoken.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthtoken.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthtoken.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case oauthtoken.FieldScopeNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeNames(v)
		return nil
	case oauthtoken.FieldExpiresIn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresIn(v)
		return nil
	case oauthtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case oauthtoken.FieldRefreshTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenExpiresAt(v)
		return nil
	case oauthtoken.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case oauthtoken.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case oauthtoken.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case oauthtoken.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthTokenMutation) AddedFields() []string {
	var fields []string
	if m.addexpires_in != nil {
		fields = append(fields, oauthtoken.FieldExpiresIn)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthtoken.FieldExpiresIn:
		return m.AddedExpiresIn()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthtoken.FieldExpiresIn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresIn(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthtoken.FieldRefreshToken) {
		fields = append(fields, oauthtoken.FieldRefreshToken)
	}
	if m.FieldCleared(oauthtoken.FieldOrganizationID) {
		fields = append(fields, oauthtoken.FieldOrganizationID)
	}
	if m.FieldCleared(oauthtoken.FieldScopeNames) {
		fields = append(fields, oauthtoken.FieldScopeNames)
	}
	if m.FieldCleared(oauthtoken.FieldRefreshTokenExpiresAt) {
		fields = append(fields, oauthtoken.FieldRefreshTokenExpiresAt)
	}
	if m.FieldCleared(oauthtoken.FieldRevokedAt) {
		fields = append(fields, oauthtoken.FieldRevokedAt)
	}
	if m.FieldCleared(oauthtoken.FieldIPAddress) {
		fields = append(fields, oauthtoken.FieldIPAddress)
	}
	if m.FieldCleared(oauthtoken.FieldUserAgent) {
		fields = append(fields, oauthtoken.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthTokenMutation) ClearField(name string) error {
	switch name {
	case oauthtoken.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case oauthtoken.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case oauthtoken.FieldScopeNames:
		m.ClearScopeNames()
		return nil
	case oauthtoken.FieldRefreshTokenExpiresAt:
		m.ClearRefreshTokenExpiresAt()
		return nil
	case oauthtoken.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case oauthtoken.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case oauthtoken.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthTokenMutation) ResetField(name string) error {
	switch name {
	case oauthtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthtoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case oauthtoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case oauthtoken.FieldTokenType:
		m.ResetTokenType()
		return nil
	case oauthtoken.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthtoken.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case oauthtoken.FieldScopeNames:
		m.ResetScopeNames()
		return nil
	case oauthtoken.FieldExpiresIn:
		m.ResetExpiresIn()
		return nil
	case oauthtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case oauthtoken.FieldRefreshTokenExpiresAt:
		m.ResetRefreshTokenExpiresAt()
		return nil
	case oauthtoken.FieldRevoked:
		m.ResetRevoked()
		return nil
	case oauthtoken.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case oauthtoken.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case oauthtoken.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.client != nil {
		edges = append(edges, oauthtoken.EdgeClient)
	}
	if m.user != nil {
		edges = append(edges, oauthtoken.EdgeUser)
	}
	if m.scopes != nil {
		edges = append(edges, oauthtoken.EdgeScopes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthtoken.EdgeClient:
		if id := m.client; id != nil {
			return []ent.Value{*id}
		}
	case oauthtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case oauthtoken.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedscopes != nil {
		edges = append(edges, oauthtoken.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthtoken.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclient {
		edges = append(edges, oauthtoken.EdgeClient)
	}
	if m.cleareduser {
		edges = append(edges, oauthtoken.EdgeUser)
	}
	if m.clearedscopes {
		edges = append(edges, oauthtoken.EdgeScopes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthtoken.EdgeClient:
		return m.clearedclient
	case oauthtoken.EdgeUser:
		return m.cleareduser
	case oauthtoken.EdgeScopes:
		return m.clearedscopes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthTokenMutation) ClearEdge(name string) error {
	switch name {
	case oauthtoken.EdgeClient:
		m.ClearClient()
		return nil
	case oauthtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthTokenMutation) ResetEdge(name string) error {
	switch name {
	case oauthtoken.EdgeClient:
		m.ResetClient()
		return nil
	case oauthtoken.EdgeUser:
		m.ResetUser()
		return nil
	case oauthtoken.EdgeScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown OAuthToken edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	created_at                *time.Time
	updated_at                *time.Time
	name                      *string
	slug                      *string
	domain                    *string
	logo_url                  *string
	plan                      *string
	active                    *bool
	metadata                  *map[string]interface{}
	trial_ends_at             *time.Time
	trial_used                *bool
	clearedFields             map[string]struct{}
	users                     map[string]struct{}
	removedusers              map[string]struct{}
	clearedusers              bool
	api_keys                  map[string]struct{}
	removedapi_keys           map[string]struct{}
	clearedapi_keys           bool
	webhooks                  map[string]struct{}
	removedwebhooks           map[string]struct{}
	clearedwebhooks           bool
	feature_flags             map[string]struct{}
	removedfeature_flags      map[string]struct{}
	clearedfeature_flags      bool
	identity_providers        map[string]struct{}
	removedidentity_providers map[string]struct{}
	clearedidentity_providers bool
	oauth_clients             map[string]struct{}
	removedoauth_clients      map[string]struct{}
	clearedoauth_clients      bool
	done                      bool
	oldValue                  func(context.Context) (*Organization, error)
	predicates                []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id string) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrganizationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrganizationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrganizationMutation) ResetSlug() {
	m.slug = nil
}

// SetDomain sets the "domain" field.
func (m *OrganizationMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *OrganizationMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *OrganizationMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[organization.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *OrganizationMutation) DomainCleared() bool {
	_, ok := m.clearedFields[organization.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *OrganizationMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, organization.FieldDomain)
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetPlan sets the "plan" field.
func (m *OrganizationMutation) SetPlan(s string) {
	m.plan = &s
}

// Plan returns the value of the "plan" field in the mutation.
func (m *OrganizationMutation) Plan() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlan returns the old "plan" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlan: %w", err)
	}
	return oldValue.Plan, nil
}

// ResetPlan resets all changes to the "plan" field.
func (m *OrganizationMutation) ResetPlan() {
	m.plan = nil
}

// SetActive sets the "active" field.
func (m *OrganizationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OrganizationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OrganizationMutation) ResetActive() {
	m.active = nil
}

// SetMetadata sets the "metadata" field.
func (m *OrganizationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *OrganizationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *OrganizationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[organization.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *OrganizationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[organization.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *OrganizationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, organization.FieldMetadata)
}

// SetTrialEndsAt sets the "trial_ends_at" field.
func (m *OrganizationMutation) SetTrialEndsAt(t time.Time) {
	m.trial_ends_at = &t
}

// TrialEndsAt returns the value of the "trial_ends_at" field in the mutation.
func (m *OrganizationMutation) TrialEndsAt() (r time.Time, exists bool) {
	v := m.trial_ends_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialEndsAt returns the old "trial_ends_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTrialEndsAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialEndsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialEndsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialEndsAt: %w", err)
	}
	return oldValue.TrialEndsAt, nil
}

// ClearTrialEndsAt clears the value of the "trial_ends_at" field.
func (m *OrganizationMutation) ClearTrialEndsAt() {
	m.trial_ends_at = nil
	m.clearedFields[organization.FieldTrialEndsAt] = struct{}{}
}

// TrialEndsAtCleared returns if the "trial_ends_at" field was cleared in this mutation.
func (m *OrganizationMutation) TrialEndsAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldTrialEndsAt]
	return ok
}

// ResetTrialEndsAt resets all changes to the "trial_ends_at" field.
func (m *OrganizationMutation) ResetTrialEndsAt() {
	m.trial_ends_at = nil
	delete(m.clearedFields, organization.FieldTrialEndsAt)
}

// SetTrialUsed sets the "trial_used" field.
func (m *OrganizationMutation) SetTrialUsed(b bool) {
	m.trial_used = &b
}

// TrialUsed returns the value of the "trial_used" field in the mutation.
func (m *OrganizationMutation) TrialUsed() (r bool, exists bool) {
	v := m.trial_used
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialUsed returns the old "trial_used" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTrialUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialUsed: %w", err)
	}
	return oldValue.TrialUsed, nil
}

// ResetTrialUsed resets all changes to the "trial_used" field.
func (m *OrganizationMutation) ResetTrialUsed() {
	m.trial_used = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *OrganizationMutation) AddAPIKeyIDs(ids ...string) {
	if m.api_keys == nil {
		m.api_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *OrganizationMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *OrganizationMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *OrganizationMutation) RemoveAPIKeyIDs(ids ...string) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *OrganizationMutation) RemovedAPIKeysIDs() (ids []string) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *OrganizationMutation) APIKeysIDs() (ids []string) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *OrganizationMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddWebhookIDs adds the "webhooks" edge to the Webhook entity by ids.
func (m *OrganizationMutation) AddWebhookIDs(ids ...string) {
	if m.webhooks == nil {
		m.webhooks = make(map[string]struct{})
	}
	for i := range ids {
		m.webhooks[ids[i]] = struct{}{}
	}
}

// ClearWebhooks clears the "webhooks" edge to the Webhook entity.
func (m *OrganizationMutation) ClearWebhooks() {
	m.clearedwebhooks = true
}

// WebhooksCleared reports if the "webhooks" edge to the Webhook entity was cleared.
func (m *OrganizationMutation) WebhooksCleared() bool {
	return m.clearedwebhooks
}

// RemoveWebhookIDs removes the "webhooks" edge to the Webhook entity by IDs.
func (m *OrganizationMutation) RemoveWebhookIDs(ids ...string) {
	if m.removedwebhooks == nil {
		m.removedwebhooks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.webhooks, ids[i])
		m.removedwebhooks[ids[i]] = struct{}{}
	}
}

// RemovedWebhooks returns the removed IDs of the "webhooks" edge to the Webhook entity.
func (m *OrganizationMutation) RemovedWebhooksIDs() (ids []string) {
	for id := range m.removedwebhooks {
		ids = append(ids, id)
	}
	return
}

// WebhooksIDs returns the "webhooks" edge IDs in the mutation.
func (m *OrganizationMutation) WebhooksIDs() (ids []string) {
	for id := range m.webhooks {
		ids = append(ids, id)
	}
	return
}

// ResetWebhooks resets all changes to the "webhooks" edge.
func (m *OrganizationMutation) ResetWebhooks() {
	m.webhooks = nil
	m.clearedwebhooks = false
	m.removedwebhooks = nil
}

// AddFeatureFlagIDs adds the "feature_flags" edge to the OrganizationFeature entity by ids.
func (m *OrganizationMutation) AddFeatureFlagIDs(ids ...string) {
	if m.feature_flags == nil {
		m.feature_flags = make(map[string]struct{})
	}
	for i := range ids {
		m.feature_flags[ids[i]] = struct{}{}
	}
}

// ClearFeatureFlags clears the "feature_flags" edge to the OrganizationFeature entity.
func (m *OrganizationMutation) ClearFeatureFlags() {
	m.clearedfeature_flags = true
}

// FeatureFlagsCleared reports if the "feature_flags" edge to the OrganizationFeature entity was cleared.
func (m *OrganizationMutation) FeatureFlagsCleared() bool {
	return m.clearedfeature_flags
}

// RemoveFeatureFlagIDs removes the "feature_flags" edge to the OrganizationFeature entity by IDs.
func (m *OrganizationMutation) RemoveFeatureFlagIDs(ids ...string) {
	if m.removedfeature_flags == nil {
		m.removedfeature_flags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.feature_flags, ids[i])
		m.removedfeature_flags[ids[i]] = struct{}{}
	}
}

// RemovedFeatureFlags returns the removed IDs of the "feature_flags" edge to the OrganizationFeature entity.
func (m *OrganizationMutation) RemovedFeatureFlagsIDs() (ids []string) {
	for id := range m.removedfeature_flags {
		ids = append(ids, id)
	}
	return
}

// FeatureFlagsIDs returns the "feature_flags" edge IDs in the mutation.
func (m *OrganizationMutation) FeatureFlagsIDs() (ids []string) {
	for id := range m.feature_flags {
		ids = append(ids, id)
	}
	return
}

// ResetFeatureFlags resets all changes to the "feature_flags" edge.
func (m *OrganizationMutation) ResetFeatureFlags() {
	m.feature_flags = nil
	m.clearedfeature_flags = false
	m.removedfeature_flags = nil
}

// AddIdentityProviderIDs adds the "identity_providers" edge to the IdentityProvider entity by ids.
func (m *OrganizationMutation) AddIdentityProviderIDs(ids ...string) {
	if m.identity_providers == nil {
		m.identity_providers = make(map[string]struct{})
	}
	for i := range ids {
		m.identity_providers[ids[i]] = struct{}{}
	}
}

// ClearIdentityProviders clears the "identity_providers" edge to the IdentityProvider entity.
func (m *OrganizationMutation) ClearIdentityProviders() {
	m.clearedidentity_providers = true
}

// IdentityProvidersCleared reports if the "identity_providers" edge to the IdentityProvider entity was cleared.
func (m *OrganizationMutation) IdentityProvidersCleared() bool {
	return m.clearedidentity_providers
}

// RemoveIdentityProviderIDs removes the "identity_providers" edge to the IdentityProvider entity by IDs.
func (m *OrganizationMutation) RemoveIdentityProviderIDs(ids ...string) {
	if m.removedidentity_providers == nil {
		m.removedidentity_providers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.identity_providers, ids[i])
		m.removedidentity_providers[ids[i]] = struct{}{}
	}
}

// RemovedIdentityProviders returns the removed IDs of the "identity_providers" edge to the IdentityProvider entity.
func (m *OrganizationMutation) RemovedIdentityProvidersIDs() (ids []string) {
	for id := range m.removedidentity_providers {
		ids = append(ids, id)
	}
	return
}

// IdentityProvidersIDs returns the "identity_providers" edge IDs in the mutation.
func (m *OrganizationMutation) IdentityProvidersIDs() (ids []string) {
	for id := range m.identity_providers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentityProviders resets all changes to the "identity_providers" edge.
func (m *OrganizationMutation) ResetIdentityProviders() {
	m.identity_providers = nil
	m.clearedidentity_providers = false
	m.removedidentity_providers = nil
}

// AddOauthClientIDs adds the "oauth_clients" edge to the OAuthClient entity by ids.
func (m *OrganizationMutation) AddOauthClientIDs(ids ...string) {
	if m.oauth_clients == nil {
		m.oauth_clients = make(map[string]struct{})
	}
	for i := range ids {
		m.oauth_clients[ids[i]] = struct{}{}
	}
}

// ClearOauthClients clears the "oauth_clients" edge to the OAuthClient entity.
func (m *OrganizationMutation) ClearOauthClients() {
	m.clearedoauth_clients = true
}

// OauthClientsCleared reports if the "oauth_clients" edge to the OAuthClient entity was cleared.
func (m *OrganizationMutation) OauthClientsCleared() bool {
	return m.clearedoauth_clients
}

// RemoveOauthClientIDs removes the "oauth_clients" edge to the OAuthClient entity by IDs.
func (m *OrganizationMutation) RemoveOauthClientIDs(ids ...string) {
	if m.removedoauth_clients == nil {
		m.removedoauth_clients = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.oauth_clients, ids[i])
		m.removedoauth_clients[ids[i]] = struct{}{}
	}
}

// RemovedOauthClients returns the removed IDs of the "oauth_clients" edge to the OAuthClient entity.
func (m *OrganizationMutation) RemovedOauthClientsIDs() (ids []string) {
	for id := range m.removedoauth_clients {
		ids = append(ids, id)
	}
	return
}

// OauthClientsIDs returns the "oauth_clients" edge IDs in the mutation.
func (m *OrganizationMutation) OauthClientsIDs() (ids []string) {
	for id := range m.oauth_clients {
		ids = append(ids, id)
	}
	return
}

// ResetOauthClients resets all changes to the "oauth_clients" edge.
func (m *OrganizationMutation) ResetOauthClients() {
	m.oauth_clients = nil
	m.clearedoauth_clients = false
	m.removedoauth_clients = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, organization.FieldSlug)
	}
	if m.domain != nil {
		fields = append(fields, organization.FieldDomain)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.plan != nil {
		fields = append(fields, organization.FieldPlan)
	}
	if m.active != nil {
		fields = append(fields, organization.FieldActive)
	}
	if m.metadata != nil {
		fields = append(fields, organization.FieldMetadata)
	}
	if m.trial_ends_at != nil {
		fields = append(fields, organization.FieldTrialEndsAt)
	}
	if m.trial_used != nil {
		fields = append(fields, organization.FieldTrialUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldName:
		return m.Name()
	case organization.FieldSlug:
		return m.Slug()
	case organization.FieldDomain:
		return m.Domain()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldPlan:
		return m.Plan()
	case organization.FieldActive:
		return m.Active()
	case organization.FieldMetadata:
		return m.Metadata()
	case organization.FieldTrialEndsAt:
		return m.TrialEndsAt()
	case organization.FieldTrialUsed:
		return m.TrialUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldSlug:
		return m.OldSlug(ctx)
	case organization.FieldDomain:
		return m.OldDomain(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldPlan:
		return m.OldPlan(ctx)
	case organization.FieldActive:
		return m.OldActive(ctx)
	case organization.FieldMetadata:
		return m.OldMetadata(ctx)
	case organization.FieldTrialEndsAt:
		return m.OldTrialEndsAt(ctx)
	case organization.FieldTrialUsed:
		return m.OldTrialUsed(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case organization.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlan(v)
		return nil
	case organization.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case organization.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case organization.FieldTrialEndsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialEndsAt(v)
		return nil
	case organization.FieldTrialUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialUsed(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldDomain) {
		fields = append(fields, organization.FieldDomain)
	}
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.FieldCleared(organization.FieldMetadata) {
		fields = append(fields, organization.FieldMetadata)
	}
	if m.FieldCleared(organization.FieldTrialEndsAt) {
		fields = append(fields, organization.FieldTrialEndsAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldDomain:
		m.ClearDomain()
		return nil
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case organization.FieldMetadata:
		m.ClearMetadata()
		return nil
	case organization.FieldTrialEndsAt:
		m.ClearTrialEndsAt()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldSlug:
		m.ResetSlug()
		return nil
	case organization.FieldDomain:
		m.ResetDomain()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldPlan:
		m.ResetPlan()
		return nil
	case organization.FieldActive:
		m.ResetActive()
		return nil
	case organization.FieldMetadata:
		m.ResetMetadata()
		return nil
	case organization.FieldTrialEndsAt:
		m.ResetTrialEndsAt()
		return nil
	case organization.FieldTrialUsed:
		m.ResetTrialUsed()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.api_keys != nil {
		edges = append(edges, organization.EdgeAPIKeys)
	}
	if m.webhooks != nil {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.feature_flags != nil {
		edges = append(edges, organization.EdgeFeatureFlags)
	}
	if m.identity_providers != nil {
		edges = append(edges, organization.EdgeIdentityProviders)
	}
	if m.oauth_clients != nil {
		edges = append(edges, organization.EdgeOauthClients)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.webhooks))
		for id := range m.webhooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFeatureFlags:
		ids := make([]ent.Value, 0, len(m.feature_flags))
		for id := range m.feature_flags {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIdentityProviders:
		ids := make([]ent.Value, 0, len(m.identity_providers))
		for id := range m.identity_providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOauthClients:
		ids := make([]ent.Value, 0, len(m.oauth_clients))
		for id := range m.oauth_clients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, organization.EdgeAPIKeys)
	}
	if m.removedwebhooks != nil {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.removedfeature_flags != nil {
		edges = append(edges, organization.EdgeFeatureFlags)
	}
	if m.removedidentity_providers != nil {
		edges = append(edges, organization.EdgeIdentityProviders)
	}
	if m.removedoauth_clients != nil {
		edges = append(edges, organization.EdgeOauthClients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.removedwebhooks))
		for id := range m.removedwebhooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFeatureFlags:
		ids := make([]ent.Value, 0, len(m.removedfeature_flags))
		for id := range m.removedfeature_flags {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIdentityProviders:
		ids := make([]ent.Value, 0, len(m.removedidentity_providers))
		for id := range m.removedidentity_providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOauthClients:
		ids := make([]ent.Value, 0, len(m.removedoauth_clients))
		for id := range m.removedoauth_clients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedapi_keys {
		edges = append(edges, organization.EdgeAPIKeys)
	}
	if m.clearedwebhooks {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.clearedfeature_flags {
		edges = append(edges, organization.EdgeFeatureFlags)
	}
	if m.clearedidentity_providers {
		edges = append(edges, organization.EdgeIdentityProviders)
	}
	if m.clearedoauth_clients {
		edges = append(edges, organization.EdgeOauthClients)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeAPIKeys:
		return m.clearedapi_keys
	case organization.EdgeWebhooks:
		return m.clearedwebhooks
	case organization.EdgeFeatureFlags:
		return m.clearedfeature_flags
	case organization.EdgeIdentityProviders:
		return m.clearedidentity_providers
	case organization.EdgeOauthClients:
		return m.clearedoauth_clients
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case organization.EdgeWebhooks:
		m.ResetWebhooks()
		return nil
	case organization.EdgeFeatureFlags:
		m.ResetFeatureFlags()
		return nil
	case organization.EdgeIdentityProviders:
		m.ResetIdentityProviders()
		return nil
	case organization.EdgeOauthClients:
		m.ResetOauthClients()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationFeatureMutation represents an operation that mutates the OrganizationFeature nodes in the graph.
type OrganizationFeatureMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	enabled             *bool
	settings            *map[string]interface{}
	clearedFields       map[string]struct{}
	organization        *string
	clearedorganization bool
	feature             *string
	clearedfeature      bool
	done                bool
	oldValue            func(context.Context) (*OrganizationFeature, error)
	predicates          []predicate.OrganizationFeature
}

var _ ent.Mutation = (*OrganizationFeatureMutation)(nil)

// organizationfeatureOption allows management of the mutation configuration using functional options.
type organizationfeatureOption func(*OrganizationFeatureMutation)

// newOrganizationFeatureMutation creates new mutation for the OrganizationFeature entity.
func newOrganizationFeatureMutation(c config, op Op, opts ...organizationfeatureOption) *OrganizationFeatureMutation {
	m := &OrganizationFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationFeatureID sets the ID field of the mutation.
func withOrganizationFeatureID(id string) organizationfeatureOption {
	return func(m *OrganizationFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationFeature
		)
		m.oldValue = func(ctx context.Context) (*OrganizationFeature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationFeature sets the old OrganizationFeature of the mutation.
func withOrganizationFeature(node *OrganizationFeature) organizationfeatureOption {
	return func(m *OrganizationFeatureMutation) {
		m.oldValue = func(context.Context) (*OrganizationFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationFeature entities.
func (m *OrganizationFeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationFeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationFeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationFeature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationFeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationFeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationFeatureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationFeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationFeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationFeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationFeatureMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationFeatureMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationFeatureMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *OrganizationFeatureMutation) SetFeatureID(s string) {
	m.feature = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *OrganizationFeatureMutation) FeatureID() (r string, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *OrganizationFeatureMutation) ResetFeatureID() {
	m.feature = nil
}

// SetEnabled sets the "enabled" field.
func (m *OrganizationFeatureMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *OrganizationFeatureMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *OrganizationFeatureMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSettings sets the "settings" field.
func (m *OrganizationFeatureMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *OrganizationFeatureMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the OrganizationFeature entity.
// If the OrganizationFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *OrganizationFeatureMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[organizationfeature.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *OrganizationFeatureMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[organizationfeature.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *OrganizationFeatureMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, organizationfeature.FieldSettings)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationFeatureMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationfeature.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationFeatureMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationFeatureMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationFeatureMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearFeature clears the "feature" edge to the FeatureFlag entity.
func (m *OrganizationFeatureMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[organizationfeature.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the FeatureFlag entity was cleared.
func (m *OrganizationFeatureMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *OrganizationFeatureMutation) FeatureIDs() (ids []string) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *OrganizationFeatureMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the OrganizationFeatureMutation builder.
func (m *OrganizationFeatureMutation) Where(ps ...predicate.OrganizationFeature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationFeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationFeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationFeature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationFeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationFeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationFeature).
func (m *OrganizationFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationFeatureMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, organizationfeature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationfeature.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationfeature.FieldOrganizationID)
	}
	if m.feature != nil {
		fields = append(fields, organizationfeature.FieldFeatureID)
	}
	if m.enabled != nil {
		fields = append(fields, organizationfeature.FieldEnabled)
	}
	if m.settings != nil {
		fields = append(fields, organizationfeature.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationFeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationfeature.FieldCreatedAt:
		return m.CreatedAt()
	case organizationfeature.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationfeature.FieldOrganizationID:
		return m.OrganizationID()
	case organizationfeature.FieldFeatureID:
		return m.FeatureID()
	case organizationfeature.FieldEnabled:
		return m.Enabled()
	case organizationfeature.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationfeature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationfeature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationfeature.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationfeature.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case organizationfeature.FieldEnabled:
		return m.OldEnabled(ctx)
	case organizationfeature.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationfeature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationfeature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationfeature.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationfeature.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case organizationfeature.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case organizationfeature.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationFeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationFeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationFeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationFeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationfeature.FieldSettings) {
		fields = append(fields, organizationfeature.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationFeatureMutation) ClearField(name string) error {
	switch name {
	case organizationfeature.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationFeatureMutation) ResetField(name string) error {
	switch name {
	case organizationfeature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationfeature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationfeature.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationfeature.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case organizationfeature.FieldEnabled:
		m.ResetEnabled()
		return nil
	case organizationfeature.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationfeature.EdgeOrganization)
	}
	if m.feature != nil {
		edges = append(edges, organizationfeature.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationfeature.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationfeature.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationFeatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationfeature.EdgeOrganization)
	}
	if m.clearedfeature {
		edges = append(edges, organizationfeature.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationfeature.EdgeOrganization:
		return m.clearedorganization
	case organizationfeature.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationFeatureMutation) ClearEdge(name string) error {
	switch name {
	case organizationfeature.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationfeature.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationFeatureMutation) ResetEdge(name string) error {
	switch name {
	case organizationfeature.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationfeature.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeature edge %s", name)
}

// PasskeyMutation represents an operation that mutates the Passkey nodes in the graph.
type PasskeyMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	credential_id    *string
	public_key       *[]byte
	sign_count       *int
	addsign_count    *int
	active           *bool
	device_type      *string
	aaguid           *string
	last_used        *time.Time
	transports       *[]string
	appendtransports []string
	attestation      *map[string]interface{}
	clearedFields    map[string]struct{}
	user             *string
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Passkey, error)
	predicates       []predicate.Passkey
}

var _ ent.Mutation = (*PasskeyMutation)(nil)

// passkeyOption allows management of the mutation configuration using functional options.
type passkeyOption func(*PasskeyMutation)

// newPasskeyMutation creates new mutation for the Passkey entity.
func newPasskeyMutation(c config, op Op, opts ...passkeyOption) *PasskeyMutation {
	m := &PasskeyMutation{
		config:        c,
		op:            op,
		typ:           TypePasskey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasskeyID sets the ID field of the mutation.
func withPasskeyID(id string) passkeyOption {
	return func(m *PasskeyMutation) {
		var (
			err   error
			once  sync.Once
			value *Passkey
		)
		m.oldValue = func(ctx context.Context) (*Passkey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passkey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasskey sets the old Passkey of the mutation.
func withPasskey(node *Passkey) passkeyOption {
	return func(m *PasskeyMutation) {
		m.oldValue = func(context.Context) (*Passkey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasskeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasskeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Passkey entities.
func (m *PasskeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasskeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasskeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passkey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasskeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasskeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasskeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasskeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasskeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasskeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *PasskeyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasskeyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasskeyMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *PasskeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PasskeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasskeyMutation) ResetName() {
	m.name = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *PasskeyMutation) SetCredentialID(s string) {
	m.credential_id = &s
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *PasskeyMutation) CredentialID() (r string, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCredentialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *PasskeyMutation) ResetCredentialID() {
	m.credential_id = nil
}

// SetPublicKey sets the "public_key" field.
func (m *PasskeyMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *PasskeyMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *PasskeyMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetSignCount sets the "sign_count" field.
func (m *PasskeyMutation) SetSignCount(i int) {
	m.sign_count = &i
	m.addsign_count = nil
}

// SignCount returns the value of the "sign_count" field in the mutation.
func (m *PasskeyMutation) SignCount() (r int, exists bool) {
	v := m.sign_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "sign_count" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldSignCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds i to the "sign_count" field.
func (m *PasskeyMutation) AddSignCount(i int) {
	if m.addsign_count != nil {
		*m.addsign_count += i
	} else {
		m.addsign_count = &i
	}
}

// AddedSignCount returns the value that was added to the "sign_count" field in this mutation.
func (m *PasskeyMutation) AddedSignCount() (r int, exists bool) {
	v := m.addsign_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "sign_count" field.
func (m *PasskeyMutation) ResetSignCount() {
	m.sign_count = nil
	m.addsign_count = nil
}

// SetActive sets the "active" field.
func (m *PasskeyMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PasskeyMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PasskeyMutation) ResetActive() {
	m.active = nil
}

// SetDeviceType sets the "device_type" field.
func (m *PasskeyMutation) SetDeviceType(s string) {
	m.device_type = &s
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *PasskeyMutation) DeviceType() (r string, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldDeviceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ClearDeviceType clears the value of the "device_type" field.
func (m *PasskeyMutation) ClearDeviceType() {
	m.device_type = nil
	m.clearedFields[passkey.FieldDeviceType] = struct{}{}
}

// DeviceTypeCleared returns if the "device_type" field was cleared in this mutation.
func (m *PasskeyMutation) DeviceTypeCleared() bool {
	_, ok := m.clearedFields[passkey.FieldDeviceType]
	return ok
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *PasskeyMutation) ResetDeviceType() {
	m.device_type = nil
	delete(m.clearedFields, passkey.FieldDeviceType)
}

// SetAaguid sets the "aaguid" field.
func (m *PasskeyMutation) SetAaguid(s string) {
	m.aaguid = &s
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *PasskeyMutation) Aaguid() (r string, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAaguid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ClearAaguid clears the value of the "aaguid" field.
func (m *PasskeyMutation) ClearAaguid() {
	m.aaguid = nil
	m.clearedFields[passkey.FieldAaguid] = struct{}{}
}

// AaguidCleared returns if the "aaguid" field was cleared in this mutation.
func (m *PasskeyMutation) AaguidCleared() bool {
	_, ok := m.clearedFields[passkey.FieldAaguid]
	return ok
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *PasskeyMutation) ResetAaguid() {
	m.aaguid = nil
	delete(m.clearedFields, passkey.FieldAaguid)
}

// SetLastUsed sets the "last_used" field.
func (m *PasskeyMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *PasskeyMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *PasskeyMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[passkey.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *PasskeyMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[passkey.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *PasskeyMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, passkey.FieldLastUsed)
}

// SetTransports sets the "transports" field.
func (m *PasskeyMutation) SetTransports(s []string) {
	m.transports = &s
	m.appendtransports = nil
}

// Transports returns the value of the "transports" field in the mutation.
func (m *PasskeyMutation) Transports() (r []string, exists bool) {
	v := m.transports
	if v == nil {
		return
	}
	return *v, true
}

// OldTransports returns the old "transports" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldTransports(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransports: %w", err)
	}
	return oldValue.Transports, nil
}

// AppendTransports adds s to the "transports" field.
func (m *PasskeyMutation) AppendTransports(s []string) {
	m.appendtransports = append(m.appendtransports, s...)
}

// AppendedTransports returns the list of values that were appended to the "transports" field in this mutation.
func (m *PasskeyMutation) AppendedTransports() ([]string, bool) {
	if len(m.appendtransports) == 0 {
		return nil, false
	}
	return m.appendtransports, true
}

// ClearTransports clears the value of the "transports" field.
func (m *PasskeyMutation) ClearTransports() {
	m.transports = nil
	m.appendtransports = nil
	m.clearedFields[passkey.FieldTransports] = struct{}{}
}

// TransportsCleared returns if the "transports" field was cleared in this mutation.
func (m *PasskeyMutation) TransportsCleared() bool {
	_, ok := m.clearedFields[passkey.FieldTransports]
	return ok
}

// ResetTransports resets all changes to the "transports" field.
func (m *PasskeyMutation) ResetTransports() {
	m.transports = nil
	m.appendtransports = nil
	delete(m.clearedFields, passkey.FieldTransports)
}

// SetAttestation sets the "attestation" field.
func (m *PasskeyMutation) SetAttestation(value map[string]interface{}) {
	m.attestation = &value
}

// Attestation returns the value of the "attestation" field in the mutation.
func (m *PasskeyMutation) Attestation() (r map[string]interface{}, exists bool) {
	v := m.attestation
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestation returns the old "attestation" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAttestation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestation: %w", err)
	}
	return oldValue.Attestation, nil
}

// ClearAttestation clears the value of the "attestation" field.
func (m *PasskeyMutation) ClearAttestation() {
	m.attestation = nil
	m.clearedFields[passkey.FieldAttestation] = struct{}{}
}

// AttestationCleared returns if the "attestation" field was cleared in this mutation.
func (m *PasskeyMutation) AttestationCleared() bool {
	_, ok := m.clearedFields[passkey.FieldAttestation]
	return ok
}

// ResetAttestation resets all changes to the "attestation" field.
func (m *PasskeyMutation) ResetAttestation() {
	m.attestation = nil
	delete(m.clearedFields, passkey.FieldAttestation)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasskeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passkey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasskeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasskeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasskeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasskeyMutation builder.
func (m *PasskeyMutation) Where(ps ...predicate.Passkey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasskeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasskeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passkey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasskeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasskeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passkey).
func (m *PasskeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasskeyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, passkey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passkey.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, passkey.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, passkey.FieldName)
	}
	if m.credential_id != nil {
		fields = append(fields, passkey.FieldCredentialID)
	}
	if m.public_key != nil {
		fields = append(fields, passkey.FieldPublicKey)
	}
	if m.sign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	if m.active != nil {
		fields = append(fields, passkey.FieldActive)
	}
	if m.device_type != nil {
		fields = append(fields, passkey.FieldDeviceType)
	}
	if m.aaguid != nil {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.last_used != nil {
		fields = append(fields, passkey.FieldLastUsed)
	}
	if m.transports != nil {
		fields = append(fields, passkey.FieldTransports)
	}
	if m.attestation != nil {
		fields = append(fields, passkey.FieldAttestation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasskeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.CreatedAt()
	case passkey.FieldUpdatedAt:
		return m.UpdatedAt()
	case passkey.FieldUserID:
		return m.UserID()
	case passkey.FieldName:
		return m.Name()
	case passkey.FieldCredentialID:
		return m.CredentialID()
	case passkey.FieldPublicKey:
		return m.PublicKey()
	case passkey.FieldSignCount:
		return m.SignCount()
	case passkey.FieldActive:
		return m.Active()
	case passkey.FieldDeviceType:
		return m.DeviceType()
	case passkey.FieldAaguid:
		return m.Aaguid()
	case passkey.FieldLastUsed:
		return m.LastUsed()
	case passkey.FieldTransports:
		return m.Transports()
	case passkey.FieldAttestation:
		return m.Attestation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasskeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passkey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passkey.FieldUserID:
		return m.OldUserID(ctx)
	case passkey.FieldName:
		return m.OldName(ctx)
	case passkey.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case passkey.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case passkey.FieldSignCount:
		return m.OldSignCount(ctx)
	case passkey.FieldActive:
		return m.OldActive(ctx)
	case passkey.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case passkey.FieldAaguid:
		return m.OldAaguid(ctx)
	case passkey.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case passkey.FieldTransports:
		return m.OldTransports(ctx)
	case passkey.FieldAttestation:
		return m.OldAttestation(ctx)
	}
	return nil, fmt.Errorf("unknown Passkey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passkey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passkey.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passkey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case passkey.FieldCredentialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case passkey.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case passkey.FieldSignCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case passkey.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case passkey.FieldDeviceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case passkey.FieldAaguid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case passkey.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case passkey.FieldTransports:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransports(v)
		return nil
	case passkey.FieldAttestation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestation(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasskeyMutation) AddedFields() []string {
	var fields []string
	if m.addsign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasskeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldSignCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasskeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passkey.FieldDeviceType) {
		fields = append(fields, passkey.FieldDeviceType)
	}
	if m.FieldCleared(passkey.FieldAaguid) {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.FieldCleared(passkey.FieldLastUsed) {
		fields = append(fields, passkey.FieldLastUsed)
	}
	if m.FieldCleared(passkey.FieldTransports) {
		fields = append(fields, passkey.FieldTransports)
	}
	if m.FieldCleared(passkey.FieldAttestation) {
		fields = append(fields, passkey.FieldAttestation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasskeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasskeyMutation) ClearField(name string) error {
	switch name {
	case passkey.FieldDeviceType:
		m.ClearDeviceType()
		return nil
	case passkey.FieldAaguid:
		m.ClearAaguid()
		return nil
	case passkey.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case passkey.FieldTransports:
		m.ClearTransports()
		return nil
	case passkey.FieldAttestation:
		m.ClearAttestation()
		return nil
	}
	return fmt.Errorf("unknown Passkey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasskeyMutation) ResetField(name string) error {
	switch name {
	case passkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passkey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passkey.FieldUserID:
		m.ResetUserID()
		return nil
	case passkey.FieldName:
		m.ResetName()
		return nil
	case passkey.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case passkey.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case passkey.FieldSignCount:
		m.ResetSignCount()
		return nil
	case passkey.FieldActive:
		m.ResetActive()
		return nil
	case passkey.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case passkey.FieldAaguid:
		m.ResetAaguid()
		return nil
	case passkey.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case passkey.FieldTransports:
		m.ResetTransports()
		return nil
	case passkey.FieldAttestation:
		m.ResetAttestation()
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasskeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasskeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasskeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasskeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasskeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasskeyMutation) EdgeCleared(name string) bool {
	switch name {
	case passkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasskeyMutation) ClearEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasskeyMutation) ResetEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	resource      *string
	action        *string
	conditions    *string
	system        *bool
	clearedFields map[string]struct{}
	roles         map[string]struct{}
	removedroles  map[string]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id string) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
}

// SetResource sets the "resource" field.
func (m *PermissionMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *PermissionMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *PermissionMutation) ResetResource() {
	m.resource = nil
}

// SetAction sets the "action" field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
}

// SetConditions sets the "conditions" field.
func (m *PermissionMutation) SetConditions(s string) {
	m.conditions = &s
}

// Conditions returns the value of the "conditions" field in the mutation.
func (m *PermissionMutation) Conditions() (r string, exists bool) {
	v := m.conditions
	if v == nil {
		return
	}
	return *v, true
}

// OldConditions returns the old "conditions" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldConditions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditions: %w", err)
	}
	return oldValue.Conditions, nil
}

// ClearConditions clears the value of the "conditions" field.
func (m *PermissionMutation) ClearConditions() {
	m.conditions = nil
	m.clearedFields[permission.FieldConditions] = struct{}{}
}

// ConditionsCleared returns if the "conditions" field was cleared in this mutation.
func (m *PermissionMutation) ConditionsCleared() bool {
	_, ok := m.clearedFields[permission.FieldConditions]
	return ok
}

// ResetConditions resets all changes to the "conditions" field.
func (m *PermissionMutation) ResetConditions() {
	m.conditions = nil
	delete(m.clearedFields, permission.FieldConditions)
}

// SetSystem sets the "system" field.
func (m *PermissionMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *PermissionMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *PermissionMutation) ResetSystem() {
	m.system = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...string) {
	if m.roles == nil {
		m.roles = make(map[string]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...string) {
	if m.removedroles == nil {
		m.removedroles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []string) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []string) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.resource != nil {
		fields = append(fields, permission.FieldResource)
	}
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	if m.conditions != nil {
		fields = append(fields, permission.FieldConditions)
	}
	if m.system != nil {
		fields = append(fields, permission.FieldSystem)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldName:
		return m.Name()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldResource:
		return m.Resource()
	case permission.FieldAction:
		return m.Action()
	case permission.FieldConditions:
		return m.Conditions()
	case permission.FieldSystem:
		return m.System()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldResource:
		return m.OldResource(ctx)
	case permission.FieldAction:
		return m.OldAction(ctx)
	case permission.FieldConditions:
		return m.OldConditions(ctx)
	case permission.FieldSystem:
		return m.OldSystem(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permission.FieldConditions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditions(v)
		return nil
	case permission.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldConditions) {
		fields = append(fields, permission.FieldConditions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldConditions:
		m.ClearConditions()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldResource:
		m.ResetResource()
		return nil
	case permission.FieldAction:
		m.ResetAction()
		return nil
	case permission.FieldConditions:
		m.ResetConditions()
		return nil
	case permission.FieldSystem:
		m.ResetSystem()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	organization_id    *string
	system             *bool
	is_default         *bool
	clearedFields      map[string]struct{}
	users              map[string]struct{}
	removedusers       map[string]struct{}
	clearedusers       bool
	permissions        map[string]struct{}
	removedpermissions map[string]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetOrganizationID sets the "organization_id" field.
func (m *RoleMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RoleMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *RoleMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[role.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *RoleMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[role.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RoleMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, role.FieldOrganizationID)
}

// SetSystem sets the "system" field.
func (m *RoleMutation) SetSystem(b bool) {
	m.system = &b
}

// System returns the value of the "system" field in the mutation.
func (m *RoleMutation) System() (r bool, exists bool) {
	v := m.system
	if v == nil {
		return
	}
	return *v, true
}

// OldSystem returns the old "system" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystem: %w", err)
	}
	return oldValue.System, nil
}

// ResetSystem resets all changes to the "system" field.
func (m *RoleMutation) ResetSystem() {
	m.system = nil
}

// SetIsDefault sets the "is_default" field.
func (m *RoleMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *RoleMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *RoleMutation) ResetIsDefault() {
	m.is_default = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...string) {
	if m.permissions == nil {
		m.permissions = make(map[string]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...string) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []string) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []string) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.organization_id != nil {
		fields = append(fields, role.FieldOrganizationID)
	}
	if m.system != nil {
		fields = append(fields, role.FieldSystem)
	}
	if m.is_default != nil {
		fields = append(fields, role.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldOrganizationID:
		return m.OrganizationID()
	case role.FieldSystem:
		return m.System()
	case role.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case role.FieldSystem:
		return m.OldSystem(ctx)
	case role.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case role.FieldSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystem(v)
		return nil
	case role.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldOrganizationID) {
		fields = append(fields, role.FieldOrganizationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case role.FieldSystem:
		m.ResetSystem()
		return nil
	case role.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SSOStateMutation represents an operation that mutates the SSOState nodes in the graph.
type SSOStateMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	state         *string
	data          *string
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SSOState, error)
	predicates    []predicate.SSOState
}

var _ ent.Mutation = (*SSOStateMutation)(nil)

// ssostateOption allows management of the mutation configuration using functional options.
type ssostateOption func(*SSOStateMutation)

// newSSOStateMutation creates new mutation for the SSOState entity.
func newSSOStateMutation(c config, op Op, opts ...ssostateOption) *SSOStateMutation {
	m := &SSOStateMutation{
		config:        c,
		op:            op,
		typ:           TypeSSOState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSSOStateID sets the ID field of the mutation.
func withSSOStateID(id string) ssostateOption {
	return func(m *SSOStateMutation) {
		var (
			err   error
			once  sync.Once
			value *SSOState
		)
		m.oldValue = func(ctx context.Context) (*SSOState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SSOState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSSOState sets the old SSOState of the mutation.
func withSSOState(node *SSOState) ssostateOption {
	return func(m *SSOStateMutation) {
		m.oldValue = func(context.Context) (*SSOState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SSOStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SSOStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SSOState entities.
func (m *SSOStateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SSOStateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SSOStateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SSOState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SSOStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SSOStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SSOStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SSOStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SSOStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SSOStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *SSOStateMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *SSOStateMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *SSOStateMutation) ResetState() {
	m.state = nil
}

// SetData sets the "data" field.
func (m *SSOStateMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *SSOStateMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SSOStateMutation) ResetData() {
	m.data = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SSOStateMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SSOStateMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SSOState entity.
// If the SSOState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SSOStateMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SSOStateMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// Where appends a list predicates to the SSOStateMutation builder.
func (m *SSOStateMutation) Where(ps ...predicate.SSOState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SSOStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SSOStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SSOState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SSOStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SSOStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SSOState).
func (m *SSOStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SSOStateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, ssostate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ssostate.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, ssostate.FieldState)
	}
	if m.data != nil {
		fields = append(fields, ssostate.FieldData)
	}
	if m.expires_at != nil {
		fields = append(fields, ssostate.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SSOStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ssostate.FieldCreatedAt:
		return m.CreatedAt()
	case ssostate.FieldUpdatedAt:
		return m.UpdatedAt()
	case ssostate.FieldState:
		return m.State()
	case ssostate.FieldData:
		return m.Data()
	case ssostate.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SSOStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ssostate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ssostate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ssostate.FieldState:
		return m.OldState(ctx)
	case ssostate.FieldData:
		return m.OldData(ctx)
	case ssostate.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown SSOState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SSOStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ssostate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ssostate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ssostate.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case ssostate.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case ssostate.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown SSOState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SSOStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SSOStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SSOStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SSOState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SSOStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SSOStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SSOStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SSOState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SSOStateMutation) ResetField(name string) error {
	switch name {
	case ssostate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ssostate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ssostate.FieldState:
		m.ResetState()
		return nil
	case ssostate.FieldData:
		m.ResetData()
		return nil
	case ssostate.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown SSOState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SSOStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SSOStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SSOStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SSOStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SSOStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SSOStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SSOStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SSOState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SSOStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SSOState edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	token           *string
	ip_address      *string
	user_agent      *string
	device_id       *string
	location        *string
	organization_id *string
	active          *bool
	expires_at      *time.Time
	last_active_at  *time.Time
	metadata        *map[string]interface{}
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Session, error)
	predicates      []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetDeviceID sets the "device_id" field.
func (m *SessionMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *SessionMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *SessionMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[session.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *SessionMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[session.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *SessionMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, session.FieldDeviceID)
}

// SetLocation sets the "location" field.
func (m *SessionMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *SessionMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *SessionMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[session.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *SessionMutation) LocationCleared() bool {
	_, ok := m.clearedFields[session.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *SessionMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, session.FieldLocation)
}

// SetOrganizationID sets the "organization_id" field.
func (m *SessionMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *SessionMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *SessionMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[session.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *SessionMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[session.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *SessionMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, session.FieldOrganizationID)
}

// SetActive sets the "active" field.
func (m *SessionMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *SessionMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *SessionMutation) ResetActive() {
	m.active = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *SessionMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *SessionMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *SessionMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetMetadata sets the "metadata" field.
func (m *SessionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SessionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SessionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[session.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SessionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[session.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SessionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, session.FieldMetadata)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.device_id != nil {
		fields = append(fields, session.FieldDeviceID)
	}
	if m.location != nil {
		fields = append(fields, session.FieldLocation)
	}
	if m.organization_id != nil {
		fields = append(fields, session.FieldOrganizationID)
	}
	if m.active != nil {
		fields = append(fields, session.FieldActive)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_active_at != nil {
		fields = append(fields, session.FieldLastActiveAt)
	}
	if m.metadata != nil {
		fields = append(fields, session.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldUserID:
		return m.UserID()
	case session.FieldToken:
		return m.Token()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldDeviceID:
		return m.DeviceID()
	case session.FieldLocation:
		return m.Location()
	case session.FieldOrganizationID:
		return m.OrganizationID()
	case session.FieldActive:
		return m.Active()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastActiveAt:
		return m.LastActiveAt()
	case session.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case session.FieldLocation:
		return m.OldLocation(ctx)
	case session.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case session.FieldActive:
		return m.OldActive(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case session.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case session.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case session.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case session.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case session.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldDeviceID) {
		fields = append(fields, session.FieldDeviceID)
	}
	if m.FieldCleared(session.FieldLocation) {
		fields = append(fields, session.FieldLocation)
	}
	if m.FieldCleared(session.FieldOrganizationID) {
		fields = append(fields, session.FieldOrganizationID)
	}
	if m.FieldCleared(session.FieldMetadata) {
		fields = append(fields, session.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case session.FieldLocation:
		m.ClearLocation()
		return nil
	case session.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case session.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case session.FieldLocation:
		m.ResetLocation()
		return nil
	case session.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case session.FieldActive:
		m.ResetActive()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case session.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	created_at                  *time.Time
	updated_at                  *time.Time
	email                       *string
	phone_number                *string
	first_name                  *string
	last_name                   *string
	password_hash               *string
	email_verified              *bool
	phone_verified              *bool
	active                      *bool
	last_login                  *time.Time
	last_password_change        *time.Time
	metadata                    *map[string]interface{}
	profile_image_url           *string
	primary_organization_id     *string
	locale                      *string
	clearedFields               map[string]struct{}
	sessions                    map[string]struct{}
	removedsessions             map[string]struct{}
	clearedsessions             bool
	api_keys                    map[string]struct{}
	removedapi_keys             map[string]struct{}
	clearedapi_keys             bool
	organizations               map[string]struct{}
	removedorganizations        map[string]struct{}
	clearedorganizations        bool
	mfa_methods                 map[string]struct{}
	removedmfa_methods          map[string]struct{}
	clearedmfa_methods          bool
	passkeys                    map[string]struct{}
	removedpasskeys             map[string]struct{}
	clearedpasskeys             bool
	oauth_tokens                map[string]struct{}
	removedoauth_tokens         map[string]struct{}
	clearedoauth_tokens         bool
	oauth_authorizations        map[string]struct{}
	removedoauth_authorizations map[string]struct{}
	clearedoauth_authorizations bool
	verifications               map[string]struct{}
	removedverifications        map[string]struct{}
	clearedverifications        bool
	roles                       map[string]struct{}
	removedroles                map[string]struct{}
	clearedroles                bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetLastPasswordChange sets the "last_password_change" field.
func (m *UserMutation) SetLastPasswordChange(t time.Time) {
	m.last_password_change = &t
}

// LastPasswordChange returns the value of the "last_password_change" field in the mutation.
func (m *UserMutation) LastPasswordChange() (r time.Time, exists bool) {
	v := m.last_password_change
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPasswordChange returns the old "last_password_change" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastPasswordChange(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPasswordChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPasswordChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPasswordChange: %w", err)
	}
	return oldValue.LastPasswordChange, nil
}

// ClearLastPasswordChange clears the value of the "last_password_change" field.
func (m *UserMutation) ClearLastPasswordChange() {
	m.last_password_change = nil
	m.clearedFields[user.FieldLastPasswordChange] = struct{}{}
}

// LastPasswordChangeCleared returns if the "last_password_change" field was cleared in this mutation.
func (m *UserMutation) LastPasswordChangeCleared() bool {
	_, ok := m.clearedFields[user.FieldLastPasswordChange]
	return ok
}

// ResetLastPasswordChange resets all changes to the "last_password_change" field.
func (m *UserMutation) ResetLastPasswordChange() {
	m.last_password_change = nil
	delete(m.clearedFields, user.FieldLastPasswordChange)
}

// SetMetadata sets the "metadata" field.
func (m *UserMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[user.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[user.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, user.FieldMetadata)
}

// SetProfileImageURL sets the "profile_image_url" field.
func (m *UserMutation) SetProfileImageURL(s string) {
	m.profile_image_url = &s
}

// ProfileImageURL returns the value of the "profile_image_url" field in the mutation.
func (m *UserMutation) ProfileImageURL() (r string, exists bool) {
	v := m.profile_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImageURL returns the old "profile_image_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfileImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImageURL: %w", err)
	}
	return oldValue.ProfileImageURL, nil
}

// ClearProfileImageURL clears the value of the "profile_image_url" field.
func (m *UserMutation) ClearProfileImageURL() {
	m.profile_image_url = nil
	m.clearedFields[user.FieldProfileImageURL] = struct{}{}
}

// ProfileImageURLCleared returns if the "profile_image_url" field was cleared in this mutation.
func (m *UserMutation) ProfileImageURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfileImageURL]
	return ok
}

// ResetProfileImageURL resets all changes to the "profile_image_url" field.
func (m *UserMutation) ResetProfileImageURL() {
	m.profile_image_url = nil
	delete(m.clearedFields, user.FieldProfileImageURL)
}

// SetPrimaryOrganizationID sets the "primary_organization_id" field.
func (m *UserMutation) SetPrimaryOrganizationID(s string) {
	m.primary_organization_id = &s
}

// PrimaryOrganizationID returns the value of the "primary_organization_id" field in the mutation.
func (m *UserMutation) PrimaryOrganizationID() (r string, exists bool) {
	v := m.primary_organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryOrganizationID returns the old "primary_organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrimaryOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryOrganizationID: %w", err)
	}
	return oldValue.PrimaryOrganizationID, nil
}

// ClearPrimaryOrganizationID clears the value of the "primary_organization_id" field.
func (m *UserMutation) ClearPrimaryOrganizationID() {
	m.primary_organization_id = nil
	m.clearedFields[user.FieldPrimaryOrganizationID] = struct{}{}
}

// PrimaryOrganizationIDCleared returns if the "primary_organization_id" field was cleared in this mutation.
func (m *UserMutation) PrimaryOrganizationIDCleared() bool {
	_, ok := m.clearedFields[user.FieldPrimaryOrganizationID]
	return ok
}

// ResetPrimaryOrganizationID resets all changes to the "primary_organization_id" field.
func (m *UserMutation) ResetPrimaryOrganizationID() {
	m.primary_organization_id = nil
	delete(m.clearedFields, user.FieldPrimaryOrganizationID)
}

// SetLocale sets the "locale" field.
func (m *UserMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *UserMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *UserMutation) ResetLocale() {
	m.locale = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...string) {
	if m.api_keys == nil {
		m.api_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...string) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []string) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []string) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOrganizationIDs(ids ...string) {
	if m.organizations == nil {
		m.organizations = make(map[string]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *UserMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOrganizationsIDs() (ids []string) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *UserMutation) OrganizationsIDs() (ids []string) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *UserMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddMfaMethodIDs adds the "mfa_methods" edge to the MFA entity by ids.
func (m *UserMutation) AddMfaMethodIDs(ids ...string) {
	if m.mfa_methods == nil {
		m.mfa_methods = make(map[string]struct{})
	}
	for i := range ids {
		m.mfa_methods[ids[i]] = struct{}{}
	}
}

// ClearMfaMethods clears the "mfa_methods" edge to the MFA entity.
func (m *UserMutation) ClearMfaMethods() {
	m.clearedmfa_methods = true
}

// MfaMethodsCleared reports if the "mfa_methods" edge to the MFA entity was cleared.
func (m *UserMutation) MfaMethodsCleared() bool {
	return m.clearedmfa_methods
}

// RemoveMfaMethodIDs removes the "mfa_methods" edge to the MFA entity by IDs.
func (m *UserMutation) RemoveMfaMethodIDs(ids ...string) {
	if m.removedmfa_methods == nil {
		m.removedmfa_methods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mfa_methods, ids[i])
		m.removedmfa_methods[ids[i]] = struct{}{}
	}
}

// RemovedMfaMethods returns the removed IDs of the "mfa_methods" edge to the MFA entity.
func (m *UserMutation) RemovedMfaMethodsIDs() (ids []string) {
	for id := range m.removedmfa_methods {
		ids = append(ids, id)
	}
	return
}

// MfaMethodsIDs returns the "mfa_methods" edge IDs in the mutation.
func (m *UserMutation) MfaMethodsIDs() (ids []string) {
	for id := range m.mfa_methods {
		ids = append(ids, id)
	}
	return
}

// ResetMfaMethods resets all changes to the "mfa_methods" edge.
func (m *UserMutation) ResetMfaMethods() {
	m.mfa_methods = nil
	m.clearedmfa_methods = false
	m.removedmfa_methods = nil
}

// AddPasskeyIDs adds the "passkeys" edge to the Passkey entity by ids.
func (m *UserMutation) AddPasskeyIDs(ids ...string) {
	if m.passkeys == nil {
		m.passkeys = make(map[string]struct{})
	}
	for i := range ids {
		m.passkeys[ids[i]] = struct{}{}
	}
}

// ClearPasskeys clears the "passkeys" edge to the Passkey entity.
func (m *UserMutation) ClearPasskeys() {
	m.clearedpasskeys = true
}

// PasskeysCleared reports if the "passkeys" edge to the Passkey entity was cleared.
func (m *UserMutation) PasskeysCleared() bool {
	return m.clearedpasskeys
}

// RemovePasskeyIDs removes the "passkeys" edge to the Passkey entity by IDs.
func (m *UserMutation) RemovePasskeyIDs(ids ...string) {
	if m.removedpasskeys == nil {
		m.removedpasskeys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.passkeys, ids[i])
		m.removedpasskeys[ids[i]] = struct{}{}
	}
}

// RemovedPasskeys returns the removed IDs of the "passkeys" edge to the Passkey entity.
func (m *UserMutation) RemovedPasskeysIDs() (ids []string) {
	for id := range m.removedpasskeys {
		ids = append(ids, id)
	}
	return
}

// PasskeysIDs returns the "passkeys" edge IDs in the mutation.
func (m *UserMutation) PasskeysIDs() (ids []string) {
	for id := range m.passkeys {
		ids = append(ids, id)
	}
	return
}

// ResetPasskeys resets all changes to the "passkeys" edge.
func (m *UserMutation) ResetPasskeys() {
	m.passkeys = nil
	m.clearedpasskeys = false
	m.removedpasskeys = nil
}

// AddOauthTokenIDs adds the "oauth_tokens" edge to the OAuthToken entity by ids.
func (m *UserMutation) AddOauthTokenIDs(ids ...string) {
	if m.oauth_tokens == nil {
		m.oauth_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.oauth_tokens[ids[i]] = struct{}{}
	}
}

// ClearOauthTokens clears the "oauth_tokens" edge to the OAuthToken entity.
func (m *UserMutation) ClearOauthTokens() {
	m.clearedoauth_tokens = true
}

// OauthTokensCleared reports if the "oauth_tokens" edge to the OAuthToken entity was cleared.
func (m *UserMutation) OauthTokensCleared() bool {
	return m.clearedoauth_tokens
}

// RemoveOauthTokenIDs removes the "oauth_tokens" edge to the OAuthToken entity by IDs.
func (m *UserMutation) RemoveOauthTokenIDs(ids ...string) {
	if m.removedoauth_tokens == nil {
		m.removedoauth_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.oauth_tokens, ids[i])
		m.removedoauth_tokens[ids[i]] = struct{}{}
	}
}

// RemovedOauthTokens returns the removed IDs of the "oauth_tokens" edge to the OAuthToken entity.
func (m *UserMutation) RemovedOauthTokensIDs() (ids []string) {
	for id := range m.removedoauth_tokens {
		ids = append(ids, id)
	}
	return
}

// OauthTokensIDs returns the "oauth_tokens" edge IDs in the mutation.
func (m *UserMutation) OauthTokensIDs() (ids []string) {
	for id := range m.oauth_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetOauthTokens resets all changes to the "oauth_tokens" edge.
func (m *UserMutation) ResetOauthTokens() {
	m.oauth_tokens = nil
	m.clearedoauth_tokens = false
	m.removedoauth_tokens = nil
}

// AddOauthAuthorizationIDs adds the "oauth_authorizations" edge to the OAuthAuthorization entity by ids.
func (m *UserMutation) AddOauthAuthorizationIDs(ids ...string) {
	if m.oauth_authorizations == nil {
		m.oauth_authorizations = make(map[string]struct{})
	}
	for i := range ids {
		m.oauth_authorizations[ids[i]] = struct{}{}
	}
}

// ClearOauthAuthorizations clears the "oauth_authorizations" edge to the OAuthAuthorization entity.
func (m *UserMutation) ClearOauthAuthorizations() {
	m.clearedoauth_authorizations = true
}

// OauthAuthorizationsCleared reports if the "oauth_authorizations" edge to the OAuthAuthorization entity was cleared.
func (m *UserMutation) OauthAuthorizationsCleared() bool {
	return m.clearedoauth_authorizations
}

// RemoveOauthAuthorizationIDs removes the "oauth_authorizations" edge to the OAuthAuthorization entity by IDs.
func (m *UserMutation) RemoveOauthAuthorizationIDs(ids ...string) {
	if m.removedoauth_authorizations == nil {
		m.removedoauth_authorizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.oauth_authorizations, ids[i])
		m.removedoauth_authorizations[ids[i]] = struct{}{}
	}
}

// RemovedOauthAuthorizations returns the removed IDs of the "oauth_authorizations" edge to the OAuthAuthorization entity.
func (m *UserMutation) RemovedOauthAuthorizationsIDs() (ids []string) {
	for id := range m.removedoauth_authorizations {
		ids = append(ids, id)
	}
	return
}

// OauthAuthorizationsIDs returns the "oauth_authorizations" edge IDs in the mutation.
func (m *UserMutation) OauthAuthorizationsIDs() (ids []string) {
	for id := range m.oauth_authorizations {
		ids = append(ids, id)
	}
	return
}

// ResetOauthAuthorizations resets all changes to the "oauth_authorizations" edge.
func (m *UserMutation) ResetOauthAuthorizations() {
	m.oauth_authorizations = nil
	m.clearedoauth_authorizations = false
	m.removedoauth_authorizations = nil
}

// AddVerificationIDs adds the "verifications" edge to the Verification entity by ids.
func (m *UserMutation) AddVerificationIDs(ids ...string) {
	if m.verifications == nil {
		m.verifications = make(map[string]struct{})
	}
	for i := range ids {
		m.verifications[ids[i]] = struct{}{}
	}
}

// ClearVerifications clears the "verifications" edge to the Verification entity.
func (m *UserMutation) ClearVerifications() {
	m.clearedverifications = true
}

// VerificationsCleared reports if the "verifications" edge to the Verification entity was cleared.
func (m *UserMutation) VerificationsCleared() bool {
	return m.clearedverifications
}

// RemoveVerificationIDs removes the "verifications" edge to the Verification entity by IDs.
func (m *UserMutation) RemoveVerificationIDs(ids ...string) {
	if m.removedverifications == nil {
		m.removedverifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.verifications, ids[i])
		m.removedverifications[ids[i]] = struct{}{}
	}
}

// RemovedVerifications returns the removed IDs of the "verifications" edge to the Verification entity.
func (m *UserMutation) RemovedVerificationsIDs() (ids []string) {
	for id := range m.removedverifications {
		ids = append(ids, id)
	}
	return
}

// VerificationsIDs returns the "verifications" edge IDs in the mutation.
func (m *UserMutation) VerificationsIDs() (ids []string) {
	for id := range m.verifications {
		ids = append(ids, id)
	}
	return
}

// ResetVerifications resets all changes to the "verifications" edge.
func (m *UserMutation) ResetVerifications() {
	m.verifications = nil
	m.clearedverifications = false
	m.removedverifications = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...string) {
	if m.roles == nil {
		m.roles = make(map[string]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...string) {
	if m.removedroles == nil {
		m.removedroles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []string) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []string) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.last_password_change != nil {
		fields = append(fields, user.FieldLastPasswordChange)
	}
	if m.metadata != nil {
		fields = append(fields, user.FieldMetadata)
	}
	if m.profile_image_url != nil {
		fields = append(fields, user.FieldProfileImageURL)
	}
	if m.primary_organization_id != nil {
		fields = append(fields, user.FieldPrimaryOrganizationID)
	}
	if m.locale != nil {
		fields = append(fields, user.FieldLocale)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldActive:
		return m.Active()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldLastPasswordChange:
		return m.LastPasswordChange()
	case user.FieldMetadata:
		return m.Metadata()
	case user.FieldProfileImageURL:
		return m.ProfileImageURL()
	case user.FieldPrimaryOrganizationID:
		return m.PrimaryOrganizationID()
	case user.FieldLocale:
		return m.Locale()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldLastPasswordChange:
		return m.OldLastPasswordChange(ctx)
	case user.FieldMetadata:
		return m.OldMetadata(ctx)
	case user.FieldProfileImageURL:
		return m.OldProfileImageURL(ctx)
	case user.FieldPrimaryOrganizationID:
		return m.OldPrimaryOrganizationID(ctx)
	case user.FieldLocale:
		return m.OldLocale(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldLastPasswordChange:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPasswordChange(v)
		return nil
	case user.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case user.FieldProfileImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImageURL(v)
		return nil
	case user.FieldPrimaryOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryOrganizationID(v)
		return nil
	case user.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.FieldCleared(user.FieldLastPasswordChange) {
		fields = append(fields, user.FieldLastPasswordChange)
	}
	if m.FieldCleared(user.FieldMetadata) {
		fields = append(fields, user.FieldMetadata)
	}
	if m.FieldCleared(user.FieldProfileImageURL) {
		fields = append(fields, user.FieldProfileImageURL)
	}
	if m.FieldCleared(user.FieldPrimaryOrganizationID) {
		fields = append(fields, user.FieldPrimaryOrganizationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	case user.FieldLastPasswordChange:
		m.ClearLastPasswordChange()
		return nil
	case user.FieldMetadata:
		m.ClearMetadata()
		return nil
	case user.FieldProfileImageURL:
		m.ClearProfileImageURL()
		return nil
	case user.FieldPrimaryOrganizationID:
		m.ClearPrimaryOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldLastPasswordChange:
		m.ResetLastPasswordChange()
		return nil
	case user.FieldMetadata:
		m.ResetMetadata()
		return nil
	case user.FieldProfileImageURL:
		m.ResetProfileImageURL()
		return nil
	case user.FieldPrimaryOrganizationID:
		m.ResetPrimaryOrganizationID()
		return nil
	case user.FieldLocale:
		m.ResetLocale()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.organizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.mfa_methods != nil {
		edges = append(edges, user.EdgeMfaMethods)
	}
	if m.passkeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.oauth_tokens != nil {
		edges = append(edges, user.EdgeOauthTokens)
	}
	if m.oauth_authorizations != nil {
		edges = append(edges, user.EdgeOauthAuthorizations)
	}
	if m.verifications != nil {
		edges = append(edges, user.EdgeVerifications)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaMethods:
		ids := make([]ent.Value, 0, len(m.mfa_methods))
		for id := range m.mfa_methods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.passkeys))
		for id := range m.passkeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthTokens:
		ids := make([]ent.Value, 0, len(m.oauth_tokens))
		for id := range m.oauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthAuthorizations:
		ids := make([]ent.Value, 0, len(m.oauth_authorizations))
		for id := range m.oauth_authorizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVerifications:
		ids := make([]ent.Value, 0, len(m.verifications))
		for id := range m.verifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedorganizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.removedmfa_methods != nil {
		edges = append(edges, user.EdgeMfaMethods)
	}
	if m.removedpasskeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.removedoauth_tokens != nil {
		edges = append(edges, user.EdgeOauthTokens)
	}
	if m.removedoauth_authorizations != nil {
		edges = append(edges, user.EdgeOauthAuthorizations)
	}
	if m.removedverifications != nil {
		edges = append(edges, user.EdgeVerifications)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaMethods:
		ids := make([]ent.Value, 0, len(m.removedmfa_methods))
		for id := range m.removedmfa_methods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.removedpasskeys))
		for id := range m.removedpasskeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthTokens:
		ids := make([]ent.Value, 0, len(m.removedoauth_tokens))
		for id := range m.removedoauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthAuthorizations:
		ids := make([]ent.Value, 0, len(m.removedoauth_authorizations))
		for id := range m.removedoauth_authorizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVerifications:
		ids := make([]ent.Value, 0, len(m.removedverifications))
		for id := range m.removedverifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedorganizations {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.clearedmfa_methods {
		edges = append(edges, user.EdgeMfaMethods)
	}
	if m.clearedpasskeys {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.clearedoauth_tokens {
		edges = append(edges, user.EdgeOauthTokens)
	}
	if m.clearedoauth_authorizations {
		edges = append(edges, user.EdgeOauthAuthorizations)
	}
	if m.clearedverifications {
		edges = append(edges, user.EdgeVerifications)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeOrganizations:
		return m.clearedorganizations
	case user.EdgeMfaMethods:
		return m.clearedmfa_methods
	case user.EdgePasskeys:
		return m.clearedpasskeys
	case user.EdgeOauthTokens:
		return m.clearedoauth_tokens
	case user.EdgeOauthAuthorizations:
		return m.clearedoauth_authorizations
	case user.EdgeVerifications:
		return m.clearedverifications
	case user.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case user.EdgeMfaMethods:
		m.ResetMfaMethods()
		return nil
	case user.EdgePasskeys:
		m.ResetPasskeys()
		return nil
	case user.EdgeOauthTokens:
		m.ResetOauthTokens()
		return nil
	case user.EdgeOauthAuthorizations:
		m.ResetOauthAuthorizations()
		return nil
	case user.EdgeVerifications:
		m.ResetVerifications()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VerificationMutation represents an operation that mutates the Verification nodes in the graph.
type VerificationMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	_type         *string
	token         *string
	email         *string
	phone_number  *string
	redirect_url  *string
	used          *bool
	used_at       *time.Time
	attempts      *int
	addattempts   *int
	expires_at    *time.Time
	ip_address    *string
	user_agent    *string
	attestation   *map[string]interface{}
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Verification, error)
	predicates    []predicate.Verification
}

var _ ent.Mutation = (*VerificationMutation)(nil)

// verificationOption allows management of the mutation configuration using functional options.
type verificationOption func(*VerificationMutation)

// newVerificationMutation creates new mutation for the Verification entity.
func newVerificationMutation(c config, op Op, opts ...verificationOption) *VerificationMutation {
	m := &VerificationMutation{
		config:        c,
		op:            op,
		typ:           TypeVerification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVerificationID sets the ID field of the mutation.
func withVerificationID(id string) verificationOption {
	return func(m *VerificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Verification
		)
		m.oldValue = func(ctx context.Context) (*Verification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Verification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVerification sets the old Verification of the mutation.
func withVerification(node *Verification) verificationOption {
	return func(m *VerificationMutation) {
		m.oldValue = func(context.Context) (*Verification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VerificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VerificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Verification entities.
func (m *VerificationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VerificationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VerificationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Verification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VerificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VerificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VerificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VerificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VerificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VerificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *VerificationMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VerificationMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VerificationMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *VerificationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VerificationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *VerificationMutation) ResetType() {
	m._type = nil
}

// SetToken sets the "token" field.
func (m *VerificationMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *VerificationMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *VerificationMutation) ResetToken() {
	m.token = nil
}

// SetEmail sets the "email" field.
func (m *VerificationMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *VerificationMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *VerificationMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[verification.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *VerificationMutation) EmailCleared() bool {
	_, ok := m.clearedFields[verification.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *VerificationMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, verification.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *VerificationMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *VerificationMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *VerificationMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[verification.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *VerificationMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[verification.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *VerificationMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, verification.FieldPhoneNumber)
}

// SetRedirectURL sets the "redirect_url" field.
func (m *VerificationMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *VerificationMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ClearRedirectURL clears the value of the "redirect_url" field.
func (m *VerificationMutation) ClearRedirectURL() {
	m.redirect_url = nil
	m.clearedFields[verification.FieldRedirectURL] = struct{}{}
}

// RedirectURLCleared returns if the "redirect_url" field was cleared in this mutation.
func (m *VerificationMutation) RedirectURLCleared() bool {
	_, ok := m.clearedFields[verification.FieldRedirectURL]
	return ok
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *VerificationMutation) ResetRedirectURL() {
	m.redirect_url = nil
	delete(m.clearedFields, verification.FieldRedirectURL)
}

// SetUsed sets the "used" field.
func (m *VerificationMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *VerificationMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *VerificationMutation) ResetUsed() {
	m.used = nil
}

// SetUsedAt sets the "used_at" field.
func (m *VerificationMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *VerificationMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *VerificationMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[verification.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *VerificationMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[verification.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *VerificationMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, verification.FieldUsedAt)
}

// SetAttempts sets the "attempts" field.
func (m *VerificationMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *VerificationMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *VerificationMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *VerificationMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *VerificationMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *VerificationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *VerificationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *VerificationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *VerificationMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *VerificationMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *VerificationMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[verification.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *VerificationMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[verification.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *VerificationMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, verification.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *VerificationMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *VerificationMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *VerificationMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[verification.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *VerificationMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[verification.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *VerificationMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, verification.FieldUserAgent)
}

// SetAttestation sets the "attestation" field.
func (m *VerificationMutation) SetAttestation(value map[string]interface{}) {
	m.attestation = &value
}

// Attestation returns the value of the "attestation" field in the mutation.
func (m *VerificationMutation) Attestation() (r map[string]interface{}, exists bool) {
	v := m.attestation
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestation returns the old "attestation" field's value of the Verification entity.
// If the Verification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VerificationMutation) OldAttestation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestation: %w", err)
	}
	return oldValue.Attestation, nil
}

// ClearAttestation clears the value of the "attestation" field.
func (m *VerificationMutation) ClearAttestation() {
	m.attestation = nil
	m.clearedFields[verification.FieldAttestation] = struct{}{}
}

// AttestationCleared returns if the "attestation" field was cleared in this mutation.
func (m *VerificationMutation) AttestationCleared() bool {
	_, ok := m.clearedFields[verification.FieldAttestation]
	return ok
}

// ResetAttestation resets all changes to the "attestation" field.
func (m *VerificationMutation) ResetAttestation() {
	m.attestation = nil
	delete(m.clearedFields, verification.FieldAttestation)
}

// ClearUser clears the "user" edge to the User entity.
func (m *VerificationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[verification.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VerificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VerificationMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VerificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VerificationMutation builder.
func (m *VerificationMutation) Where(ps ...predicate.Verification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VerificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VerificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Verification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VerificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VerificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Verification).
func (m *VerificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VerificationMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, verification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, verification.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, verification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, verification.FieldType)
	}
	if m.token != nil {
		fields = append(fields, verification.FieldToken)
	}
	if m.email != nil {
		fields = append(fields, verification.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, verification.FieldPhoneNumber)
	}
	if m.redirect_url != nil {
		fields = append(fields, verification.FieldRedirectURL)
	}
	if m.used != nil {
		fields = append(fields, verification.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, verification.FieldUsedAt)
	}
	if m.attempts != nil {
		fields = append(fields, verification.FieldAttempts)
	}
	if m.expires_at != nil {
		fields = append(fields, verification.FieldExpiresAt)
	}
	if m.ip_address != nil {
		fields = append(fields, verification.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, verification.FieldUserAgent)
	}
	if m.attestation != nil {
		fields = append(fields, verification.FieldAttestation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VerificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case verification.FieldCreatedAt:
		return m.CreatedAt()
	case verification.FieldUpdatedAt:
		return m.UpdatedAt()
	case verification.FieldUserID:
		return m.UserID()
	case verification.FieldType:
		return m.GetType()
	case verification.FieldToken:
		return m.Token()
	case verification.FieldEmail:
		return m.Email()
	case verification.FieldPhoneNumber:
		return m.PhoneNumber()
	case verification.FieldRedirectURL:
		return m.RedirectURL()
	case verification.FieldUsed:
		return m.Used()
	case verification.FieldUsedAt:
		return m.UsedAt()
	case verification.FieldAttempts:
		return m.Attempts()
	case verification.FieldExpiresAt:
		return m.ExpiresAt()
	case verification.FieldIPAddress:
		return m.IPAddress()
	case verification.FieldUserAgent:
		return m.UserAgent()
	case verification.FieldAttestation:
		return m.Attestation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VerificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case verification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case verification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case verification.FieldUserID:
		return m.OldUserID(ctx)
	case verification.FieldType:
		return m.OldType(ctx)
	case verification.FieldToken:
		return m.OldToken(ctx)
	case verification.FieldEmail:
		return m.OldEmail(ctx)
	case verification.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case verification.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case verification.FieldUsed:
		return m.OldUsed(ctx)
	case verification.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case verification.FieldAttempts:
		return m.OldAttempts(ctx)
	case verification.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case verification.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case verification.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case verification.FieldAttestation:
		return m.OldAttestation(ctx)
	}
	return nil, fmt.Errorf("unknown Verification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VerificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case verification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case verification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case verification.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case verification.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case verification.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case verification.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case verification.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case verification.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case verification.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case verification.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case verification.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case verification.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case verification.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case verification.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case verification.FieldAttestation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestation(v)
		return nil
	}
	return fmt.Errorf("unknown Verification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VerificationMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, verification.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VerificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case verification.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VerificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case verification.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown Verification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VerificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(verification.FieldEmail) {
		fields = append(fields, verification.FieldEmail)
	}
	if m.FieldCleared(verification.FieldPhoneNumber) {
		fields = append(fields, verification.FieldPhoneNumber)
	}
	if m.FieldCleared(verification.FieldRedirectURL) {
		fields = append(fields, verification.FieldRedirectURL)
	}
	if m.FieldCleared(verification.FieldUsedAt) {
		fields = append(fields, verification.FieldUsedAt)
	}
	if m.FieldCleared(verification.FieldIPAddress) {
		fields = append(fields, verification.FieldIPAddress)
	}
	if m.FieldCleared(verification.FieldUserAgent) {
		fields = append(fields, verification.FieldUserAgent)
	}
	if m.FieldCleared(verification.FieldAttestation) {
		fields = append(fields, verification.FieldAttestation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VerificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VerificationMutation) ClearField(name string) error {
	switch name {
	case verification.FieldEmail:
		m.ClearEmail()
		return nil
	case verification.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case verification.FieldRedirectURL:
		m.ClearRedirectURL()
		return nil
	case verification.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case verification.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case verification.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case verification.FieldAttestation:
		m.ClearAttestation()
		return nil
	}
	return fmt.Errorf("unknown Verification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VerificationMutation) ResetField(name string) error {
	switch name {
	case verification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case verification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case verification.FieldUserID:
		m.ResetUserID()
		return nil
	case verification.FieldType:
		m.ResetType()
		return nil
	case verification.FieldToken:
		m.ResetToken()
		return nil
	case verification.FieldEmail:
		m.ResetEmail()
		return nil
	case verification.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case verification.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case verification.FieldUsed:
		m.ResetUsed()
		return nil
	case verification.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case verification.FieldAttempts:
		m.ResetAttempts()
		return nil
	case verification.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case verification.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case verification.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case verification.FieldAttestation:
		m.ResetAttestation()
		return nil
	}
	return fmt.Errorf("unknown Verification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VerificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, verification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VerificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case verification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VerificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VerificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VerificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, verification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VerificationMutation) EdgeCleared(name string) bool {
	switch name {
	case verification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VerificationMutation) ClearEdge(name string) error {
	switch name {
	case verification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Verification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VerificationMutation) ResetEdge(name string) error {
	switch name {
	case verification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Verification edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	url                 *string
	secret              *string
	active              *bool
	event_types         *[]string
	appendevent_types   []string
	version             *string
	retry_count         *int
	addretry_count      *int
	timeout_ms          *int
	addtimeout_ms       *int
	format              *webhook.Format
	metadata            *map[string]interface{}
	clearedFields       map[string]struct{}
	organization        *string
	clearedorganization bool
	events              map[string]struct{}
	removedevents       map[string]struct{}
	clearedevents       bool
	done                bool
	oldValue            func(context.Context) (*Webhook, error)
	predicates          []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id string) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Webhook entities.
func (m *WebhookMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *WebhookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebhookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebhookMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *WebhookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebhookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebhookMutation) ResetURL() {
	m.url = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WebhookMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WebhookMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WebhookMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetSecret sets the "secret" field.
func (m *WebhookMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *WebhookMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *WebhookMutation) ResetSecret() {
	m.secret = nil
}

// SetActive sets the "active" field.
func (m *WebhookMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WebhookMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WebhookMutation) ResetActive() {
	m.active = nil
}

// SetEventTypes sets the "event_types" field.
func (m *WebhookMutation) SetEventTypes(s []string) {
	m.event_types = &s
	m.appendevent_types = nil
}

// EventTypes returns the value of the "event_types" field in the mutation.
func (m *WebhookMutation) EventTypes() (r []string, exists bool) {
	v := m.event_types
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypes returns the old "event_types" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEventTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypes: %w", err)
	}
	return oldValue.EventTypes, nil
}

// AppendEventTypes adds s to the "event_types" field.
func (m *WebhookMutation) AppendEventTypes(s []string) {
	m.appendevent_types = append(m.appendevent_types, s...)
}

// AppendedEventTypes returns the list of values that were appended to the "event_types" field in this mutation.
func (m *WebhookMutation) AppendedEventTypes() ([]string, bool) {
	if len(m.appendevent_types) == 0 {
		return nil, false
	}
	return m.appendevent_types, true
}

// ResetEventTypes resets all changes to the "event_types" field.
func (m *WebhookMutation) ResetEventTypes() {
	m.event_types = nil
	m.appendevent_types = nil
}

// SetVersion sets the "version" field.
func (m *WebhookMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *WebhookMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *WebhookMutation) ResetVersion() {
	m.version = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *WebhookMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *WebhookMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *WebhookMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *WebhookMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *WebhookMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetTimeoutMs sets the "timeout_ms" field.
func (m *WebhookMutation) SetTimeoutMs(i int) {
	m.timeout_ms = &i
	m.addtimeout_ms = nil
}

// TimeoutMs returns the value of the "timeout_ms" field in the mutation.
func (m *WebhookMutation) TimeoutMs() (r int, exists bool) {
	v := m.timeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeoutMs returns the old "timeout_ms" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldTimeoutMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeoutMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeoutMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeoutMs: %w", err)
	}
	return oldValue.TimeoutMs, nil
}

// AddTimeoutMs adds i to the "timeout_ms" field.
func (m *WebhookMutation) AddTimeoutMs(i int) {
	if m.addtimeout_ms != nil {
		*m.addtimeout_ms += i
	} else {
		m.addtimeout_ms = &i
	}
}

// AddedTimeoutMs returns the value that was added to the "timeout_ms" field in this mutation.
func (m *WebhookMutation) AddedTimeoutMs() (r int, exists bool) {
	v := m.addtimeout_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeoutMs resets all changes to the "timeout_ms" field.
func (m *WebhookMutation) ResetTimeoutMs() {
	m.timeout_ms = nil
	m.addtimeout_ms = nil
}

// SetFormat sets the "format" field.
func (m *WebhookMutation) SetFormat(w webhook.Format) {
	m.format = &w
}

// Format returns the value of the "format" field in the mutation.
func (m *WebhookMutation) Format() (r webhook.Format, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFormat(ctx context.Context) (v webhook.Format, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *WebhookMutation) ResetFormat() {
	m.format = nil
}

// SetMetadata sets the "metadata" field.
func (m *WebhookMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *WebhookMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *WebhookMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[webhook.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *WebhookMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[webhook.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *WebhookMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, webhook.FieldMetadata)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WebhookMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[webhook.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WebhookMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WebhookMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WebhookMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddEventIDs adds the "events" edge to the WebhookEvent entity by ids.
func (m *WebhookMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the WebhookEvent entity.
func (m *WebhookMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the WebhookEvent entity was cleared.
func (m *WebhookMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the WebhookEvent entity by IDs.
func (m *WebhookMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the WebhookEvent entity.
func (m *WebhookMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *WebhookMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *WebhookMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, webhook.FieldName)
	}
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.organization != nil {
		fields = append(fields, webhook.FieldOrganizationID)
	}
	if m.secret != nil {
		fields = append(fields, webhook.FieldSecret)
	}
	if m.active != nil {
		fields = append(fields, webhook.FieldActive)
	}
	if m.event_types != nil {
		fields = append(fields, webhook.FieldEventTypes)
	}
	if m.version != nil {
		fields = append(fields, webhook.FieldVersion)
	}
	if m.retry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.timeout_ms != nil {
		fields = append(fields, webhook.FieldTimeoutMs)
	}
	if m.format != nil {
		fields = append(fields, webhook.FieldFormat)
	}
	if m.metadata != nil {
		fields = append(fields, webhook.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	case webhook.FieldName:
		return m.Name()
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldOrganizationID:
		return m.OrganizationID()
	case webhook.FieldSecret:
		return m.Secret()
	case webhook.FieldActive:
		return m.Active()
	case webhook.FieldEventTypes:
		return m.EventTypes()
	case webhook.FieldVersion:
		return m.Version()
	case webhook.FieldRetryCount:
		return m.RetryCount()
	case webhook.FieldTimeoutMs:
		return m.TimeoutMs()
	case webhook.FieldFormat:
		return m.Format()
	case webhook.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webhook.FieldName:
		return m.OldName(ctx)
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case webhook.FieldSecret:
		return m.OldSecret(ctx)
	case webhook.FieldActive:
		return m.OldActive(ctx)
	case webhook.FieldEventTypes:
		return m.OldEventTypes(ctx)
	case webhook.FieldVersion:
		return m.OldVersion(ctx)
	case webhook.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case webhook.FieldTimeoutMs:
		return m.OldTimeoutMs(ctx)
	case webhook.FieldFormat:
		return m.OldFormat(ctx)
	case webhook.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case webhook.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case webhook.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case webhook.FieldEventTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypes(v)
		return nil
	case webhook.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case webhook.FieldTimeoutMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeoutMs(v)
		return nil
	case webhook.FieldFormat:
		v, ok := value.(webhook.Format)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case webhook.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.addtimeout_ms != nil {
		fields = append(fields, webhook.FieldTimeoutMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldRetryCount:
		return m.AddedRetryCount()
	case webhook.FieldTimeoutMs:
		return m.AddedTimeoutMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case webhook.FieldTimeoutMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeoutMs(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldMetadata) {
		fields = append(fields, webhook.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webhook.FieldName:
		m.ResetName()
		return nil
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case webhook.FieldSecret:
		m.ResetSecret()
		return nil
	case webhook.FieldActive:
		m.ResetActive()
		return nil
	case webhook.FieldEventTypes:
		m.ResetEventTypes()
		return nil
	case webhook.FieldVersion:
		m.ResetVersion()
		return nil
	case webhook.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case webhook.FieldTimeoutMs:
		m.ResetTimeoutMs()
		return nil
	case webhook.FieldFormat:
		m.ResetFormat()
		return nil
	case webhook.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, webhook.EdgeOrganization)
	}
	if m.events != nil {
		edges = append(edges, webhook.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case webhook.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, webhook.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, webhook.EdgeOrganization)
	}
	if m.clearedevents {
		edges = append(edges, webhook.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeOrganization:
		return m.clearedorganization
	case webhook.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	case webhook.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case webhook.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}

// WebhookEventMutation represents an operation that mutates the WebhookEvent nodes in the graph.
type WebhookEventMutation struct {
	config
	op             Op
	typ            string
	id             *string
	event_type     *string
	headers        *map[string]string
	payload        *map[string]interface{}
	delivered      *bool
	delivered_at   *time.Time
	attempts       *int
	addattempts    *int
	next_retry     *time.Time
	status_code    *int
	addstatus_code *int
	response_body  *string
	error          *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	webhook        *string
	clearedwebhook bool
	done           bool
	oldValue       func(context.Context) (*WebhookEvent, error)
	predicates     []predicate.WebhookEvent
}

var _ ent.Mutation = (*WebhookEventMutation)(nil)

// webhookeventOption allows management of the mutation configuration using functional options.
type webhookeventOption func(*WebhookEventMutation)

// newWebhookEventMutation creates new mutation for the WebhookEvent entity.
func newWebhookEventMutation(c config, op Op, opts ...webhookeventOption) *WebhookEventMutation {
	m := &WebhookEventMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhookEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookEventID sets the ID field of the mutation.
func withWebhookEventID(id string) webhookeventOption {
	return func(m *WebhookEventMutation) {
		var (
			err   error
			once  sync.Once
			value *WebhookEvent
		)
		m.oldValue = func(ctx context.Context) (*WebhookEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebhookEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhookEvent sets the old WebhookEvent of the mutation.
func withWebhookEvent(node *WebhookEvent) webhookeventOption {
	return func(m *WebhookEventMutation) {
		m.oldValue = func(context.Context) (*WebhookEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebhookEvent entities.
func (m *WebhookEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebhookEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWebhookID sets the "webhook_id" field.
func (m *WebhookEventMutation) SetWebhookID(s string) {
	m.webhook = &s
}

// WebhookID returns the value of the "webhook_id" field in the mutation.
func (m *WebhookEventMutation) WebhookID() (r string, exists bool) {
	v := m.webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookID returns the old "webhook_id" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldWebhookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebhookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebhookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookID: %w", err)
	}
	return oldValue.WebhookID, nil
}

// ResetWebhookID resets all changes to the "webhook_id" field.
func (m *WebhookEventMutation) ResetWebhookID() {
	m.webhook = nil
}

// SetEventType sets the "event_type" field.
func (m *WebhookEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *WebhookEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *WebhookEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetHeaders sets the "headers" field.
func (m *WebhookEventMutation) SetHeaders(value map[string]string) {
	m.headers = &value
}

// Headers returns the value of the "headers" field in the mutation.
func (m *WebhookEventMutation) Headers() (r map[string]string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldHeaders(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ClearHeaders clears the value of the "headers" field.
func (m *WebhookEventMutation) ClearHeaders() {
	m.headers = nil
	m.clearedFields[webhookevent.FieldHeaders] = struct{}{}
}

// HeadersCleared returns if the "headers" field was cleared in this mutation.
func (m *WebhookEventMutation) HeadersCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldHeaders]
	return ok
}

// ResetHeaders resets all changes to the "headers" field.
func (m *WebhookEventMutation) ResetHeaders() {
	m.headers = nil
	delete(m.clearedFields, webhookevent.FieldHeaders)
}

// SetPayload sets the "payload" field.
func (m *WebhookEventMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *WebhookEventMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *WebhookEventMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[webhookevent.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *WebhookEventMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *WebhookEventMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, webhookevent.FieldPayload)
}

// SetDelivered sets the "delivered" field.
func (m *WebhookEventMutation) SetDelivered(b bool) {
	m.delivered = &b
}

// Delivered returns the value of the "delivered" field in the mutation.
func (m *WebhookEventMutation) Delivered() (r bool, exists bool) {
	v := m.delivered
	if v == nil {
		return
	}
	return *v, true
}

// OldDelivered returns the old "delivered" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldDelivered(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelivered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelivered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelivered: %w", err)
	}
	return oldValue.Delivered, nil
}

// ResetDelivered resets all changes to the "delivered" field.
func (m *WebhookEventMutation) ResetDelivered() {
	m.delivered = nil
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *WebhookEventMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *WebhookEventMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldDeliveredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *WebhookEventMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[webhookevent.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *WebhookEventMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *WebhookEventMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, webhookevent.FieldDeliveredAt)
}

// SetAttempts sets the "attempts" field.
func (m *WebhookEventMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *WebhookEventMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *WebhookEventMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *WebhookEventMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *WebhookEventMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetNextRetry sets the "next_retry" field.
func (m *WebhookEventMutation) SetNextRetry(t time.Time) {
	m.next_retry = &t
}

// NextRetry returns the value of the "next_retry" field in the mutation.
func (m *WebhookEventMutation) NextRetry() (r time.Time, exists bool) {
	v := m.next_retry
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRetry returns the old "next_retry" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldNextRetry(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRetry: %w", err)
	}
	return oldValue.NextRetry, nil
}

// ClearNextRetry clears the value of the "next_retry" field.
func (m *WebhookEventMutation) ClearNextRetry() {
	m.next_retry = nil
	m.clearedFields[webhookevent.FieldNextRetry] = struct{}{}
}

// NextRetryCleared returns if the "next_retry" field was cleared in this mutation.
func (m *WebhookEventMutation) NextRetryCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldNextRetry]
	return ok
}

// ResetNextRetry resets all changes to the "next_retry" field.
func (m *WebhookEventMutation) ResetNextRetry() {
	m.next_retry = nil
	delete(m.clearedFields, webhookevent.FieldNextRetry)
}

// SetStatusCode sets the "status_code" field.
func (m *WebhookEventMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *WebhookEventMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldStatusCode(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *WebhookEventMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *WebhookEventMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *WebhookEventMutation) ClearStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	m.clearedFields[webhookevent.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *WebhookEventMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *WebhookEventMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
	delete(m.clearedFields, webhookevent.FieldStatusCode)
}

// SetResponseBody sets the "response_body" field.
func (m *WebhookEventMutation) SetResponseBody(s string) {
	m.response_body = &s
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *WebhookEventMutation) ResponseBody() (r string, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldResponseBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *WebhookEventMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[webhookevent.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *WebhookEventMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *WebhookEventMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, webhookevent.FieldResponseBody)
}

// SetError sets the "error" field.
func (m *WebhookEventMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *WebhookEventMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *WebhookEventMutation) ClearError() {
	m.error = nil
	m.clearedFields[webhookevent.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *WebhookEventMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[webhookevent.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *WebhookEventMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, webhookevent.FieldError)
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WebhookEvent entity.
// If the WebhookEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWebhook clears the "webhook" edge to the Webhook entity.
func (m *WebhookEventMutation) ClearWebhook() {
	m.clearedwebhook = true
	m.clearedFields[webhookevent.FieldWebhookID] = struct{}{}
}

// WebhookCleared reports if the "webhook" edge to the Webhook entity was cleared.
func (m *WebhookEventMutation) WebhookCleared() bool {
	return m.clearedwebhook
}

// WebhookIDs returns the "webhook" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WebhookID instead. It exists only for internal usage by the builders.
func (m *WebhookEventMutation) WebhookIDs() (ids []string) {
	if id := m.webhook; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWebhook resets all changes to the "webhook" edge.
func (m *WebhookEventMutation) ResetWebhook() {
	m.webhook = nil
	m.clearedwebhook = false
}

// Where appends a list predicates to the WebhookEventMutation builder.
func (m *WebhookEventMutation) Where(ps ...predicate.WebhookEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebhookEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebhookEvent).
func (m *WebhookEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookEventMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.webhook != nil {
		fields = append(fields, webhookevent.FieldWebhookID)
	}
	if m.event_type != nil {
		fields = append(fields, webhookevent.FieldEventType)
	}
	if m.headers != nil {
		fields = append(fields, webhookevent.FieldHeaders)
	}
	if m.payload != nil {
		fields = append(fields, webhookevent.FieldPayload)
	}
	if m.delivered != nil {
		fields = append(fields, webhookevent.FieldDelivered)
	}
	if m.delivered_at != nil {
		fields = append(fields, webhookevent.FieldDeliveredAt)
	}
	if m.attempts != nil {
		fields = append(fields, webhookevent.FieldAttempts)
	}
	if m.next_retry != nil {
		fields = append(fields, webhookevent.FieldNextRetry)
	}
	if m.status_code != nil {
		fields = append(fields, webhookevent.FieldStatusCode)
	}
	if m.response_body != nil {
		fields = append(fields, webhookevent.FieldResponseBody)
	}
	if m.error != nil {
		fields = append(fields, webhookevent.FieldError)
	}
	if m.created_at != nil {
		fields = append(fields, webhookevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhookevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhookevent.FieldWebhookID:
		return m.WebhookID()
	case webhookevent.FieldEventType:
		return m.EventType()
	case webhookevent.FieldHeaders:
		return m.Headers()
	case webhookevent.FieldPayload:
		return m.Payload()
	case webhookevent.FieldDelivered:
		return m.Delivered()
	case webhookevent.FieldDeliveredAt:
		return m.DeliveredAt()
	case webhookevent.FieldAttempts:
		return m.Attempts()
	case webhookevent.FieldNextRetry:
		return m.NextRetry()
	case webhookevent.FieldStatusCode:
		return m.StatusCode()
	case webhookevent.FieldResponseBody:
		return m.ResponseBody()
	case webhookevent.FieldError:
		return m.Error()
	case webhookevent.FieldCreatedAt:
		return m.CreatedAt()
	case webhookevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhookevent.FieldWebhookID:
		return m.OldWebhookID(ctx)
	case webhookevent.FieldEventType:
		return m.OldEventType(ctx)
	case webhookevent.FieldHeaders:
		return m.OldHeaders(ctx)
	case webhookevent.FieldPayload:
		return m.OldPayload(ctx)
	case webhookevent.FieldDelivered:
		return m.OldDelivered(ctx)
	case webhookevent.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	case webhookevent.FieldAttempts:
		return m.OldAttempts(ctx)
	case webhookevent.FieldNextRetry:
		return m.OldNextRetry(ctx)
	case webhookevent.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case webhookevent.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case webhookevent.FieldError:
		return m.OldError(ctx)
	case webhookevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhookevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WebhookEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhookevent.FieldWebhookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookID(v)
		return nil
	case webhookevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case webhookevent.FieldHeaders:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case webhookevent.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case webhookevent.FieldDelivered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelivered(v)
		return nil
	case webhookevent.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	case webhookevent.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case webhookevent.FieldNextRetry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRetry(v)
		return nil
	case webhookevent.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case webhookevent.FieldResponseBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case webhookevent.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case webhookevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhookevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookEventMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, webhookevent.FieldAttempts)
	}
	if m.addstatus_code != nil {
		fields = append(fields, webhookevent.FieldStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhookevent.FieldAttempts:
		return m.AddedAttempts()
	case webhookevent.FieldStatusCode:
		return m.AddedStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhookevent.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	case webhookevent.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhookevent.FieldHeaders) {
		fields = append(fields, webhookevent.FieldHeaders)
	}
	if m.FieldCleared(webhookevent.FieldPayload) {
		fields = append(fields, webhookevent.FieldPayload)
	}
	if m.FieldCleared(webhookevent.FieldDeliveredAt) {
		fields = append(fields, webhookevent.FieldDeliveredAt)
	}
	if m.FieldCleared(webhookevent.FieldNextRetry) {
		fields = append(fields, webhookevent.FieldNextRetry)
	}
	if m.FieldCleared(webhookevent.FieldStatusCode) {
		fields = append(fields, webhookevent.FieldStatusCode)
	}
	if m.FieldCleared(webhookevent.FieldResponseBody) {
		fields = append(fields, webhookevent.FieldResponseBody)
	}
	if m.FieldCleared(webhookevent.FieldError) {
		fields = append(fields, webhookevent.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookEventMutation) ClearField(name string) error {
	switch name {
	case webhookevent.FieldHeaders:
		m.ClearHeaders()
		return nil
	case webhookevent.FieldPayload:
		m.ClearPayload()
		return nil
	case webhookevent.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	case webhookevent.FieldNextRetry:
		m.ClearNextRetry()
		return nil
	case webhookevent.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case webhookevent.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case webhookevent.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookEventMutation) ResetField(name string) error {
	switch name {
	case webhookevent.FieldWebhookID:
		m.ResetWebhookID()
		return nil
	case webhookevent.FieldEventType:
		m.ResetEventType()
		return nil
	case webhookevent.FieldHeaders:
		m.ResetHeaders()
		return nil
	case webhookevent.FieldPayload:
		m.ResetPayload()
		return nil
	case webhookevent.FieldDelivered:
		m.ResetDelivered()
		return nil
	case webhookevent.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	case webhookevent.FieldAttempts:
		m.ResetAttempts()
		return nil
	case webhookevent.FieldNextRetry:
		m.ResetNextRetry()
		return nil
	case webhookevent.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case webhookevent.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case webhookevent.FieldError:
		m.ResetError()
		return nil
	case webhookevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhookevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.webhook != nil {
		edges = append(edges, webhookevent.EdgeWebhook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhookevent.EdgeWebhook:
		if id := m.webhook; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwebhook {
		edges = append(edges, webhookevent.EdgeWebhook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookEventMutation) EdgeCleared(name string) bool {
	switch name {
	case webhookevent.EdgeWebhook:
		return m.clearedwebhook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookEventMutation) ClearEdge(name string) error {
	switch name {
	case webhookevent.EdgeWebhook:
		m.ClearWebhook()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookEventMutation) ResetEdge(name string) error {
	switch name {
	case webhookevent.EdgeWebhook:
		m.ResetWebhook()
		return nil
	}
	return fmt.Errorf("unknown WebhookEvent edge %s", name)
}
