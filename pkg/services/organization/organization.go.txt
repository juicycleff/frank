package organization

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"time"

	"github.com/juicycleff/frank/ent"
	"github.com/juicycleff/frank/ent/membership"
	"github.com/juicycleff/frank/ent/organization"
	"github.com/juicycleff/frank/ent/role"
	"github.com/juicycleff/frank/ent/user"
	"github.com/juicycleff/frank/pkg/errors"
	"github.com/juicycleff/frank/pkg/logging"
	"github.com/rs/xid"
)

// Service handles organization and membership operations
type Service struct {
	db     *ent.Client
	logger logging.Logger
}

// NewService creates a new organization service
func NewService(db *ent.Client, logger logging.Logger) *Service {
	return &Service{
		db:     db,
		logger: logger,
	}
}

// Organization Management

// CreateOrganizationInput represents input for creating an organization
type CreateOrganizationInput struct {
	Name     string                 `json:"name" validate:"required,min=2,max=100"`
	Slug     string                 `json:"slug" validate:"required,min=2,max=50,alphanum"`
	Domain   *string                `json:"domain,omitempty" validate:"omitempty,fqdn"`
	LogoURL  *string                `json:"logo_url,omitempty" validate:"omitempty,url"`
	Plan     string                 `json:"plan" validate:"omitempty,oneof=free pro enterprise"`
	OwnerID  xid.ID                 `json:"owner_id" validate:"required"`
	OrgType  organization.OrgType   `json:"org_type" validate:"omitempty,oneof=platform customer"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// CreateOrganization creates a new organization with the owner as the first member
func (s *Service) CreateOrganization(ctx context.Context, input CreateOrganizationInput) (*ent.Organization, error) {
	// Validate owner exists and is active
	ownerExists, err := s.db.User.Query().
		Where(user.ID(input.OwnerID), user.Active(true)).
		Exist(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to validate owner")
	}
	if !ownerExists {
		return nil, errors.New(errors.CodeNotFound, "owner user not found or inactive")
	}

	// Check if slug is unique
	slugExists, err := s.db.Organization.Query().
		Where(organization.Slug(input.Slug)).
		Exist(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to check slug uniqueness")
	}
	if slugExists {
		return nil, errors.New(errors.CodeConflict, "organization slug already exists")
	}

	// Start transaction
	tx, err := s.db.Tx(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to start transaction")
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Create organization
	org, err := tx.Organization.Create().
		SetName(input.Name).
		SetSlug(input.Slug).
		SetNillableDomain(input.Domain).
		SetNillableLogoURL(input.LogoURL).
		SetPlan(input.Plan).
		SetOwnerID(input.OwnerID).
		SetOrgType(input.OrgType).
		SetMetadata(input.Metadata).
		SetActive(true).
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to create organization")
	}

	// Create default organization owner role if it doesn't exist
	ownerRole, err := tx.Role.Query().
		Where(
			role.Name("owner"),
			role.RoleTypeEQ(role.RoleTypeOrganization),
			role.OrganizationID(org.ID),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			// Create owner role
			ownerRole, err = tx.Role.Create().
				SetName("owner").
				SetDisplayName("Organization Owner").
				SetDescription("Full access to organization").
				SetRoleType(role.RoleTypeOrganization).
				SetOrganizationID(org.ID).
				SetIsDefault(false).
				SetPriority(100).
				SetApplicableUserTypes([]string{"external"}).
				SetSystem(true).
				Save(ctx)
			if err != nil {
				return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to create owner role")
			}
		} else {
			return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to query owner role")
		}
	}

	// Add owner as first member with owner role
	_, err = tx.Membership.Create().
		SetUserID(input.OwnerID).
		SetOrganizationID(org.ID).
		SetRoleID(ownerRole.ID).
		SetStatus(membership.StatusActive).
		SetJoinedAt(time.Now()).
		SetIsPrimaryContact(true).
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to create owner membership")
	}

	// Update organization member count
	err = tx.Organization.UpdateOne(org).
		SetCurrentExternalUsers(1).
		Exec(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to update member count")
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to commit transaction")
	}

	s.logger.Info("Organization created",
		logging.String("org_id", org.ID.String()),
		logging.String("name", org.Name),
		logging.String("owner_id", input.OwnerID.String()),
	)

	return org, nil
}

// UpdateOrganizationInput represents input for updating an organization
type UpdateOrganizationInput struct {
	Name     *string                `json:"name,omitempty" validate:"omitempty,min=2,max=100"`
	Domain   *string                `json:"domain,omitempty" validate:"omitempty,fqdn"`
	LogoURL  *string                `json:"logo_url,omitempty" validate:"omitempty,url"`
	Plan     *string                `json:"plan,omitempty" validate:"omitempty,oneof=free pro enterprise"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// UpdateOrganization updates an organization
func (s *Service) UpdateOrganization(ctx context.Context, orgID xid.ID, input UpdateOrganizationInput) (*ent.Organization, error) {
	update := s.db.Organization.UpdateOneID(orgID)

	if input.Name != nil {
		update.SetName(*input.Name)
	}
	if input.Domain != nil {
		update.SetNillableDomain(input.Domain)
	}
	if input.LogoURL != nil {
		update.SetNillableLogoURL(input.LogoURL)
	}
	if input.Plan != nil {
		update.SetPlan(*input.Plan)
	}
	if input.Metadata != nil {
		update.SetMetadata(input.Metadata)
	}

	org, err := update.Save(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "organization not found")
		}
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to update organization")
	}

	return org, nil
}

// GetOrganization retrieves an organization by ID
func (s *Service) GetOrganization(ctx context.Context, orgID xid.ID) (*ent.Organization, error) {
	org, err := s.db.Organization.Query().
		Where(organization.ID(orgID), organization.Active(true)).
		WithMemberships(func(q *ent.MembershipQuery) {
			q.WithUser().WithRole().Where(membership.StatusEQ(membership.StatusActive))
		}).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "organization not found")
		}
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to get organization")
	}

	return org, nil
}

// Membership Management

// InviteMemberInput represents input for inviting a member
type InviteMemberInput struct {
	OrganizationID xid.ID         `json:"organization_id" validate:"required"`
	Email          string         `json:"email" validate:"required,email"`
	RoleID         xid.ID         `json:"role_id" validate:"required"`
	InvitedBy      xid.ID         `json:"invited_by" validate:"required"`
	ExpiresIn      *time.Duration `json:"expires_in,omitempty"`
	Message        *string        `json:"message,omitempty"`
}

// InviteMember invites a user to join an organization
func (s *Service) InviteMember(ctx context.Context, input InviteMemberInput) (*ent.Membership, error) {
	// Check organization limits
	org, err := s.GetOrganization(ctx, input.OrganizationID)
	if err != nil {
		return nil, err
	}

	if org.CurrentExternalUsers >= org.ExternalUserLimit {
		return nil, errors.New(errors.CodeConflict, "organization has reached its member limit")
	}

	// Check if role exists and is valid for this organization
	roleExists, err := s.db.Role.Query().
		Where(
			role.ID(input.RoleID),
			role.OrganizationID(input.OrganizationID),
			role.Active(true),
		).
		Exist(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to validate role")
	}
	if !roleExists {
		return nil, errors.New(errors.CodeNotFound, "role not found or not valid for organization")
	}

	// Check if user exists, create if not
	var targetUser *ent.User
	targetUser, err = s.db.User.Query().
		Where(
			user.Email(input.Email),
			user.UserTypeEQ(user.UserTypeExternal),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			// Create user as external user
			targetUser, err = s.db.User.Create().
				SetEmail(input.Email).
				SetUserType(user.UserTypeExternal).
				SetActive(true).
				Save(ctx)
			if err != nil {
				return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to create user")
			}
		} else {
			return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to query user")
		}
	}

	// Check if membership already exists
	existingMembership, err := s.db.Membership.Query().
		Where(
			membership.UserID(targetUser.ID),
			membership.OrganizationID(input.OrganizationID),
		).
		First(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to check existing membership")
	}

	if existingMembership != nil {
		if existingMembership.Status == membership.StatusActive {
			return nil, errors.New(errors.CodeConflict, "user is already a member of this organization")
		}
		// Update existing pending membership
		token, err := generateInvitationToken()
		if err != nil {
			return nil, errors.Wrap(err, errors.CodeCryptoError, "failed to generate invitation token")
		}

		expiresAt := time.Now().Add(7 * 24 * time.Hour) // 7 days default
		if input.ExpiresIn != nil {
			expiresAt = time.Now().Add(*input.ExpiresIn)
		}

		return existingMembership.Update().
			SetRoleID(input.RoleID).
			SetStatus(membership.StatusPending).
			SetInvitedBy(input.InvitedBy).
			SetInvitedAt(time.Now()).
			SetInvitationToken(token).
			SetExpiresAt(expiresAt).
			Save(ctx)
	}

	// Create new membership invitation
	token, err := generateInvitationToken()
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeCryptoError, "failed to generate invitation token")
	}

	expiresAt := time.Now().Add(7 * 24 * time.Hour) // 7 days default
	if input.ExpiresIn != nil {
		expiresAt = time.Now().Add(*input.ExpiresIn)
	}

	membership, err := s.db.Membership.Create().
		SetUserID(targetUser.ID).
		SetOrganizationID(input.OrganizationID).
		SetRoleID(input.RoleID).
		SetStatus(membership.StatusPending).
		SetInvitedBy(input.InvitedBy).
		SetInvitedAt(time.Now()).
		SetInvitationToken(token).
		SetExpiresAt(expiresAt).
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to create membership")
	}

	s.logger.Info("Member invited",
		logging.String("org_id", input.OrganizationID.String()),
		logging.String("email", input.Email),
		logging.String("invited_by", input.InvitedBy.String()),
	)

	return membership, nil
}

// AcceptInvitationInput represents input for accepting an invitation
type AcceptInvitationInput struct {
	Token  string `json:"token" validate:"required"`
	UserID xid.ID `json:"user_id" validate:"required"`
}

// AcceptInvitation accepts a membership invitation
func (s *Service) AcceptInvitation(ctx context.Context, input AcceptInvitationInput) (*ent.Membership, error) {
	// Find the invitation
	member, err := s.db.Membership.Query().
		Where(
			membership.InvitationToken(input.Token),
			membership.StatusEQ(membership.StatusPending),
			membership.ExpiresAtGT(time.Now()),
		).
		WithUser().
		WithOrganization().
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "invitation not found or expired")
		}
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to find invitation")
	}

	// Verify the user is the intended recipient
	if member.Edges.User.ID != input.UserID {
		return nil, errors.New(errors.CodeForbidden, "invitation is not for this user")
	}

	// Check organization limits
	org := member.Edges.Organization
	if org.CurrentExternalUsers >= org.ExternalUserLimit {
		return nil, errors.New(errors.CodeConflict, "organization has reached its member limit")
	}

	// Start transaction
	tx, err := s.db.Tx(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to start transaction")
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Accept the invitation
	member, err = tx.Membership.UpdateOne(member).
		SetStatus(membership.StatusActive).
		SetJoinedAt(time.Now()).
		ClearInvitationToken().
		ClearExpiresAt().
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to accept invitation")
	}

	// Update organization member count
	err = tx.Organization.UpdateOneID(org.ID).
		SetCurrentExternalUsers(org.CurrentExternalUsers + 1).
		Exec(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to update member count")
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to commit transaction")
	}

	s.logger.Info("Invitation accepted",
		logging.String("org_id", org.ID.String()),
		logging.String("user_id", input.UserID.String()),
	)

	return member, nil
}

// RemoveMember removes a member from an organization
func (s *Service) RemoveMember(ctx context.Context, orgID, userID xid.ID) error {
	// Get the membership
	member, err := s.db.Membership.Query().
		Where(
			membership.OrganizationID(orgID),
			membership.UserID(userID),
		).
		WithOrganization().
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeNotFound, "membership not found")
		}
		return errors.Wrap(err, errors.CodeDatabaseError, "failed to find membership")
	}

	// Check if user is the owner
	if !member.Edges.Organization.OwnerID.IsNil() && member.Edges.Organization.OwnerID == userID {
		return errors.New(errors.CodeForbidden, "cannot remove organization owner")
	}

	// Start transaction
	tx, err := s.db.Tx(ctx)
	if err != nil {
		return errors.Wrap(err, errors.CodeDatabaseError, "failed to start transaction")
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Remove membership
	err = tx.Membership.DeleteOne(member).Exec(ctx)
	if err != nil {
		return errors.Wrap(err, errors.CodeDatabaseError, "failed to remove membership")
	}

	// Update organization member count if membership was active
	if member.Status == membership.StatusActive {
		org := member.Edges.Organization
		err = tx.Organization.UpdateOneID(orgID).
			SetCurrentExternalUsers(org.CurrentExternalUsers - 1).
			Exec(ctx)
		if err != nil {
			return errors.Wrap(err, errors.CodeDatabaseError, "failed to update member count")
		}
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return errors.Wrap(err, errors.CodeDatabaseError, "failed to commit transaction")
	}

	s.logger.Info("Member removed",
		logging.String("org_id", orgID.String()),
		logging.String("user_id", userID.String()),
	)

	return nil
}

// UpdateMemberRole updates a member's role in an organization
func (s *Service) UpdateMemberRole(ctx context.Context, orgID, userID, roleID xid.ID) (*ent.Membership, error) {
	// Validate role exists for this organization
	roleExists, err := s.db.Role.Query().
		Where(
			role.ID(roleID),
			role.OrganizationID(orgID),
			role.Active(true),
		).
		Exist(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to validate role")
	}
	if !roleExists {
		return nil, errors.New(errors.CodeNotFound, "role not found for organization")
	}

	membershipQuery := s.db.Membership.Query().
		Where(
			membership.OrganizationID(orgID),
			membership.UserID(userID),
			membership.StatusEQ(membership.StatusActive),
		)

	// Update membership
	_, err = s.db.Membership.Update().
		Where(
			membership.OrganizationID(orgID),
			membership.UserID(userID),
			membership.StatusEQ(membership.StatusActive),
		).
		SetRoleID(roleID).
		Save(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "active membership not found")
		}
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to update member role")
	}

	return membershipQuery.First(ctx)
}

// ListMembers lists all members of an organization
func (s *Service) ListMembers(ctx context.Context, orgID xid.ID, status *membership.Status) ([]*ent.Membership, error) {
	query := s.db.Membership.Query().
		Where(membership.OrganizationID(orgID)).
		WithUser().
		WithRole()

	if status != nil {
		query.Where(membership.StatusEQ(*status))
	}

	members, err := query.All(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to list members")
	}

	return members, nil
}

// GetMembershipByUser gets a user's membership in an organization
func (s *Service) GetMembershipByUser(ctx context.Context, orgID, userID xid.ID) (*ent.Membership, error) {
	membership, err := s.db.Membership.Query().
		Where(
			membership.OrganizationID(orgID),
			membership.UserID(userID),
		).
		WithUser().
		WithRole().
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "membership not found")
		}
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to get membership")
	}

	return membership, nil
}

// Helper Functions

// generateInvitationToken generates a secure invitation token
func generateInvitationToken() (string, error) {
	bytes := make([]byte, 32)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(bytes), nil
}

// GetOrganizationStats returns organization statistics
func (s *Service) GetOrganizationStats(ctx context.Context, orgID xid.ID) (*OrganizationStats, error) {
	org, err := s.GetOrganization(ctx, orgID)
	if err != nil {
		return nil, err
	}

	activeMembers, err := s.db.Membership.Query().
		Where(
			membership.OrganizationID(orgID),
			membership.StatusEQ(membership.StatusActive),
		).
		Count(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to count active members")
	}

	pendingInvitations, err := s.db.Membership.Query().
		Where(
			membership.OrganizationID(orgID),
			membership.StatusEQ(membership.StatusPending),
		).
		Count(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeDatabaseError, "failed to count pending invitations")
	}

	return &OrganizationStats{
		Organization:       org,
		ActiveMembers:      activeMembers,
		PendingInvitations: pendingInvitations,
		MemberLimit:        org.ExternalUserLimit,
		UsagePercentage:    float64(activeMembers) / float64(org.ExternalUserLimit) * 100,
	}, nil
}

// OrganizationStats represents organization statistics
type OrganizationStats struct {
	Organization       *ent.Organization `json:"organization"`
	ActiveMembers      int               `json:"active_members"`
	PendingInvitations int               `json:"pending_invitations"`
	MemberLimit        int               `json:"member_limit"`
	UsagePercentage    float64           `json:"usage_percentage"`
}
