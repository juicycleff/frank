package di

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/juicycleff/frank/config"
	"github.com/juicycleff/frank/ent"
	"github.com/juicycleff/frank/internal/authz"
	"github.com/juicycleff/frank/internal/middleware"
	"github.com/juicycleff/frank/internal/rbac"
	"github.com/juicycleff/frank/internal/services/audit"
	"github.com/juicycleff/frank/internal/services/auth"
	"github.com/juicycleff/frank/internal/services/mfa"
	"github.com/juicycleff/frank/internal/services/oauth"
	"github.com/juicycleff/frank/internal/services/organization"
	"github.com/juicycleff/frank/internal/services/passkey"
	"github.com/juicycleff/frank/internal/services/user"
	"github.com/juicycleff/frank/internal/services/webhook"
	"github.com/juicycleff/frank/internal/sms"
	"github.com/juicycleff/frank/pkg/data"
	"github.com/juicycleff/frank/pkg/email"

	// Import other services as they are implemented
	// "github.com/juicycleff/frank/internal/services/rbac"
	// "github.com/juicycleff/frank/internal/services/mfa"
	// "github.com/juicycleff/frank/internal/services/oauth"
	// "github.com/juicycleff/frank/internal/services/passkey"
	// "github.com/juicycleff/frank/internal/services/webhook"
	// "github.com/juicycleff/frank/internal/services/audit"
	// "github.com/juicycleff/frank/internal/services/notification"
	"github.com/juicycleff/frank/pkg/logging"
	"github.com/rs/xid"

	_ "github.com/lib/pq" // PostgreSQL driver
)

// Container interface defines the dependency injection container
type Container interface {
	// Core Infrastructure
	Config() *config.Config
	Logger() logging.Logger
	DB() *ent.Client
	Data() *data.Clients

	// Authentication & Authorization
	Auth() *auth.Service
	AuthZ() *authz.Service
	AuthMiddleware() *middleware.AuthMiddleware

	// Core Services
	UserService() *user.Service
	OrganizationService() *organization.Service

	// RBAC Services (to be implemented)
	// RBACService() *rbac.Service

	// Authentication Services (to be implemented)
	// MFAService() *mfa.Service
	// OAuthService() *oauth.Service
	// PasskeyService() *passkey.Service

	// Notification Services (to be implemented)
	// EmailService() *email.Service
	// SMSService() *sms.Service
	// WebhookService() *webhook.Service

	// Audit & Compliance (to be implemented)
	// AuditService() *audit.Service

	// Utility methods
	Cleanup() error
	HealthCheck(ctx context.Context) error
}

// container implements the Container interface
type container struct {
	cfg    *config.Config
	logger logging.Logger
	db     *ent.Client
	client *data.Clients

	// Services
	authService         *auth.Service
	authzService        *authz.Service
	userService         *user.Service
	organizationService *organization.Service

	// Middleware
	authMiddleware *middleware.AuthMiddleware

	// Future services
	// rbacService       *rbac.Service
	// mfaService        *mfa.Service
	// oauthService      *oauth.Service
	// passkeyService    *passkey.Service
	// emailService      *email.Service
	// smsService        *sms.Service
	// webhookService    *webhook.Service
	// auditService      *audit.Service
}

// NewContainer creates a new dependency injection container
func NewContainer(cfg *config.Config) (Container, error) {
	// Initialize logger
	logger := logging.NewLogger(&logging.LoggerConfig{
		Level:       cfg.Logging.Level,
		Environment: cfg.Environment,
	})

	// Initialize database
	db, err := initDatabase(cfg, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize database: %w", err)
	}

	// Create container instance
	c := &container{
		cfg:    cfg,
		logger: logger,
		db:     db,
	}

	// Initialize services
	if err := c.initServices(); err != nil {
		return nil, fmt.Errorf("failed to initialize services: %w", err)
	}

	logger.Info("Dependency injection container initialized successfully")
	return c, nil
}

// initDatabase initializes the database connection
func initDatabase(cfg *config.Config, logger logging.Logger) (*ent.Client, error) {
	// Build database URL if not provided
	var dbURL string
	if cfg.Database.DSN != "" {
		dbURL = cfg.Database.DSN
	} else {
		dbURL = buildPostgresURL(cfg.Database)
	}

	// Open database connection
	sqlDB, err := sql.Open(cfg.Database.Driver, dbURL)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Configure connection pool
	sqlDB.SetMaxOpenConns(cfg.Database.MaxOpenConns)
	sqlDB.SetMaxIdleConns(cfg.Database.MaxIdleConns)
	sqlDB.SetConnMaxLifetime(cfg.Database.ConnMaxLife)

	// Test connection
	if err := sqlDB.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	// Create Ent client
	client := ent.NewClient(ent.Driver(ent.NewDriver(cfg.Database.Driver, sqlDB)))

	// Auto-migrate if enabled
	if cfg.Database.AutoMigrate {
		if err := client.Schema.Create(context.Background()); err != nil {
			logger.Warn("Failed to run auto-migration", logging.Error(err))
		} else {
			logger.Info("Database schema migration completed")
		}
	}

	logger.Info("Database connection established",
		logging.String("driver", cfg.Database.Driver),
		logging.String("host", cfg.Database.Host),
		logging.Int("port", cfg.Database.Port),
		logging.String("database", cfg.Database.Database),
	)

	return client, nil
}

// buildPostgresURL builds PostgreSQL connection URL
func buildPostgresURL(cfg config.DatabaseConfig) string {
	return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=%s",
		cfg.User,
		cfg.Password,
		cfg.Host,
		cfg.Port,
		cfg.Database,
		cfg.SSLMode,
	)
}

// initServices initializes all services with their dependencies
func (c *container) initServices() error {
	// Initialize core services first
	c.userService = user.NewService(c.db, c.logger)
	c.organizationService = organization.NewService(c.db, c.logger)

	// Initialize authentication services
	c.authService = auth.NewService(c.db, c.cfg, c.logger)
	c.authzService = authz.NewService(c.db, c.logger)

	// Initialize middleware
	c.authMiddleware = middleware.NewAuthMiddleware(c.authService, c.cfg, c.logger)

	// TODO: Initialize other services as they are implemented
	// c.rbacService = rbac.NewService(c.db, c.logger)
	// c.mfaService = mfa.NewService(c.db, c.cfg, c.logger)
	// c.oauthService = oauth.NewService(c.db, c.cfg, c.logger)
	// c.passkeyService = passkey.NewService(c.db, c.cfg, c.logger)
	// c.emailService = email.NewService(c.cfg, c.logger)
	// c.smsService = sms.NewService(c.cfg, c.logger)
	// c.webhookService = webhook.NewService(c.db, c.logger)
	// c.auditService = audit.NewService(c.db, c.logger)

	return nil
}

// Core Infrastructure

func (c *container) Config() *config.Config {
	return c.cfg
}

func (c *container) Logger() logging.Logger {
	return c.logger
}

func (c *container) DB() *ent.Client {
	return c.db
}

func (c *container) Auth() *auth.Service {
	return c.authService
}

func (c *container) AuthZ() *authz.Service {
	return c.authzService
}

func (c *container) AuthMiddleware() *middleware.AuthMiddleware {
	return c.authMiddleware
}

// Core Services

func (c *container) UserService() *user.Service {
	return c.userService
}

func (c *container) OrganizationService() *organization.Service {
	return c.organizationService
}

func (c *container) RBACService() *rbac.Service {
	return c.rbacService
}

func (c *container) MFAService() *mfa.Service {
	return c.mfaService
}

func (c *container) OAuthService() *oauth.Service {
	return c.oauthService
}

func (c *container) PasskeyService() *passkey.Service {
	return c.passkeyService
}

func (c *container) EmailService() *email.Service {
	return c.emailService
}

func (c *container) SMSService() *sms.Service {
	return c.smsService
}

func (c *container) WebhookService() *webhook.Service {
	return c.webhookService
}

func (c *container) AuditService() *audit.Service {
	return c.auditService
}

// Utility Methods

// Cleanup closes all resources
func (c *container) Cleanup() error {
	c.logger.Info("Cleaning up resources...")

	// Close database connection
	if c.db != nil {
		if err := c.db.Close(); err != nil {
			c.logger.Error("Failed to close database connection", logging.Error(err))
			return err
		}
	}

	// Sync logger
	if err := c.logger.Sync(); err != nil {
		// Ignore sync errors on cleanup
		c.logger.Warn("Failed to sync logger", logging.Error(err))
	}

	c.logger.Info("Resource cleanup completed")
	return nil
}

// HealthCheck performs health checks on all services
func (c *container) HealthCheck(ctx context.Context) error {
	// Check database connectivity
	if err := c.client.PingDB(); err != nil {
		return fmt.Errorf("database health check failed: %w", err)
	}

	// TODO: Add health checks for other services
	// Check authentication service
	// Check external integrations (email, SMS, etc.)

	return nil
}

// GetUserIDFromContext extracts user ID from context (convenience method)
func (c *container) GetUserIDFromContext(ctx context.Context) (xid.ID, error) {
	return middleware.GetUserIDFromContext(ctx)
}

// GetUserFromContext extracts user from context (convenience method)
func (c *container) GetUserFromContext(ctx context.Context) (*ent.User, error) {
	return middleware.GetUserFromContext(ctx)
}

// GetOrganizationIDFromContext extracts organization ID from context (convenience method)
func (c *container) GetOrganizationIDFromContext(ctx context.Context) (xid.ID, error) {
	return middleware.GetOrganizationIDFromContext(ctx)
}

// ContainerBuilder provides a fluent interface for building containers
type ContainerBuilder struct {
	cfg     *config.Config
	options []ContainerOption
}

// ContainerOption represents a configuration option for the container
type ContainerOption func(*container) error

// NewContainerBuilder creates a new container builder
func NewContainerBuilder(cfg *config.Config) *ContainerBuilder {
	return &ContainerBuilder{cfg: cfg}
}

// WithOption adds a configuration option
func (b *ContainerBuilder) WithOption(option ContainerOption) *ContainerBuilder {
	b.options = append(b.options, option)
	return b
}

// Build creates the container with applied options
func (b *ContainerBuilder) Build() (Container, error) {
	containers, err := NewContainer(b.cfg)
	if err != nil {
		return nil, err
	}

	// Apply options
	c := containers.(*container)
	for _, option := range b.options {
		if err := option(c); err != nil {
			return nil, fmt.Errorf("failed to apply container option: %w", err)
		}
	}

	return containers, nil
}

// Container Options

// WithCustomLogger sets a custom logger
func WithCustomLogger(logger logging.Logger) ContainerOption {
	return func(c *container) error {
		c.logger = logger
		return nil
	}
}

// WithCustomDatabase sets a custom database client
func WithCustomDatabase(db *ent.Client) ContainerOption {
	return func(c *container) error {
		c.db = db
		return nil
	}
}

// WithDataClient sets a custom database client
func WithDataClient(cli *data.Clients) ContainerOption {
	return func(c *container) error {
		c.client = cli
		c.db = cli.DB
		return nil
	}
}
