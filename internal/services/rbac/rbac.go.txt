package rbac

import (
	"context"
	"time"

	"github.com/juicycleff/frank/ent"
	"github.com/juicycleff/frank/ent/permission"
	"github.com/juicycleff/frank/ent/role"
	"github.com/juicycleff/frank/ent/user"
	"github.com/juicycleff/frank/ent/userpermission"
	"github.com/juicycleff/frank/ent/userrole"
	"github.com/juicycleff/frank/internal/model"
	"github.com/juicycleff/frank/pkg/errors"
	"github.com/juicycleff/frank/pkg/logging"
	"github.com/rs/xid"
)

// Service handles RBAC operations
type Service struct {
	db     *ent.Client
	logger logging.Logger
}

// NewService creates a new RBAC service
func NewService(db *ent.Client, logger logging.Logger) *Service {
	return &Service{
		db:     db,
		logger: logger,
	}
}

// Role Management

// CreateRoleInput represents input for creating a role
type CreateRoleInput struct {
	Name                string   `json:"name" validate:"required,min=2,max=50"`
	DisplayName         *string  `json:"display_name,omitempty" validate:"omitempty,min=2,max=100"`
	Description         *string  `json:"description,omitempty" validate:"omitempty,max=500"`
	RoleType            string   `json:"role_type" validate:"required,oneof=system organization application"`
	OrganizationID      *xid.ID  `json:"organization_id,omitempty"`
	ApplicationID       *xid.ID  `json:"application_id,omitempty"`
	IsDefault           bool     `json:"is_default"`
	Priority            int      `json:"priority" validate:"min=0,max=1000"`
	Color               *string  `json:"color,omitempty" validate:"omitempty,hexcolor"`
	ApplicableUserTypes []string `json:"applicable_user_types" validate:"required,dive,oneof=internal external end_user"`
	CreatedBy           *xid.ID  `json:"created_by,omitempty"`
	ParentID            *xid.ID  `json:"parent_id,omitempty"`
}

// UpdateRoleInput represents input for updating a role
type UpdateRoleInput struct {
	DisplayName         *string  `json:"display_name,omitempty" validate:"omitempty,min=2,max=100"`
	Description         *string  `json:"description,omitempty" validate:"omitempty,max=500"`
	Priority            *int     `json:"priority,omitempty" validate:"omitempty,min=0,max=1000"`
	Color               *string  `json:"color,omitempty" validate:"omitempty,hexcolor"`
	ApplicableUserTypes []string `json:"applicable_user_types,omitempty" validate:"omitempty,dive,oneof=internal external end_user"`
	Active              *bool    `json:"active,omitempty"`
	ParentID            *xid.ID  `json:"parent_id,omitempty"`
}

// ListRolesParams represents parameters for listing roles
type ListRolesParams struct {
	model.PaginationParams
	OrgID     model.OptionalParam[xid.ID] `query:"org_id"`
	RoleType  *string                     `query:"role_type" validate:"omitempty,oneof=system organization application"`
	UserType  *string                     `query:"user_type" validate:"omitempty,oneof=internal external end_user"`
	IsDefault *bool                       `query:"is_default"`
	Active    *bool                       `query:"active"`
	System    *bool                       `query:"system"`
	Search    *string                     `query:"search"`
}

// CreateRole creates a new role
func (s *Service) CreateRole(ctx context.Context, input CreateRoleInput) (*Role, error) {
	// Validate role type and context
	roleType, err := s.parseRoleType(input.RoleType)
	if err != nil {
		return nil, err
	}

	if err := s.validateRoleContext(roleType, input.OrganizationID, input.ApplicationID); err != nil {
		return nil, err
	}

	// Check name uniqueness within context
	if err := s.validateRoleNameUniqueness(ctx, input.Name, roleType, input.OrganizationID, input.ApplicationID, nil); err != nil {
		return nil, err
	}

	// Validate parent role if specified
	if input.ParentID != nil {
		if err := s.validateParentRole(ctx, *input.ParentID, roleType, input.OrganizationID); err != nil {
			return nil, err
		}
	}

	// Create role
	roleCreate := s.db.Role.Create().
		SetName(input.Name).
		SetNillableDisplayName(input.DisplayName).
		SetNillableDescription(input.Description).
		SetRoleType(roleType).
		SetNillableOrganizationID(input.OrganizationID).
		SetNillableApplicationID(input.ApplicationID).
		SetIsDefault(input.IsDefault).
		SetPriority(input.Priority).
		SetNillableColor(input.Color).
		SetApplicableUserTypes(input.ApplicableUserTypes).
		SetActive(true).
		SetNillableParentID(input.ParentID)

	if input.CreatedBy != nil {
		roleCreate.SetCreatedBy(input.CreatedBy.String())
	}

	newRole, err := roleCreate.Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create role")
	}

	s.logger.Info("Role created",
		logging.String("role_id", newRole.ID.String()),
		logging.String("name", newRole.Name),
		logging.String("role_type", string(newRole.RoleType)),
	)

	return &Role{Role: newRole}, nil
}

// UpdateRole updates an existing role
func (s *Service) UpdateRole(ctx context.Context, roleID xid.ID, input UpdateRoleInput) (*Role, error) {
	// Get existing role
	existingRole, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "role not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get role")
	}

	// Check if role is system role (cannot be modified)
	if existingRole.System {
		return nil, errors.New(errors.CodeForbidden, "cannot modify system role")
	}

	// Validate parent role if specified
	if input.ParentID != nil && *input.ParentID != existingRole.ID {
		if err := s.validateParentRole(ctx, *input.ParentID, existingRole.RoleType, &existingRole.OrganizationID); err != nil {
			return nil, err
		}

		// Check for circular reference
		if err := s.checkCircularRoleReference(ctx, roleID, *input.ParentID); err != nil {
			return nil, err
		}
	}

	// Update role
	update := s.db.Role.UpdateOneID(roleID)

	if input.DisplayName != nil {
		update.SetNillableDisplayName(input.DisplayName)
	}
	if input.Description != nil {
		update.SetNillableDescription(input.Description)
	}
	if input.Priority != nil {
		update.SetPriority(*input.Priority)
	}
	if input.Color != nil {
		update.SetNillableColor(input.Color)
	}
	if input.ApplicableUserTypes != nil {
		update.SetApplicableUserTypes(input.ApplicableUserTypes)
	}
	if input.Active != nil {
		update.SetActive(*input.Active)
	}
	if input.ParentID != nil {
		update.SetNillableParentID(input.ParentID)
	}

	updatedRole, err := update.Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to update role")
	}

	return &Role{Role: updatedRole}, nil
}

// GetRole retrieves a role by ID
func (s *Service) GetRole(ctx context.Context, roleID xid.ID) (*ent.Role, error) {
	role, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		WithPermissions().
		WithUserAssignments(func(q *ent.UserRoleQuery) {
			q.WithUser()
		}).
		WithParent().
		WithChildren().
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "role not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get role")
	}

	return role, nil
}

// ListRoles lists roles with filtering and pagination
func (s *Service) ListRoles(ctx context.Context, params ListRolesParams) (*model.PaginatedOutput[*ent.Role], error) {
	query := s.db.Role.Query()

	// Apply filters
	if params.OrgID.IsSet {
		orgID := params.OrgID.Value
		query.Where(role.OrganizationID(orgID))
	}

	if params.RoleType != nil {
		roleType, err := s.parseRoleType(*params.RoleType)
		if err != nil {
			return nil, err
		}
		query.Where(role.RoleTypeEQ(roleType))
	}

	if params.IsDefault != nil {
		query.Where(role.IsDefault(*params.IsDefault))
	}

	if params.Active != nil {
		query.Where(role.Active(*params.Active))
	}

	if params.System != nil {
		query.Where(role.System(*params.System))
	}

	if params.Search != nil && *params.Search != "" {
		// searchTerm := "%" + strings.ToLower(*params.Search) + "%"
		query.Where(
			role.Or(
				role.NameContainsFold(*params.Search),
				role.DisplayNameContainsFold(*params.Search),
				role.DescriptionContainsFold(*params.Search),
			),
		)
	}

	// Apply pagination
	return model.WithPaginationAndOptions[*ent.Role, *ent.RoleQuery](
		ctx, query, params.PaginationParams,
	)
}

// DeleteRole soft deletes a role
func (s *Service) DeleteRole(ctx context.Context, roleID xid.ID) error {
	// Get role to check if it's a system role
	existingRole, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeNotFound, "role not found")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get role")
	}

	if existingRole.System {
		return errors.New(errors.CodeForbidden, "cannot delete system role")
	}

	// Check if role is in use
	usageCount, err := s.db.UserRole.Query().
		Where(userrole.RoleID(roleID)).
		Count(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check role usage")
	}

	if usageCount > 0 {
		return errors.New(errors.CodeConflict, "cannot delete role that is assigned to users")
	}

	// Soft delete by setting active to false
	err = s.db.Role.UpdateOneID(roleID).
		SetActive(false).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to delete role")
	}

	s.logger.Info("Role deleted", logging.String("role_id", roleID.String()))
	return nil
}

// Permission Management

// CreatePermissionInput represents input for creating a permission
type CreatePermissionInput struct {
	Name                string   `json:"name" validate:"required,min=2,max=100"`
	DisplayName         *string  `json:"display_name,omitempty" validate:"omitempty,min=2,max=100"`
	Description         string   `json:"description" validate:"required,max=500"`
	Resource            string   `json:"resource" validate:"required,min=2,max=50"`
	Action              string   `json:"action" validate:"required,min=2,max=50"`
	Category            string   `json:"category" validate:"required,oneof=platform organization application resource"`
	ApplicableUserTypes []string `json:"applicable_user_types" validate:"required,dive,oneof=internal external end_user"`
	ApplicableContexts  []string `json:"applicable_contexts" validate:"required,dive,oneof=system organization application"`
	Conditions          *string  `json:"conditions,omitempty"`
	Dangerous           bool     `json:"dangerous"`
	RiskLevel           int      `json:"risk_level" validate:"min=1,max=5"`
	PermissionGroup     *string  `json:"permission_group,omitempty"`
	CreatedBy           *xid.ID  `json:"created_by,omitempty"`
}

// UpdatePermissionInput represents input for updating a permission
type UpdatePermissionInput struct {
	DisplayName         *string  `json:"display_name,omitempty" validate:"omitempty,min=2,max=100"`
	Description         *string  `json:"description,omitempty" validate:"omitempty,max=500"`
	ApplicableUserTypes []string `json:"applicable_user_types,omitempty" validate:"omitempty,dive,oneof=internal external end_user"`
	ApplicableContexts  []string `json:"applicable_contexts,omitempty" validate:"omitempty,dive,oneof=system organization application"`
	Conditions          *string  `json:"conditions,omitempty"`
	RiskLevel           *int     `json:"risk_level,omitempty" validate:"omitempty,min=1,max=5"`
	PermissionGroup     *string  `json:"permission_group,omitempty"`
	Active              *bool    `json:"active,omitempty"`
}

// ListPermissionsParams represents parameters for listing permissions
type ListPermissionsParams struct {
	model.PaginationParams
	Category  *string `query:"category" validate:"omitempty,oneof=platform organization application resource"`
	Resource  *string `query:"resource"`
	Action    *string `query:"action"`
	UserType  *string `query:"user_type" validate:"omitempty,oneof=internal external end_user"`
	Context   *string `query:"context" validate:"omitempty,oneof=system organization application"`
	Dangerous *bool   `query:"dangerous"`
	System    *bool   `query:"system"`
	Active    *bool   `query:"active"`
	RiskLevel *int    `query:"risk_level" validate:"omitempty,min=1,max=5"`
	Search    *string `query:"search"`
}

// CreatePermission creates a new permission
func (s *Service) CreatePermission(ctx context.Context, input CreatePermissionInput) (*Permission, error) {
	// Validate category
	category, err := s.parsePermissionCategory(input.Category)
	if err != nil {
		return nil, err
	}

	// Check name uniqueness
	exists, err := s.db.Permission.Query().
		Where(permission.Name(input.Name)).
		Exist(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to check permission name uniqueness")
	}
	if exists {
		return nil, errors.New(errors.CodeConflict, "permission name already exists")
	}

	// Check resource-action uniqueness
	exists, err = s.db.Permission.Query().
		Where(
			permission.Resource(input.Resource),
			permission.Action(input.Action),
		).
		Exist(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to check resource-action uniqueness")
	}
	if exists {
		return nil, errors.New(errors.CodeConflict, "permission for this resource-action combination already exists")
	}

	// Create permission
	permCreate := s.db.Permission.Create().
		SetName(input.Name).
		SetNillableDisplayName(input.DisplayName).
		SetDescription(input.Description).
		SetResource(input.Resource).
		SetAction(input.Action).
		SetCategory(category).
		SetApplicableUserTypes(input.ApplicableUserTypes).
		SetApplicableContexts(input.ApplicableContexts).
		SetNillableConditions(input.Conditions).
		SetDangerous(input.Dangerous).
		SetRiskLevel(input.RiskLevel).
		SetNillablePermissionGroup(input.PermissionGroup).
		SetActive(true)

	if input.CreatedBy != nil {
		permCreate.SetCreatedBy(input.CreatedBy.String())
	}

	newPermission, err := permCreate.Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create permission")
	}

	s.logger.Info("Permission created",
		logging.String("permission_id", newPermission.ID.String()),
		logging.String("name", newPermission.Name),
		logging.String("resource", newPermission.Resource),
		logging.String("action", newPermission.Action),
	)

	return &Permission{Permission: newPermission}, nil
}

// UpdatePermission updates an existing permission
func (s *Service) UpdatePermission(ctx context.Context, permissionID xid.ID, input UpdatePermissionInput) (*Permission, error) {
	// Get existing permission
	existingPermission, err := s.db.Permission.Query().
		Where(permission.ID(permissionID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "permission not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get permission")
	}

	// Check if permission is system permission (cannot be modified)
	if existingPermission.System {
		return nil, errors.New(errors.CodeForbidden, "cannot modify system permission")
	}

	// Update permission
	update := s.db.Permission.UpdateOneID(permissionID)

	if input.DisplayName != nil {
		update.SetNillableDisplayName(input.DisplayName)
	}
	if input.Description != nil {
		update.SetDescription(*input.Description)
	}
	if input.ApplicableUserTypes != nil {
		update.SetApplicableUserTypes(input.ApplicableUserTypes)
	}
	if input.ApplicableContexts != nil {
		update.SetApplicableContexts(input.ApplicableContexts)
	}
	if input.Conditions != nil {
		update.SetNillableConditions(input.Conditions)
	}
	if input.RiskLevel != nil {
		update.SetRiskLevel(*input.RiskLevel)
	}
	if input.PermissionGroup != nil {
		update.SetNillablePermissionGroup(input.PermissionGroup)
	}
	if input.Active != nil {
		update.SetActive(*input.Active)
	}

	updatedPermission, err := update.Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to update permission")
	}

	return &Permission{Permission: updatedPermission}, nil
}

// GetPermission retrieves a permission by ID
func (s *Service) GetPermission(ctx context.Context, permissionID xid.ID) (*Permission, error) {
	perm, err := s.db.Permission.Query().
		Where(permission.ID(permissionID)).
		WithRoles().
		WithUserAssignments(func(q *ent.UserPermissionQuery) {
			q.WithUser()
		}).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "permission not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get permission")
	}

	return &Permission{Permission: perm}, nil
}

// ListPermissions lists permissions with filtering and pagination
func (s *Service) ListPermissions(ctx context.Context, params ListPermissionsParams) (*model.PaginatedOutput[*ent.Permission], error) {
	query := s.db.Permission.Query()

	// Apply filters
	if params.Category != nil {
		category, err := s.parsePermissionCategory(*params.Category)
		if err != nil {
			return nil, err
		}
		query.Where(permission.CategoryEQ(category))
	}

	if params.Resource != nil {
		query.Where(permission.Resource(*params.Resource))
	}

	if params.Action != nil {
		query.Where(permission.Action(*params.Action))
	}

	if params.Dangerous != nil {
		query.Where(permission.Dangerous(*params.Dangerous))
	}

	if params.System != nil {
		query.Where(permission.System(*params.System))
	}

	if params.Active != nil {
		query.Where(permission.Active(*params.Active))
	}

	if params.RiskLevel != nil {
		query.Where(permission.RiskLevel(*params.RiskLevel))
	}

	if params.Search != nil && *params.Search != "" {
		query.Where(
			permission.Or(
				permission.NameContainsFold(*params.Search),
				permission.DisplayNameContainsFold(*params.Search),
				permission.DescriptionContainsFold(*params.Search),
				permission.ResourceContainsFold(*params.Search),
				permission.ActionContainsFold(*params.Search),
			),
		)
	}

	// Apply pagination
	return model.WithPaginationAndOptions[*Permission, *ent.PermissionQuery](
		ctx, query, params.PaginationParams,
	)
}

// DeletePermission soft deletes a permission
func (s *Service) DeletePermission(ctx context.Context, permissionID xid.ID) error {
	// Get permission to check if it's a system permission
	existingPermission, err := s.db.Permission.Query().
		Where(permission.ID(permissionID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeNotFound, "permission not found")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get permission")
	}

	if existingPermission.System {
		return errors.New(errors.CodeForbidden, "cannot delete system permission")
	}

	// Check if permission is in use
	roleUsageCount, err := s.db.Role.Query().
		Where(role.HasPermissionsWith(permission.ID(permissionID))).
		Count(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check permission role usage")
	}

	userUsageCount, err := s.db.UserPermission.Query().
		Where(userpermission.PermissionID(permissionID)).
		Count(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check permission user usage")
	}

	if roleUsageCount > 0 || userUsageCount > 0 {
		return errors.New(errors.CodeConflict, "cannot delete permission that is assigned to roles or users")
	}

	// Soft delete by setting active to false
	err = s.db.Permission.UpdateOneID(permissionID).
		SetActive(false).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to delete permission")
	}

	s.logger.Info("Permission deleted", logging.String("permission_id", permissionID.String()))
	return nil
}

// Role-Permission Management

// AddPermissionToRole adds a permission to a role
func (s *Service) AddPermissionToRole(ctx context.Context, roleID, permissionID xid.ID) error {
	// Verify role exists
	roleExists, err := s.db.Role.Query().
		Where(role.ID(roleID), role.Active(true)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check role existence")
	}
	if !roleExists {
		return errors.New(errors.CodeNotFound, "role not found")
	}

	// Verify permission exists
	permissionExists, err := s.db.Permission.Query().
		Where(permission.ID(permissionID), permission.Active(true)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check permission existence")
	}
	if !permissionExists {
		return errors.New(errors.CodeNotFound, "permission not found")
	}

	// Check if permission is already assigned to role
	hasPermission, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		QueryPermissions().
		Where(permission.ID(permissionID)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check existing permission assignment")
	}
	if hasPermission {
		return errors.New(errors.CodeConflict, "permission already assigned to role")
	}

	// Add permission to role
	err = s.db.Role.UpdateOneID(roleID).
		AddPermissionIDs(permissionID).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to add permission to role")
	}

	s.logger.Info("Permission added to role",
		logging.String("role_id", roleID.String()),
		logging.String("permission_id", permissionID.String()),
	)

	return nil
}

// RemovePermissionFromRole removes a permission from a role
func (s *Service) RemovePermissionFromRole(ctx context.Context, roleID, permissionID xid.ID) error {
	// Verify role exists
	roleExists, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check role existence")
	}
	if !roleExists {
		return errors.New(errors.CodeNotFound, "role not found")
	}

	// Check if permission is assigned to role
	hasPermission, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		QueryPermissions().
		Where(permission.ID(permissionID)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check permission assignment")
	}
	if !hasPermission {
		return errors.New(errors.CodeNotFound, "permission not assigned to role")
	}

	// Remove permission from role
	err = s.db.Role.UpdateOneID(roleID).
		RemovePermissionIDs(permissionID).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to remove permission from role")
	}

	s.logger.Info("Permission removed from role",
		logging.String("role_id", roleID.String()),
		logging.String("permission_id", permissionID.String()),
	)

	return nil
}

// ListRolePermissions lists all permissions for a role
func (s *Service) ListRolePermissions(ctx context.Context, roleID xid.ID) ([]*Permission, error) {
	permissions, err := s.db.Role.Query().
		Where(role.ID(roleID)).
		QueryPermissions().
		Where(permission.Active(true)).
		All(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to list role permissions")
	}

	var result []*Permission
	for _, perm := range permissions {
		result = append(result, &Permission{Permission: perm})
	}

	return result, nil
}

// User Role/Permission Assignment

// AssignRoleToUserInput represents input for assigning a role to a user
type AssignRoleToUserInput struct {
	UserID      xid.ID                 `json:"user_id" validate:"required"`
	RoleID      xid.ID                 `json:"role_id" validate:"required"`
	ContextType string                 `json:"context_type" validate:"required,oneof=system organization application"`
	ContextID   *xid.ID                `json:"context_id,omitempty"`
	ExpiresAt   *time.Time             `json:"expires_at,omitempty"`
	Conditions  map[string]interface{} `json:"conditions,omitempty"`
	AssignedBy  *xid.ID                `json:"assigned_by,omitempty"`
}

// AssignRoleToUser assigns a role to a user in a specific context
func (s *Service) AssignRoleToUser(ctx context.Context, input AssignRoleToUserInput) error {
	// Parse context type
	contextType, err := s.parseContextType(input.ContextType)
	if err != nil {
		return err
	}

	// Validate context
	if err := s.validateContext(contextType, input.ContextID); err != nil {
		return err
	}

	// Verify user exists and is active
	userExists, err := s.db.User.Query().
		Where(user.ID(input.UserID), user.Active(true)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check user existence")
	}
	if !userExists {
		return errors.New(errors.CodeNotFound, "user not found or inactive")
	}

	// Verify role exists and is active
	roleExists, err := s.db.Role.Query().
		Where(role.ID(input.RoleID), role.Active(true)).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check role existence")
	}
	if !roleExists {
		return errors.New(errors.CodeNotFound, "role not found or inactive")
	}

	// Check if user already has this role in the same context
	exists, err := s.db.UserRole.Query().
		Where(
			userrole.UserID(input.UserID),
			userrole.RoleID(input.RoleID),
			userrole.ContextTypeEQ(contextType),
			userrole.ContextID(*input.ContextID),
		).
		Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check existing role assignment")
	}
	if exists {
		return errors.New(errors.CodeConflict, "user already has this role in the specified context")
	}

	// Create role assignment
	userRoleCreate := s.db.UserRole.Create().
		SetUserID(input.UserID).
		SetRoleID(input.RoleID).
		SetContextType(contextType).
		SetNillableContextID(input.ContextID).
		SetNillableExpiresAt(input.ExpiresAt).
		SetConditions(input.Conditions).
		SetActive(true)

	if input.AssignedBy != nil {
		userRoleCreate.SetAssignedBy(*input.AssignedBy)
	}

	_, err = userRoleCreate.Save(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to assign role to user")
	}

	s.logger.Info("Role assigned to user",
		logging.String("user_id", input.UserID.String()),
		logging.String("role_id", input.RoleID.String()),
		logging.String("context_type", input.ContextType),
	)

	return nil
}

// Helper Functions

// parseRoleType parses role type string to enum
func (s *Service) parseRoleType(roleTypeStr string) (role.RoleType, error) {
	switch roleTypeStr {
	case "system":
		return role.RoleTypeSystem, nil
	case "organization":
		return role.RoleTypeOrganization, nil
	case "application":
		return role.RoleTypeApplication, nil
	default:
		return "", errors.New(errors.CodeInvalidInput, "invalid role type")
	}
}

// parsePermissionCategory parses permission category string to enum
func (s *Service) parsePermissionCategory(categoryStr string) (permission.Category, error) {
	switch categoryStr {
	case "platform":
		return permission.CategoryPlatform, nil
	case "organization":
		return permission.CategoryOrganization, nil
	case "application":
		return permission.CategoryApplication, nil
	case "resource":
		return permission.CategoryResource, nil
	default:
		return "", errors.New(errors.CodeInvalidInput, "invalid permission category")
	}
}

// parseContextType parses context type string to enum
func (s *Service) parseContextType(contextTypeStr string) (userrole.ContextType, error) {
	switch contextTypeStr {
	case "system":
		return userrole.ContextTypeSystem, nil
	case "organization":
		return userrole.ContextTypeOrganization, nil
	case "application":
		return userrole.ContextTypeApplication, nil
	default:
		return "", errors.New(errors.CodeInvalidInput, "invalid context type")
	}
}

// validateRoleContext validates role context based on role type
func (s *Service) validateRoleContext(roleType role.RoleType, orgID, appID *xid.ID) error {
	switch roleType {
	case role.RoleTypeSystem:
		if orgID != nil || appID != nil {
			return errors.New(errors.CodeInvalidInput, "system roles cannot have organization or application context")
		}
	case role.RoleTypeOrganization:
		if orgID == nil {
			return errors.New(errors.CodeInvalidInput, "organization roles must have organization context")
		}
		if appID != nil {
			return errors.New(errors.CodeInvalidInput, "organization roles cannot have application context")
		}
	case role.RoleTypeApplication:
		if orgID == nil {
			return errors.New(errors.CodeInvalidInput, "application roles must have organization context")
		}
		// appID can be optional for application roles
	}
	return nil
}

// validateContext validates context for user role assignments
func (s *Service) validateContext(contextType userrole.ContextType, contextID *xid.ID) error {
	switch contextType {
	case userrole.ContextTypeSystem:
		if contextID != nil {
			return errors.New(errors.CodeInvalidInput, "system context cannot have context ID")
		}
	case userrole.ContextTypeOrganization, userrole.ContextTypeApplication:
		if contextID == nil {
			return errors.New(errors.CodeInvalidInput, "organization and application contexts must have context ID")
		}
	}
	return nil
}

// validateRoleNameUniqueness validates role name uniqueness within context
func (s *Service) validateRoleNameUniqueness(ctx context.Context, name string, roleType role.RoleType, orgID, appID *xid.ID, excludeID *xid.ID) error {
	query := s.db.Role.Query().
		Where(
			role.Name(name),
			role.RoleTypeEQ(roleType),
		)

	if orgID != nil {
		query.Where(role.OrganizationID(*orgID))
	} else {
		query.Where(role.OrganizationIDIsNil())
	}

	if appID != nil {
		query.Where(role.ApplicationID(*appID))
	} else {
		query.Where(role.ApplicationIDIsNil())
	}

	if excludeID != nil {
		query.Where(role.IDNEQ(*excludeID))
	}

	exists, err := query.Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check role name uniqueness")
	}

	if exists {
		return errors.New(errors.CodeConflict, "role name already exists in this context")
	}

	return nil
}

// validateParentRole validates parent role for hierarchy
func (s *Service) validateParentRole(ctx context.Context, parentID xid.ID, roleType role.RoleType, orgID *xid.ID) error {
	parent, err := s.db.Role.Query().
		Where(role.ID(parentID), role.Active(true)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeNotFound, "parent role not found")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get parent role")
	}

	// Parent role must be of same type and context
	if parent.RoleType != roleType {
		return errors.New(errors.CodeInvalidInput, "parent role must be of the same type")
	}

	// Check organization context match
	if (parent.OrganizationID.IsNil()) != (orgID == nil) {
		return errors.New(errors.CodeInvalidInput, "parent role must be in the same organization context")
	}

	if !parent.OrganizationID.IsNil() && orgID != nil && parent.OrganizationID != *orgID {
		return errors.New(errors.CodeInvalidInput, "parent role must be in the same organization")
	}

	return nil
}

// checkCircularRoleReference checks for circular reference in role hierarchy
func (s *Service) checkCircularRoleReference(ctx context.Context, roleID, parentID xid.ID) error {
	// Simple check: ensure parent is not a descendant of the role
	visited := make(map[xid.ID]bool)
	return s.checkCircularRoleReferenceRecursive(ctx, roleID, parentID, visited)
}

// checkCircularRoleReferenceRecursive recursively checks for circular reference
func (s *Service) checkCircularRoleReferenceRecursive(ctx context.Context, originalID, currentID xid.ID, visited map[xid.ID]bool) error {
	if currentID == originalID {
		return errors.New(errors.CodeInvalidInput, "circular role hierarchy detected")
	}

	if visited[currentID] {
		return nil // Already checked this path
	}
	visited[currentID] = true

	// Get current role's parent
	currentRole, err := s.db.Role.Query().
		Where(role.ID(currentID)).
		First(ctx)
	if err != nil {
		return nil // If role not found, no circular reference
	}

	if !currentRole.ParentID.IsNil() {
		return s.checkCircularRoleReferenceRecursive(ctx, originalID, currentRole.ParentID, visited)
	}

	return nil
}

// Data Transfer Objects

// Role wraps ent.Role with additional methods
type Role struct {
	*ent.Role
}

// Permission wraps ent.Permission with additional methods
type Permission struct {
	*ent.Permission
}

// GetEffectivePermissions returns all permissions for a role including inherited ones
func (r *Role) GetEffectivePermissions(ctx context.Context, db *ent.Client) ([]*Permission, error) {
	// This would implement permission inheritance logic
	// For now, just return direct permissions
	permissions, err := db.Role.Query().
		Where(role.ID(r.ID)).
		QueryPermissions().
		Where(permission.Active(true)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	var result []*Permission
	for _, perm := range permissions {
		result = append(result, &Permission{Permission: perm})
	}

	return result, nil
}

// IsApplicableToUserType checks if permission is applicable to a user type
func (p *Permission) IsApplicableToUserType(userType string) bool {
	for _, ut := range p.ApplicableUserTypes {
		if ut == userType {
			return true
		}
	}
	return false
}

// IsApplicableToContext checks if permission is applicable to a context
func (p *Permission) IsApplicableToContext(contextType string) bool {
	for _, ct := range p.ApplicableContexts {
		if ct == contextType {
			return true
		}
	}
	return false
}
