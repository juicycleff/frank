package user

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"time"

	"github.com/juicycleff/frank/ent"
	"github.com/juicycleff/frank/ent/membership"
	"github.com/juicycleff/frank/ent/organization"
	"github.com/juicycleff/frank/ent/role"
	"github.com/juicycleff/frank/ent/user"
	"github.com/juicycleff/frank/ent/userrole"
	"github.com/juicycleff/frank/pkg/crypto"
	"github.com/juicycleff/frank/pkg/errors"
	"github.com/juicycleff/frank/pkg/logging"
	"github.com/rs/xid"
)

// Service handles user operations across all user types
type Service struct {
	db     *ent.Client
	logger logging.Logger
}

// NewService creates a new user service
func NewService(db *ent.Client, logger logging.Logger) *Service {
	return &Service{
		db:     db,
		logger: logger,
	}
}

// User Creation and Management

// CreateUserInput represents input for creating a user
type CreateUserInput struct {
	Email            string                 `json:"email" validate:"required,email"`
	FirstName        *string                `json:"first_name,omitempty" validate:"omitempty,min=1,max=50"`
	LastName         *string                `json:"last_name,omitempty" validate:"omitempty,min=1,max=50"`
	Username         *string                `json:"username,omitempty" validate:"omitempty,min=3,max=50"`
	Password         *string                `json:"password,omitempty" validate:"omitempty,min=8"`
	PhoneNumber      *string                `json:"phone_number,omitempty" validate:"omitempty,e164"`
	UserType         user.UserType          `json:"user_type" validate:"required,oneof=internal external end_user"`
	OrganizationID   *xid.ID                `json:"organization_id,omitempty"`
	AuthProvider     string                 `json:"auth_provider" validate:"omitempty,oneof=internal google github microsoft saml oidc"`
	ExternalID       *string                `json:"external_id,omitempty"`
	EmailVerified    bool                   `json:"email_verified"`
	Active           bool                   `json:"active"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
	CustomAttributes map[string]interface{} `json:"custom_attributes,omitempty"`
	CreatedBy        *xid.ID                `json:"created_by,omitempty"`
}

// CreateUser creates a new user with proper validation and context
func (s *Service) CreateUser(ctx context.Context, input CreateUserInput) (*ent.User, error) {
	// Validate organization context for external users and end users
	if input.UserType == user.UserTypeExternal || input.UserType == user.UserTypeEndUser {
		if input.OrganizationID == nil {
			return nil, errors.New(errors.CodeBadRequest, "organization_id is required for external and end users")
		}

		// Validate organization exists and is active
		orgExists, err := s.db.Organization.Query().
			Where(
				organization.ID(*input.OrganizationID),
				organization.Active(true),
			).
			Exist(ctx)
		if err != nil {
			return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to validate organization")
		}
		if !orgExists {
			return nil, errors.New(errors.CodeNotFound, "organization not found or inactive")
		}
	}

	// Check email uniqueness within context
	if err := s.validateEmailUniqueness(ctx, input.Email, input.UserType, input.OrganizationID); err != nil {
		return nil, err
	}

	// Check username uniqueness if provided
	if input.Username != nil {
		if err := s.validateUsernameUniqueness(ctx, *input.Username, input.UserType, input.OrganizationID); err != nil {
			return nil, err
		}
	}

	// Hash password if provided
	var passwordHash *string
	if input.Password != nil {
		hash, err := crypto.HashPassword(*input.Password)
		if err != nil {
			return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to hash password")
		}
		passwordHash = &hash
	}

	// Set defaults
	authProvider := input.AuthProvider
	if authProvider == "" {
		authProvider = "internal"
	}

	// Start transaction
	tx, err := s.db.Tx(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to start transaction")
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Create user
	userCreate := tx.User.Create().
		SetEmail(input.Email).
		SetNillableFirstName(input.FirstName).
		SetNillableLastName(input.LastName).
		SetNillableUsername(input.Username).
		SetNillablePasswordHash(passwordHash).
		SetNillablePhoneNumber(input.PhoneNumber).
		SetUserType(input.UserType).
		SetNillableOrganizationID(input.OrganizationID).
		SetAuthProvider(authProvider).
		SetNillableExternalID(input.ExternalID).
		SetEmailVerified(input.EmailVerified).
		SetActive(input.Active).
		SetMetadata(input.Metadata).
		SetCustomAttributes(input.CustomAttributes)

	if input.CreatedBy != nil {
		userCreate.SetCreatedBy(input.CreatedBy.String())
	}

	newUser, err := userCreate.Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create user")
	}

	// Assign default role based on user type and context
	if err := s.assignDefaultRole(ctx, tx, newUser); err != nil {
		return nil, err
	}

	// Update organization user counts
	if input.OrganizationID != nil {
		if err := s.updateOrganizationUserCount(ctx, tx, *input.OrganizationID, input.UserType, 1); err != nil {
			return nil, err
		}
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to commit transaction")
	}

	s.logger.Info("User created",
		logging.String("user_id", newUser.ID.String()),
		logging.String("email", newUser.Email),
		logging.String("user_type", string(newUser.UserType)),
		logging.String("organization_id", func() string {
			if input.OrganizationID != nil {
				return input.OrganizationID.String()
			}
			return ""
		}()),
	)

	return newUser, nil
}

// UpdateUserInput represents input for updating a user
type UpdateUserInput struct {
	FirstName        *string                `json:"first_name,omitempty" validate:"omitempty,min=1,max=50"`
	LastName         *string                `json:"last_name,omitempty" validate:"omitempty,min=1,max=50"`
	Username         *string                `json:"username,omitempty" validate:"omitempty,min=3,max=50"`
	PhoneNumber      *string                `json:"phone_number,omitempty" validate:"omitempty,e164"`
	ProfileImageURL  *string                `json:"profile_image_url,omitempty" validate:"omitempty,url"`
	Locale           *string                `json:"locale,omitempty"`
	Timezone         *string                `json:"timezone,omitempty"`
	Active           *bool                  `json:"active,omitempty"`
	Blocked          *bool                  `json:"blocked,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
	CustomAttributes map[string]interface{} `json:"custom_attributes,omitempty"`
}

// UpdateUser updates a user's information
func (s *Service) UpdateUser(ctx context.Context, userID xid.ID, input UpdateUserInput) (*ent.User, error) {
	// Get existing user for validation
	existingUser, err := s.db.User.Query().
		Where(user.ID(userID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "user not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Validate username uniqueness if changed
	if input.Username != nil && existingUser.Username != *input.Username {
		if err := s.validateUsernameUniqueness(ctx, *input.Username, existingUser.UserType, &existingUser.OrganizationID); err != nil {
			return nil, err
		}
	}

	// Build update query
	update := s.db.User.UpdateOneID(userID)

	if input.FirstName != nil {
		update.SetNillableFirstName(input.FirstName)
	}
	if input.LastName != nil {
		update.SetNillableLastName(input.LastName)
	}
	if input.Username != nil {
		update.SetNillableUsername(input.Username)
	}
	if input.PhoneNumber != nil {
		update.SetNillablePhoneNumber(input.PhoneNumber)
	}
	if input.ProfileImageURL != nil {
		update.SetNillableProfileImageURL(input.ProfileImageURL)
	}
	if input.Locale != nil {
		update.SetLocale(*input.Locale)
	}
	if input.Timezone != nil {
		update.SetNillableTimezone(input.Timezone)
	}
	if input.Active != nil {
		update.SetActive(*input.Active)
	}
	if input.Blocked != nil {
		update.SetBlocked(*input.Blocked)
	}
	if input.Metadata != nil {
		update.SetMetadata(input.Metadata)
	}
	if input.CustomAttributes != nil {
		update.SetCustomAttributes(input.CustomAttributes)
	}

	updatedUser, err := update.Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to update user")
	}

	return updatedUser, nil
}

// GetUser retrieves a user by ID with organization context validation
func (s *Service) GetUser(ctx context.Context, userID xid.ID, requesterOrgID *xid.ID) (*ent.User, error) {
	query := s.db.User.Query().
		Where(user.ID(userID)).
		WithMemberships(func(q *ent.MembershipQuery) {
			q.WithRole().WithOrganization()
		}).
		WithUserRoles(func(q *ent.UserRoleQuery) {
			q.WithRole()
		})

	// If requester has organization context, ensure user is accessible
	if requesterOrgID != nil {
		query.Where(
			user.Or(
				user.OrganizationID(*requesterOrgID),                                // User belongs to requester's org
				user.HasMembershipsWith(membership.OrganizationID(*requesterOrgID)), // User is member of requester's org
			),
		)
	}

	foundUser, err := query.First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeNotFound, "user not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	return foundUser, nil
}

// ListUsersInput represents input for listing users
type ListUsersInput struct {
	OrganizationID *xid.ID        `json:"organization_id,omitempty"`
	UserType       *user.UserType `json:"user_type,omitempty"`
	Active         *bool          `json:"active,omitempty"`
	Blocked        *bool          `json:"blocked,omitempty"`
	AuthProvider   *string        `json:"auth_provider,omitempty"`
	Search         *string        `json:"search,omitempty"`
	Limit          int            `json:"limit" validate:"min=1,max=100"`
	Offset         int            `json:"offset" validate:"min=0"`
}

// ListUsers lists users with filtering and pagination
func (s *Service) ListUsers(ctx context.Context, input ListUsersInput) ([]*ent.User, int, error) {
	query := s.db.User.Query()

	// Apply filters
	if input.OrganizationID != nil {
		query.Where(
			user.Or(
				user.OrganizationID(*input.OrganizationID),
				user.HasMembershipsWith(membership.OrganizationID(*input.OrganizationID)),
			),
		)
	}

	if input.UserType != nil {
		query.Where(user.UserTypeEQ(*input.UserType))
	}

	if input.Active != nil {
		query.Where(user.Active(*input.Active))
	}

	if input.Blocked != nil {
		query.Where(user.Blocked(*input.Blocked))
	}

	if input.AuthProvider != nil {
		query.Where(user.AuthProvider(*input.AuthProvider))
	}

	if input.Search != nil && *input.Search != "" {
		// searchTerm := "%" + strings.ToLower(*input.Search) + "%"
		query.Where(
			user.Or(
				user.EmailContainsFold(*input.Search),
				user.FirstNameContainsFold(*input.Search),
				user.LastNameContainsFold(*input.Search),
				user.UsernameContainsFold(*input.Search),
			),
		)
	}

	// Get total count
	totalCount, err := query.Count(ctx)
	if err != nil {
		return nil, 0, errors.Wrap(errors.CodeDatabaseError, err, "failed to count users")
	}

	// Apply pagination and get results
	users, err := query.
		Limit(input.Limit).
		Offset(input.Offset).
		Order(ent.Asc(user.FieldCreatedAt)).
		WithMemberships(func(q *ent.MembershipQuery) {
			q.WithRole().WithOrganization()
		}).
		All(ctx)
	if err != nil {
		return nil, 0, errors.Wrap(errors.CodeDatabaseError, err, "failed to list users")
	}

	return users, totalCount, nil
}

// DeleteUser soft deletes a user (sets active to false)
func (s *Service) DeleteUser(ctx context.Context, userID xid.ID) error {
	// Get user for organization context
	existingUser, err := s.db.User.Query().
		Where(user.ID(userID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeNotFound, "user not found")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Start transaction
	tx, err := s.db.Tx(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to start transaction")
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Soft delete user
	err = tx.User.UpdateOneID(userID).
		SetActive(false).
		SetBlocked(true).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to delete user")
	}

	// Update organization user count
	if !existingUser.OrganizationID.IsNil() {
		if err := s.updateOrganizationUserCount(ctx, tx, existingUser.OrganizationID, existingUser.UserType, -1); err != nil {
			return err
		}
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to commit transaction")
	}

	s.logger.Info("User deleted",
		logging.String("user_id", userID.String()),
		logging.String("email", existingUser.Email),
	)

	return nil
}

// Authentication Methods

// ChangePasswordInput represents input for changing password
type ChangePasswordInput struct {
	CurrentPassword string `json:"current_password" validate:"required" doc:"Current password"`
	NewPassword     string `json:"new_password" validate:"required,min=8" doc:"New password"`
}

// ChangePassword changes a user's password
func (s *Service) ChangePassword(ctx context.Context, userID xid.ID, input ChangePasswordInput) error {
	// Get user
	existingUser, err := s.db.User.Query().
		Where(user.ID(userID)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeNotFound, "user not found")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Verify current password
	if existingUser.PasswordHash != "" {
		if crypto.VerifyPassword(input.CurrentPassword, existingUser.PasswordHash) != nil {
			return errors.New(errors.CodeUnauthorized, "current password is incorrect")
		}
	}

	// Hash new password
	newHash, err := crypto.HashPassword(input.NewPassword)
	if err != nil {
		return errors.Wrap(errors.CodeCryptoError, err, "failed to hash new password")
	}

	// Update password
	err = s.db.User.UpdateOneID(userID).
		SetPasswordHash(newHash).
		SetLastPasswordChange(time.Now()).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to update password")
	}

	s.logger.Info("Password changed",
		logging.String("user_id", userID.String()),
	)

	return nil
}

// ResetPasswordInput represents input for password reset
type ResetPasswordInput struct {
	Email string `json:"email" validate:"required,email"`
}

// InitiatePasswordReset initiates a password reset process
func (s *Service) InitiatePasswordReset(ctx context.Context, input ResetPasswordInput) error {
	// Find user by email
	existingUser, err := s.db.User.Query().
		Where(user.Email(input.Email), user.Active(true)).
		First(ctx)
	if err != nil {
		// Don't reveal if email exists for security
		if ent.IsNotFound(err) {
			return nil
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to find user")
	}

	// Generate reset token
	token, err := generateSecureToken(32)
	if err != nil {
		return errors.Wrap(errors.CodeCryptoError, err, "failed to generate reset token")
	}

	// Set token and expiry (15 minutes)
	expiresAt := time.Now().Add(15 * time.Minute)
	err = s.db.User.UpdateOneID(existingUser.ID).
		SetPasswordResetToken(token).
		SetPasswordResetTokenExpires(expiresAt).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to set reset token")
	}

	// TODO: Send reset email
	s.logger.Info("Password reset initiated",
		logging.String("user_id", existingUser.ID.String()),
		logging.String("email", input.Email),
	)

	return nil
}

// CompletePasswordResetInput represents input for completing password reset
type CompletePasswordResetInput struct {
	Token       string `json:"token" validate:"required"`
	NewPassword string `json:"new_password" validate:"required,min=8"`
}

// CompletePasswordReset completes the password reset process
func (s *Service) CompletePasswordReset(ctx context.Context, input CompletePasswordResetInput) error {
	// Find user with valid reset token
	existingUser, err := s.db.User.Query().
		Where(
			user.PasswordResetToken(input.Token),
			user.PasswordResetTokenExpiresGT(time.Now()),
			user.Active(true),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeUnauthorized, "invalid or expired reset token")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to find user with reset token")
	}

	// Hash new password
	newHash, err := crypto.HashPassword(input.NewPassword)
	if err != nil {
		return errors.Wrap(errors.CodeCryptoError, err, "failed to hash new password")
	}

	// Update password and clear reset token
	err = s.db.User.UpdateOneID(existingUser.ID).
		SetPasswordHash(newHash).
		SetLastPasswordChange(time.Now()).
		ClearPasswordResetToken().
		ClearPasswordResetTokenExpires().
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to update password")
	}

	s.logger.Info("Password reset completed",
		logging.String("user_id", existingUser.ID.String()),
	)

	return nil
}

// Helper Functions

// validateEmailUniqueness validates email uniqueness within the appropriate context
func (s *Service) validateEmailUniqueness(ctx context.Context, email string, userType user.UserType, orgID *xid.ID) error {
	query := s.db.User.Query().
		Where(
			user.Email(email),
			user.UserTypeEQ(userType),
		)

	// For external and end users, check uniqueness within organization
	if (userType == user.UserTypeExternal || userType == user.UserTypeEndUser) && orgID != nil {
		query.Where(user.OrganizationID(*orgID))
	}

	exists, err := query.Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check email uniqueness")
	}

	if exists {
		return errors.New(errors.CodeConflict, "email already exists in this context")
	}

	return nil
}

// validateUsernameUniqueness validates username uniqueness within the appropriate context
func (s *Service) validateUsernameUniqueness(ctx context.Context, username string, userType user.UserType, orgID *xid.ID) error {
	query := s.db.User.Query().
		Where(
			user.Username(username),
			user.UserTypeEQ(userType),
		)

	// For external and end users, check uniqueness within organization
	if (userType == user.UserTypeExternal || userType == user.UserTypeEndUser) && orgID != nil {
		query.Where(user.OrganizationID(*orgID))
	}

	exists, err := query.Exist(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to check username uniqueness")
	}

	if exists {
		return errors.New(errors.CodeConflict, "username already exists in this context")
	}

	return nil
}

// assignDefaultRole assigns default role to new user based on type and context
func (s *Service) assignDefaultRole(ctx context.Context, tx *ent.Tx, newUser *ent.User) error {
	var defaultRole *ent.Role

	switch newUser.UserType {
	case user.UserTypeInternal:
		// Assign default platform role
		defaultRole, _ = tx.Role.Query().
			Where(
				role.Name("platform_user"),
				role.RoleTypeEQ(role.RoleTypeSystem),
				role.IsDefault(true),
			).
			First(ctx)

	case user.UserTypeExternal:
		// Assign default organization member role
		if !newUser.OrganizationID.IsNil() {
			defaultRole, _ = tx.Role.Query().
				Where(
					role.Name("member"),
					role.RoleTypeEQ(role.RoleTypeOrganization),
					role.OrganizationID(newUser.OrganizationID),
					role.IsDefault(true),
				).
				First(ctx)
		}

	case user.UserTypeEndUser:
		// Assign default end user role
		if !newUser.OrganizationID.IsNil() {
			defaultRole, _ = tx.Role.Query().
				Where(
					role.Name("end_user"),
					role.RoleTypeEQ(role.RoleTypeApplication),
					role.OrganizationID(newUser.OrganizationID),
					role.IsDefault(true),
				).
				First(ctx)
		}
	}

	// Assign role if found
	if defaultRole != nil {
		contextType := userrole.ContextTypeSystem
		var contextID *xid.ID

		if defaultRole.RoleType == role.RoleTypeOrganization {
			contextType = userrole.ContextTypeOrganization
			contextID = &newUser.OrganizationID
		} else if defaultRole.RoleType == role.RoleTypeApplication {
			contextType = userrole.ContextTypeApplication
			contextID = &newUser.OrganizationID
		}

		_, err := tx.UserRole.Create().
			SetUserID(newUser.ID).
			SetRoleID(defaultRole.ID).
			SetContextType(contextType).
			SetNillableContextID(contextID).
			SetActive(true).
			Save(ctx)
		if err != nil {
			return errors.Wrap(errors.CodeDatabaseError, err, "failed to assign default role")
		}
	}

	return nil
}

// updateOrganizationUserCount updates user count in organization
func (s *Service) updateOrganizationUserCount(ctx context.Context, tx *ent.Tx, orgID xid.ID, userType user.UserType, delta int) error {
	org, err := tx.Organization.Query().
		Where(organization.ID(orgID)).
		First(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get organization")
	}

	update := tx.Organization.UpdateOneID(orgID)

	switch userType {
	case user.UserTypeExternal:
		newCount := org.CurrentExternalUsers + delta
		if newCount < 0 {
			newCount = 0
		}
		update.SetCurrentExternalUsers(newCount)

	case user.UserTypeEndUser:
		newCount := org.CurrentEndUsers + delta
		if newCount < 0 {
			newCount = 0
		}
		update.SetCurrentEndUsers(newCount)
	}

	return update.Exec(ctx)
}

// generateSecureToken generates a cryptographically secure token
func generateSecureToken(length int) (string, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(bytes), nil
}

// GetUsersByOrganization returns all users in an organization
func (s *Service) GetUsersByOrganization(ctx context.Context, orgID xid.ID, userType *user.UserType) ([]*ent.User, error) {
	query := s.db.User.Query().
		Where(
			user.Or(
				user.OrganizationID(orgID),
				user.HasMembershipsWith(membership.OrganizationID(orgID)),
			),
			user.Active(true),
		)

	if userType != nil {
		query.Where(user.UserTypeEQ(*userType))
	}

	users, err := query.All(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get users by organization")
	}

	return users, nil
}

// GetUserMemberships returns all memberships for a user
func (s *Service) GetUserMemberships(ctx context.Context, userID xid.ID) ([]*ent.Membership, error) {
	memberships, err := s.db.Membership.Query().
		Where(
			membership.UserID(userID),
			membership.StatusEQ(membership.StatusActive),
		).
		WithOrganization().
		WithRole().
		All(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user memberships")
	}

	return memberships, nil
}

// VerifyUserAccess verifies if a user has access to a resource in an organization context
func (s *Service) VerifyUserAccess(ctx context.Context, userID, orgID xid.ID) (bool, error) {
	// Check if user belongs to organization directly or through membership
	exists, err := s.db.User.Query().
		Where(
			user.ID(userID),
			user.Active(true),
			user.Or(
				user.OrganizationID(orgID),
				user.HasMembershipsWith(
					membership.And(
						membership.OrganizationID(orgID),
						membership.StatusEQ(membership.StatusActive),
					),
				),
			),
		).
		Exist(ctx)
	if err != nil {
		return false, errors.Wrap(errors.CodeDatabaseError, err, "failed to verify user access")
	}

	return exists, nil
}
