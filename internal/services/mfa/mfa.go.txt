package mfa

import (
	"context"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base32"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/juicycleff/frank/config"
	"github.com/juicycleff/frank/ent"
	"github.com/juicycleff/frank/ent/mfa"
	"github.com/juicycleff/frank/ent/user"
	"github.com/juicycleff/frank/pkg/crypto"
	"github.com/juicycleff/frank/pkg/errors"
	"github.com/juicycleff/frank/pkg/logging"
	"github.com/pquerna/otp"
	"github.com/pquerna/otp/totp"
	"github.com/rs/xid"
)

// Service handles MFA operations
type Service struct {
	db     *ent.Client
	config *config.Config
	logger logging.Logger
}

// NewService creates a new MFA service
func NewService(db *ent.Client, config *config.Config, logger logging.Logger) *Service {
	return &Service{
		db:     db,
		config: config,
		logger: logger,
	}
}

// MFA Method Types
const (
	MethodTOTP        = "totp"
	MethodSMS         = "sms"
	MethodEmail       = "email"
	MethodBackupCodes = "backup_codes"
)

// TOTP Configuration
const (
	TOTPIssuer    = "Frank Auth"
	TOTPDigits    = 6
	TOTPPeriod    = 30
	TOTPSkew      = 1
	TOTPAlgorithm = otp.AlgorithmSHA1
)

// Input/Output Types

// SetupTOTPInput represents input for setting up TOTP
type SetupTOTPInput struct {
	UserID      xid.ID  `json:"user_id" validate:"required"`
	AccountName *string `json:"account_name,omitempty"`
}

// SetupTOTPOutput represents output for TOTP setup
type SetupTOTPOutput struct {
	Secret    string   `json:"secret"`
	QRCodeURL string   `json:"qr_code_url"`
	BackupURL string   `json:"backup_url"`
	MFA       *ent.MFA `json:"mfa"`
}

// VerifyTOTPInput represents input for verifying TOTP
type VerifyTOTPInput struct {
	UserID xid.ID `json:"user_id" validate:"required"`
	Code   string `json:"code" validate:"required,len=6,numeric"`
}

// SetupSMSInput represents input for setting up SMS MFA
type SetupSMSInput struct {
	UserID      xid.ID `json:"user_id" validate:"required"`
	PhoneNumber string `json:"phone_number" validate:"required,e164"`
}

// SetupEmailInput represents input for setting up Email MFA
type SetupEmailInput struct {
	UserID xid.ID `json:"user_id" validate:"required"`
	Email  string `json:"email" validate:"required,email"`
}

// SendCodeInput represents input for sending MFA code
type SendCodeInput struct {
	UserID xid.ID `json:"user_id" validate:"required"`
	Method string `json:"method" validate:"required,oneof=sms email"`
}

// VerifyCodeInput represents input for verifying MFA code
type VerifyCodeInput struct {
	UserID xid.ID `json:"user_id" validate:"required"`
	Method string `json:"method" validate:"required,oneof=sms email totp backup_code"`
	Code   string `json:"code" validate:"required"`
}

// GenerateBackupCodesInput represents input for generating backup codes
type GenerateBackupCodesInput struct {
	UserID xid.ID `json:"user_id" validate:"required"`
	Count  int    `json:"count" validate:"min=1,max=20"`
}

// BackupCodesOutput represents output for backup codes
type BackupCodesOutput struct {
	BackupCodes []string `json:"backup_codes"`
	MFA         *ent.MFA `json:"mfa"`
}

// MFAStatusOutput represents MFA status for a user
type MFAStatusOutput struct {
	UserID           xid.ID     `json:"user_id"`
	MFAEnabled       bool       `json:"mfa_enabled"`
	Methods          []*ent.MFA `json:"methods"`
	PrimaryMethod    *string    `json:"primary_method,omitempty"`
	BackupCodesCount int        `json:"backup_codes_count"`
	LastUsed         *time.Time `json:"last_used,omitempty"`
}

// TOTP Management

// SetupTOTP sets up TOTP for a user
func (s *Service) SetupTOTP(ctx context.Context, input SetupTOTPInput) (*SetupTOTPOutput, error) {
	// Verify user exists
	targetUser, err := s.db.User.Query().
		Where(user.ID(input.UserID), user.Active(true)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeUserNotFound, "user not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Check if TOTP is already set up
	existingTOTP, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(MethodTOTP),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to check existing TOTP")
	}

	if existingTOTP != nil {
		return nil, errors.New(errors.CodeConflict, "TOTP is already set up for this user")
	}

	// Generate TOTP secret
	secret, err := s.generateTOTPSecret()
	if err != nil {
		return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to generate TOTP secret")
	}

	// Create account name
	accountName := targetUser.Email
	if input.AccountName != nil {
		accountName = *input.AccountName
	}

	// Generate TOTP key
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      s.getTOTPIssuer(),
		AccountName: accountName,
		Secret:      []byte(secret),
		Digits:      otp.Digits(s.getTOTPDigits()),
		Algorithm:   s.getTOTPAlgorithm(),
		Period:      s.getTOTPPeriod(),
	})
	if err != nil {
		return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to generate TOTP key")
	}

	// Encrypt the secret
	encryptedSecret, err := crypto.Encrypt(secret, s.config.Auth.TokenSecretKey)
	if err != nil {
		return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to encrypt TOTP secret")
	}

	// Create MFA record (not verified yet)
	mfaRecord, err := s.db.MFA.Create().
		SetUserID(input.UserID).
		SetMethod(MethodTOTP).
		SetSecret(string(encryptedSecret)).
		SetVerified(false).
		SetActive(true).
		SetMetadata(map[string]interface{}{
			"issuer":       s.getTOTPIssuer(),
			"account_name": accountName,
			"digits":       s.getTOTPDigits(),
			"period":       s.getTOTPPeriod(),
			"algorithm":    s.getTOTPAlgorithm().String(),
		}).
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create MFA record")
	}

	s.logger.Info("TOTP setup initiated",
		logging.String("user_id", input.UserID.String()),
		logging.String("mfa_id", mfaRecord.ID.String()),
	)

	return &SetupTOTPOutput{
		Secret:    secret,
		QRCodeURL: key.URL(),
		BackupURL: key.String(),
		MFA:       mfaRecord,
	}, nil
}

// VerifyTOTP verifies TOTP code and activates the method
func (s *Service) VerifyTOTP(ctx context.Context, input VerifyTOTPInput) error {
	// Get TOTP MFA record
	mfaRecord, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(MethodTOTP),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeMFAMethodNotFound, "TOTP not set up for this user")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get TOTP record")
	}

	// Decrypt the secret
	secret, err := crypto.Decrypt(mfaRecord.Secret, s.config.Auth.TokenSecretKey)
	if err != nil {
		return errors.Wrap(errors.CodeCryptoError, err, "failed to decrypt TOTP secret")
	}

	// Verify the code
	valid := totp.Validate(input.Code, secret, time.Now())
	if !valid {
		// Try with skew
		now := time.Now()
		for i := 1; i <= int(s.getTOTPSkew()); i++ {
			// Check past
			if totp.Validate(input.Code, secret, now.Add(-time.Duration(i)*time.Second*time.Duration(s.getTOTPPeriod()))) {
				valid = true
				break
			}
			// Check future
			if totp.Validate(input.Code, secret, now.Add(time.Duration(i)*time.Second*time.Duration(s.getTOTPPeriod()))) {
				valid = true
				break
			}
		}
	}

	if !valid {
		return errors.New(errors.CodeInvalidMFACode, "invalid TOTP code")
	}

	// Mark as verified and update last used
	err = s.db.MFA.UpdateOne(mfaRecord).
		SetVerified(true).
		SetLastUsed(time.Now()).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to verify TOTP")
	}

	s.logger.Info("TOTP verified successfully",
		logging.String("user_id", input.UserID.String()),
		logging.String("mfa_id", mfaRecord.ID.String()),
	)

	return nil
}

// SMS MFA Management

// SetupSMS sets up SMS MFA for a user
func (s *Service) SetupSMS(ctx context.Context, input SetupSMSInput) (*ent.MFA, error) {
	// Verify user exists
	_, err := s.db.User.Query().
		Where(user.ID(input.UserID), user.Active(true)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeUserNotFound, "user not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Check if SMS MFA is already set up
	existingSMS, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(MethodSMS),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to check existing SMS MFA")
	}

	if existingSMS != nil {
		// Update phone number
		mfaRecord, err := s.db.MFA.UpdateOne(existingSMS).
			SetPhoneNumber(input.PhoneNumber).
			SetVerified(false).
			Save(ctx)
		if err != nil {
			return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to update SMS MFA")
		}
		return mfaRecord, nil
	}

	// Generate a secret for SMS (used for verification)
	secret, err := s.generateRandomSecret(32)
	if err != nil {
		return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to generate SMS secret")
	}

	// Create MFA record
	mfaRecord, err := s.db.MFA.Create().
		SetUserID(input.UserID).
		SetMethod(MethodSMS).
		SetSecret(secret).
		SetPhoneNumber(input.PhoneNumber).
		SetVerified(false).
		SetActive(true).
		SetMetadata(map[string]interface{}{
			"phone_number": input.PhoneNumber,
		}).
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create SMS MFA record")
	}

	s.logger.Info("SMS MFA setup initiated",
		logging.String("user_id", input.UserID.String()),
		logging.String("phone_number", input.PhoneNumber),
	)

	return mfaRecord, nil
}

// SetupEmail sets up Email MFA for a user
func (s *Service) SetupEmail(ctx context.Context, input SetupEmailInput) (*ent.MFA, error) {
	// Verify user exists
	_, err := s.db.User.Query().
		Where(user.ID(input.UserID), user.Active(true)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeUserNotFound, "user not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Check if Email MFA is already set up
	existingEmail, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(MethodEmail),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to check existing Email MFA")
	}

	if existingEmail != nil {
		// Update email address
		mfaRecord, err := s.db.MFA.UpdateOne(existingEmail).
			SetEmail(input.Email).
			SetVerified(false).
			Save(ctx)
		if err != nil {
			return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to update Email MFA")
		}
		return mfaRecord, nil
	}

	// Generate a secret for Email (used for verification)
	secret, err := s.generateRandomSecret(32)
	if err != nil {
		return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to generate Email secret")
	}

	// Create MFA record
	mfaRecord, err := s.db.MFA.Create().
		SetUserID(input.UserID).
		SetMethod(MethodEmail).
		SetSecret(secret).
		SetEmail(input.Email).
		SetVerified(false).
		SetActive(true).
		SetMetadata(map[string]interface{}{
			"email": input.Email,
		}).
		Save(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create Email MFA record")
	}

	s.logger.Info("Email MFA setup initiated",
		logging.String("user_id", input.UserID.String()),
		logging.String("email", input.Email),
	)

	return mfaRecord, nil
}

// Code-based MFA (SMS/Email)

// SendCode sends MFA code via SMS or Email
func (s *Service) SendCode(ctx context.Context, input SendCodeInput) error {
	// Get MFA record
	mfaRecord, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(input.Method),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeMFAMethodNotFound, fmt.Sprintf("%s MFA not set up for this user", strings.ToUpper(input.Method)))
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get MFA record")
	}

	// Generate verification code
	code, err := s.generateMFACode(6)
	if err != nil {
		return errors.Wrap(errors.CodeCryptoError, err, "failed to generate MFA code")
	}

	// Hash and store the code
	hashedCode, err := crypto.HashPassword(code)
	if err != nil {
		return errors.Wrap(errors.CodeCryptoError, err, "failed to hash MFA code")
	}

	// Update MFA record with the code and expiry
	expiresAt := time.Now().Add(s.getMFACodeExpiry(input.Method))
	err = s.db.MFA.UpdateOne(mfaRecord).
		SetSecret(hashedCode).
		SetMetadata(map[string]interface{}{
			"code_expires_at": expiresAt,
			"code_attempts":   0,
		}).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to store MFA code")
	}

	// Send the code
	switch input.Method {
	case MethodSMS:
		if mfaRecord.PhoneNumber == nil {
			return errors.New(errors.CodeInvalidInput, "phone number not set for SMS MFA")
		}
		err = s.sendSMSCode(*mfaRecord.PhoneNumber, code)
	case MethodEmail:
		if mfaRecord.Email == nil {
			return errors.New(errors.CodeInvalidInput, "email not set for Email MFA")
		}
		err = s.sendEmailCode(*mfaRecord.Email, code)
	default:
		return errors.New(errors.CodeInvalidInput, "unsupported MFA method for code sending")
	}

	if err != nil {
		return errors.Wrap(errors.CodeNotificationFailed, err, "failed to send MFA code")
	}

	s.logger.Info("MFA code sent",
		logging.String("user_id", input.UserID.String()),
		logging.String("method", input.Method),
	)

	return nil
}

// VerifyCode verifies MFA code for SMS/Email/TOTP/Backup
func (s *Service) VerifyCode(ctx context.Context, input VerifyCodeInput) error {
	switch input.Method {
	case MethodTOTP:
		return s.VerifyTOTP(ctx, VerifyTOTPInput{
			UserID: input.UserID,
			Code:   input.Code,
		})
	case MethodBackupCodes:
		return s.verifyBackupCode(ctx, input.UserID, input.Code)
	case MethodSMS, MethodEmail:
		return s.verifyCodeBased(ctx, input)
	default:
		return errors.New(errors.CodeInvalidInput, "unsupported MFA method")
	}
}

// verifyCodeBased verifies code for SMS/Email MFA
func (s *Service) verifyCodeBased(ctx context.Context, input VerifyCodeInput) error {
	// Get MFA record
	mfaRecord, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(input.Method),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeMFAMethodNotFound, fmt.Sprintf("%s MFA not set up for this user", strings.ToUpper(input.Method)))
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get MFA record")
	}

	// Check if code has expired
	if codeExpiresAt, ok := mfaRecord.Metadata["code_expires_at"].(time.Time); ok {
		if time.Now().After(codeExpiresAt) {
			return errors.New(errors.CodeMFACodeExpired, "MFA code has expired")
		}
	}

	// Check rate limiting
	if attempts, ok := mfaRecord.Metadata["code_attempts"].(int); ok {
		if attempts >= 3 {
			return errors.New(errors.CodeTooManyRequests, "too many failed attempts")
		}
	}

	// Verify the code
	valid := crypto.VerifyPassword(input.Code, mfaRecord.Secret)
	if !valid {
		// Increment attempts
		attempts := 0
		if a, ok := mfaRecord.Metadata["code_attempts"].(int); ok {
			attempts = a
		}
		attempts++

		metadata := mfaRecord.Metadata
		metadata["code_attempts"] = attempts

		err = s.db.MFA.UpdateOne(mfaRecord).
			SetMetadata(metadata).
			Exec(ctx)
		if err != nil {
			s.logger.Warn("Failed to update MFA attempts", logging.Error(err))
		}

		return errors.New(errors.CodeInvalidMFACode, "invalid MFA code")
	}

	// Mark as verified and update last used
	err = s.db.MFA.UpdateOne(mfaRecord).
		SetVerified(true).
		SetLastUsed(time.Now()).
		SetMetadata(map[string]interface{}{
			"code_attempts": 0,
		}).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to verify MFA")
	}

	s.logger.Info("MFA code verified successfully",
		logging.String("user_id", input.UserID.String()),
		logging.String("method", input.Method),
	)

	return nil
}

// Backup Codes Management

// GenerateBackupCodes generates backup codes for a user
func (s *Service) GenerateBackupCodes(ctx context.Context, input GenerateBackupCodesInput) (*BackupCodesOutput, error) {
	// Verify user exists
	_, err := s.db.User.Query().
		Where(user.ID(input.UserID), user.Active(true)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.New(errors.CodeUserNotFound, "user not found")
		}
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get user")
	}

	// Set default count if not provided
	count := input.Count
	if count == 0 {
		count = s.getBackupCodesCount()
	}

	// Generate backup codes
	backupCodes, err := s.generateBackupCodes(count)
	if err != nil {
		return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to generate backup codes")
	}

	// Hash the backup codes for storage
	hashedCodes := make([]string, len(backupCodes))
	for i, code := range backupCodes {
		hashedCodes[i], err = crypto.HashPassword(code)
		if err != nil {
			return nil, errors.Wrap(errors.CodeCryptoError, err, "failed to hash backup code")
		}
	}

	// Check if backup codes already exist
	existingBackupCodes, err := s.db.MFA.Query().
		Where(
			mfa.UserID(input.UserID),
			mfa.Method(MethodBackupCodes),
			mfa.Active(true),
		).
		First(ctx)

	var mfaRecord *ent.MFA
	if err != nil && !ent.IsNotFound(err) {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to check existing backup codes")
	}

	if existingBackupCodes != nil {
		// Update existing backup codes
		mfaRecord, err = s.db.MFA.UpdateOne(existingBackupCodes).
			SetBackupCodes(hashedCodes).
			SetVerified(true).
			SetMetadata(map[string]interface{}{
				"used_codes":   []string{},
				"generated_at": time.Now(),
			}).
			Save(ctx)
		if err != nil {
			return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to update backup codes")
		}
	} else {
		// Create new backup codes record
		mfaRecord, err = s.db.MFA.Create().
			SetUserID(input.UserID).
			SetMethod(MethodBackupCodes).
			SetSecret("backup_codes").
			SetBackupCodes(hashedCodes).
			SetVerified(true).
			SetActive(true).
			SetMetadata(map[string]interface{}{
				"used_codes":   []string{},
				"generated_at": time.Now(),
			}).
			Save(ctx)
		if err != nil {
			return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to create backup codes")
		}
	}

	s.logger.Info("Backup codes generated",
		logging.String("user_id", input.UserID.String()),
		logging.Int("count", count),
	)

	return &BackupCodesOutput{
		BackupCodes: backupCodes,
		MFA:         mfaRecord,
	}, nil
}

// verifyBackupCode verifies a backup code
func (s *Service) verifyBackupCode(ctx context.Context, userID xid.ID, code string) error {
	// Get backup codes record
	mfaRecord, err := s.db.MFA.Query().
		Where(
			mfa.UserID(userID),
			mfa.Method(MethodBackupCodes),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeMFAMethodNotFound, "backup codes not set up for this user")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get backup codes record")
	}

	// Get used codes list
	usedCodes := []string{}
	if used, ok := mfaRecord.Metadata["used_codes"].([]interface{}); ok {
		for _, u := range used {
			if s, ok := u.(string); ok {
				usedCodes = append(usedCodes, s)
			}
		}
	}

	// Check if code is already used
	for _, usedCode := range usedCodes {
		if subtle.ConstantTimeCompare([]byte(code), []byte(usedCode)) == 1 {
			return errors.New(errors.CodeBackupCodeUsed, "backup code has already been used")
		}
	}

	// Verify the code against stored hashes
	codeValid := false
	for _, hashedCode := range mfaRecord.BackupCodes {
		if crypto.VerifyPassword(code, hashedCode) {
			codeValid = true
			break
		}
	}

	if !codeValid {
		return errors.New(errors.CodeInvalidBackupCode, "invalid backup code")
	}

	// Mark code as used
	usedCodes = append(usedCodes, code)
	metadata := mfaRecord.Metadata
	metadata["used_codes"] = usedCodes

	err = s.db.MFA.UpdateOne(mfaRecord).
		SetLastUsed(time.Now()).
		SetMetadata(metadata).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to mark backup code as used")
	}

	s.logger.Info("Backup code verified successfully",
		logging.String("user_id", userID.String()),
	)

	return nil
}

// MFA Status and Management

// GetMFAStatus returns MFA status for a user
func (s *Service) GetMFAStatus(ctx context.Context, userID xid.ID) (*MFAStatusOutput, error) {
	// Get all MFA methods for user
	mfaMethods, err := s.db.MFA.Query().
		Where(
			mfa.UserID(userID),
			mfa.Active(true),
		).
		Order(ent.Asc(mfa.FieldCreatedAt)).
		All(ctx)
	if err != nil {
		return nil, errors.Wrap(errors.CodeDatabaseError, err, "failed to get MFA methods")
	}

	// Calculate status
	mfaEnabled := false
	var primaryMethod *string
	var lastUsed *time.Time
	backupCodesCount := 0

	for _, method := range mfaMethods {
		if method.Verified {
			mfaEnabled = true
			if primaryMethod == nil {
				primaryMethod = &method.Method
			}
			if method.LastUsed != nil && (lastUsed == nil || method.LastUsed.After(*lastUsed)) {
				lastUsed = method.LastUsed
			}
		}

		if method.Method == MethodBackupCodes {
			// Count unused backup codes
			usedCount := 0
			if used, ok := method.Metadata["used_codes"].([]interface{}); ok {
				usedCount = len(used)
			}
			backupCodesCount = len(method.BackupCodes) - usedCount
		}
	}

	return &MFAStatusOutput{
		UserID:           userID,
		MFAEnabled:       mfaEnabled,
		Methods:          mfaMethods,
		PrimaryMethod:    primaryMethod,
		BackupCodesCount: backupCodesCount,
		LastUsed:         lastUsed,
	}, nil
}

// DisableMFA disables an MFA method for a user
func (s *Service) DisableMFA(ctx context.Context, userID xid.ID, method string) error {
	// Get MFA record
	mfaRecord, err := s.db.MFA.Query().
		Where(
			mfa.UserID(userID),
			mfa.Method(method),
			mfa.Active(true),
		).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return errors.New(errors.CodeMFAMethodNotFound, "MFA method not found")
		}
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to get MFA record")
	}

	// Disable the method
	err = s.db.MFA.UpdateOne(mfaRecord).
		SetActive(false).
		Exec(ctx)
	if err != nil {
		return errors.Wrap(errors.CodeDatabaseError, err, "failed to disable MFA method")
	}

	s.logger.Info("MFA method disabled",
		logging.String("user_id", userID.String()),
		logging.String("method", method),
	)

	return nil
}

// Helper Functions

// generateTOTPSecret generates a random TOTP secret
func (s *Service) generateTOTPSecret() (string, error) {
	secret := make([]byte, 20) // 160 bits
	_, err := rand.Read(secret)
	if err != nil {
		return "", err
	}
	return base32.StdEncoding.EncodeToString(secret), nil
}

// generateRandomSecret generates a random secret of specified length
func (s *Service) generateRandomSecret(length int) (string, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base32.StdEncoding.EncodeToString(bytes), nil
}

// generateMFACode generates a numeric MFA code
func (s *Service) generateMFACode(length int) (string, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}

	code := ""
	for _, b := range bytes {
		code += strconv.Itoa(int(b) % 10)
	}
	return code, nil
}

// generateBackupCodes generates backup codes
func (s *Service) generateBackupCodes(count int) ([]string, error) {
	codes := make([]string, count)
	for i := 0; i < count; i++ {
		code, err := s.generateMFACode(s.getBackupCodesLength())
		if err != nil {
			return nil, err
		}
		codes[i] = code
	}
	return codes, nil
}

// Configuration getters with defaults

func (s *Service) getTOTPIssuer() string {
	if s.config.MFA.TOTPIssuer != "" {
		return s.config.MFA.TOTPIssuer
	}
	return TOTPIssuer
}

func (s *Service) getTOTPDigits() int {
	if s.config.MFA.TOTPDigits > 0 {
		return s.config.MFA.TOTPDigits
	}
	return TOTPDigits
}

func (s *Service) getTOTPPeriod() uint {
	if s.config.MFA.TOTPPeriod > 0 {
		return s.config.MFA.TOTPPeriod
	}
	return TOTPPeriod
}

func (s *Service) getTOTPSkew() uint {
	if s.config.MFA.TOTPSkew > 0 {
		return s.config.MFA.TOTPSkew
	}
	return TOTPSkew
}

func (s *Service) getTOTPAlgorithm() otp.Algorithm {
	switch s.config.MFA.TOTPAlgorithm {
	case "SHA256":
		return otp.AlgorithmSHA256
	case "SHA512":
		return otp.AlgorithmSHA512
	default:
		return TOTPAlgorithm
	}
}

func (s *Service) getMFACodeExpiry(method string) time.Duration {
	switch method {
	case MethodSMS:
		if s.config.MFA.SMSCodeExpiry > 0 {
			return s.config.MFA.SMSCodeExpiry
		}
		return 10 * time.Minute
	case MethodEmail:
		if s.config.MFA.EmailCodeExpiry > 0 {
			return s.config.MFA.EmailCodeExpiry
		}
		return 10 * time.Minute
	default:
		return 10 * time.Minute
	}
}

func (s *Service) getBackupCodesCount() int {
	if s.config.MFA.BackupCodesCount > 0 {
		return s.config.MFA.BackupCodesCount
	}
	return 10
}

func (s *Service) getBackupCodesLength() int {
	if s.config.MFA.BackupCodesLength > 0 {
		return s.config.MFA.BackupCodesLength
	}
	return 8
}

// Notification functions (to be implemented with actual providers)

func (s *Service) sendSMSCode(phoneNumber, code string) error {
	// TODO: Implement SMS sending via configured provider
	s.logger.Info("SMS MFA code sent",
		logging.String("phone_number", phoneNumber),
		logging.String("code", code), // Remove in production
	)
	return nil
}

func (s *Service) sendEmailCode(email, code string) error {
	// TODO: Implement email sending via configured provider
	s.logger.Info("Email MFA code sent",
		logging.String("email", email),
		logging.String("code", code), // Remove in production
	)
	return nil
}

// Utility functions for external integrations

// RequiresMFA checks if a user has MFA enabled and requires it for login
func (s *Service) RequiresMFA(ctx context.Context, userID xid.ID) (bool, []string, error) {
	status, err := s.GetMFAStatus(ctx, userID)
	if err != nil {
		return false, nil, err
	}

	if !status.MFAEnabled {
		return false, nil, nil
	}

	// Return list of available methods
	methods := []string{}
	for _, method := range status.Methods {
		if method.Verified {
			methods = append(methods, method.Method)
		}
	}

	return true, methods, nil
}

// ValidateUserMFA validates MFA for a user during login
func (s *Service) ValidateUserMFA(ctx context.Context, userID xid.ID, method, code string) error {
	return s.VerifyCode(ctx, VerifyCodeInput{
		UserID: userID,
		Method: method,
		Code:   code,
	})
}
