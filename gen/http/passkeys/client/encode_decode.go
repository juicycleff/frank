// Code generated by goa v3.20.0, DO NOT EDIT.
//
// passkeys HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	passkeys "github.com/juicycleff/frank/gen/passkeys"
	goahttp "goa.design/goa/v3/http"
)

// BuildRegisterBeginRequest instantiates a HTTP request object with method and
// path set to call the "passkeys" service "register_begin" endpoint
func (c *Client) BuildRegisterBeginRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RegisterBeginPasskeysPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "register_begin", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRegisterBeginRequest returns an encoder for requests sent to the
// passkeys register_begin server.
func EncodeRegisterBeginRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.RegisterBeginPayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "register_begin", "*passkeys.RegisterBeginPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewRegisterBeginRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("passkeys", "register_begin", err)
		}
		return nil
	}
}

// DecodeRegisterBeginResponse returns a decoder for responses returned by the
// passkeys register_begin endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeRegisterBeginResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeRegisterBeginResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RegisterBeginResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			res := NewRegisterBeginResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body RegisterBeginBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			return nil, NewRegisterBeginBadRequest(&body)
		case http.StatusConflict:
			var (
				body RegisterBeginConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			return nil, NewRegisterBeginConflict(&body)
		case http.StatusForbidden:
			var (
				body RegisterBeginForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			return nil, NewRegisterBeginForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body RegisterBeginInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			return nil, NewRegisterBeginInternalError(&body)
		case http.StatusNotFound:
			var (
				body RegisterBeginNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			return nil, NewRegisterBeginNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body RegisterBeginUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_begin", err)
			}
			err = ValidateRegisterBeginUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_begin", err)
			}
			return nil, NewRegisterBeginUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "register_begin", resp.StatusCode, string(body))
		}
	}
}

// BuildRegisterCompleteRequest instantiates a HTTP request object with method
// and path set to call the "passkeys" service "register_complete" endpoint
func (c *Client) BuildRegisterCompleteRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RegisterCompletePasskeysPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "register_complete", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRegisterCompleteRequest returns an encoder for requests sent to the
// passkeys register_complete server.
func EncodeRegisterCompleteRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.RegisterCompletePayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "register_complete", "*passkeys.RegisterCompletePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewRegisterCompleteRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("passkeys", "register_complete", err)
		}
		return nil
	}
}

// DecodeRegisterCompleteResponse returns a decoder for responses returned by
// the passkeys register_complete endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeRegisterCompleteResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeRegisterCompleteResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RegisterCompleteResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			res := NewRegisterCompleteRegisteredPasskeyOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body RegisterCompleteBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			return nil, NewRegisterCompleteBadRequest(&body)
		case http.StatusConflict:
			var (
				body RegisterCompleteConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			return nil, NewRegisterCompleteConflict(&body)
		case http.StatusForbidden:
			var (
				body RegisterCompleteForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			return nil, NewRegisterCompleteForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body RegisterCompleteInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			return nil, NewRegisterCompleteInternalError(&body)
		case http.StatusNotFound:
			var (
				body RegisterCompleteNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			return nil, NewRegisterCompleteNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body RegisterCompleteUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "register_complete", err)
			}
			err = ValidateRegisterCompleteUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "register_complete", err)
			}
			return nil, NewRegisterCompleteUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "register_complete", resp.StatusCode, string(body))
		}
	}
}

// BuildLoginBeginRequest instantiates a HTTP request object with method and
// path set to call the "passkeys" service "login_begin" endpoint
func (c *Client) BuildLoginBeginRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LoginBeginPasskeysPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "login_begin", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLoginBeginRequest returns an encoder for requests sent to the passkeys
// login_begin server.
func EncodeLoginBeginRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.LoginBeginPayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "login_begin", "*passkeys.LoginBeginPayload", v)
		}
		if p.Oauth2 != nil {
			head := *p.Oauth2
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XAPIKey != nil {
			head := *p.XAPIKey
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeLoginBeginResponse returns a decoder for responses returned by the
// passkeys login_begin endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeLoginBeginResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeLoginBeginResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LoginBeginResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			res := NewLoginBeginResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body LoginBeginBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			return nil, NewLoginBeginBadRequest(&body)
		case http.StatusConflict:
			var (
				body LoginBeginConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			return nil, NewLoginBeginConflict(&body)
		case http.StatusForbidden:
			var (
				body LoginBeginForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			return nil, NewLoginBeginForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body LoginBeginInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			return nil, NewLoginBeginInternalError(&body)
		case http.StatusNotFound:
			var (
				body LoginBeginNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			return nil, NewLoginBeginNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body LoginBeginUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_begin", err)
			}
			err = ValidateLoginBeginUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_begin", err)
			}
			return nil, NewLoginBeginUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "login_begin", resp.StatusCode, string(body))
		}
	}
}

// BuildLoginCompleteRequest instantiates a HTTP request object with method and
// path set to call the "passkeys" service "login_complete" endpoint
func (c *Client) BuildLoginCompleteRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LoginCompletePasskeysPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "login_complete", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLoginCompleteRequest returns an encoder for requests sent to the
// passkeys login_complete server.
func EncodeLoginCompleteRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.LoginCompletePayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "login_complete", "*passkeys.LoginCompletePayload", v)
		}
		if p.Oauth2 != nil {
			head := *p.Oauth2
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XAPIKey != nil {
			head := *p.XAPIKey
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewLoginCompleteRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("passkeys", "login_complete", err)
		}
		return nil
	}
}

// DecodeLoginCompleteResponse returns a decoder for responses returned by the
// passkeys login_complete endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeLoginCompleteResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeLoginCompleteResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LoginCompleteResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			res := NewLoginCompleteResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body LoginCompleteBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			return nil, NewLoginCompleteBadRequest(&body)
		case http.StatusConflict:
			var (
				body LoginCompleteConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			return nil, NewLoginCompleteConflict(&body)
		case http.StatusForbidden:
			var (
				body LoginCompleteForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			return nil, NewLoginCompleteForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body LoginCompleteInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			return nil, NewLoginCompleteInternalError(&body)
		case http.StatusNotFound:
			var (
				body LoginCompleteNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			return nil, NewLoginCompleteNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body LoginCompleteUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "login_complete", err)
			}
			err = ValidateLoginCompleteUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "login_complete", err)
			}
			return nil, NewLoginCompleteUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "login_complete", resp.StatusCode, string(body))
		}
	}
}

// BuildListRequest instantiates a HTTP request object with method and path set
// to call the "passkeys" service "list" endpoint
func (c *Client) BuildListRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListPasskeysPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "list", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListRequest returns an encoder for requests sent to the passkeys list
// server.
func EncodeListRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.ListPayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "list", "*passkeys.ListPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeListResponse returns a decoder for responses returned by the passkeys
// list endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeListResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeListResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			res := NewListResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ListBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			return nil, NewListBadRequest(&body)
		case http.StatusConflict:
			var (
				body ListConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			return nil, NewListConflict(&body)
		case http.StatusForbidden:
			var (
				body ListForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			return nil, NewListForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body ListInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			return nil, NewListInternalError(&body)
		case http.StatusNotFound:
			var (
				body ListNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			return nil, NewListNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body ListUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "list", err)
			}
			err = ValidateListUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "list", err)
			}
			return nil, NewListUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "list", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateRequest instantiates a HTTP request object with method and path
// set to call the "passkeys" service "update" endpoint
func (c *Client) BuildUpdateRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*passkeys.UpdatePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("passkeys", "update", "*passkeys.UpdatePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdatePasskeysPath(id)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "update", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateRequest returns an encoder for requests sent to the passkeys
// update server.
func EncodeUpdateRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.UpdatePayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "update", "*passkeys.UpdatePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdateRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("passkeys", "update", err)
		}
		return nil
	}
}

// DecodeUpdateResponse returns a decoder for responses returned by the
// passkeys update endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUpdateResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeUpdateResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			res := NewUpdateResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			return nil, NewUpdateBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			return nil, NewUpdateConflict(&body)
		case http.StatusForbidden:
			var (
				body UpdateForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			return nil, NewUpdateForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			return nil, NewUpdateInternalError(&body)
		case http.StatusNotFound:
			var (
				body UpdateNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			return nil, NewUpdateNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body UpdateUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "update", err)
			}
			err = ValidateUpdateUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "update", err)
			}
			return nil, NewUpdateUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "update", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteRequest instantiates a HTTP request object with method and path
// set to call the "passkeys" service "delete" endpoint
func (c *Client) BuildDeleteRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*passkeys.DeletePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("passkeys", "delete", "*passkeys.DeletePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePasskeysPath(id)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("passkeys", "delete", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteRequest returns an encoder for requests sent to the passkeys
// delete server.
func EncodeDeleteRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*passkeys.DeletePayload)
		if !ok {
			return goahttp.ErrInvalidType("passkeys", "delete", "*passkeys.DeletePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDeleteResponse returns a decoder for responses returned by the
// passkeys delete endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDeleteResponse may return the following errors:
//   - "bad_request" (type *passkeys.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *passkeys.ConflictError): http.StatusConflict
//   - "forbidden" (type *passkeys.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *passkeys.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *passkeys.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *passkeys.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeDeleteResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "delete", err)
			}
			err = ValidateDeleteBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "delete", err)
			}
			return nil, NewDeleteBadRequest(&body)
		case http.StatusConflict:
			var (
				body DeleteConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "delete", err)
			}
			err = ValidateDeleteConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "delete", err)
			}
			return nil, NewDeleteConflict(&body)
		case http.StatusForbidden:
			var (
				body DeleteForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "delete", err)
			}
			err = ValidateDeleteForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "delete", err)
			}
			return nil, NewDeleteForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "delete", err)
			}
			err = ValidateDeleteInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "delete", err)
			}
			return nil, NewDeleteInternalError(&body)
		case http.StatusNotFound:
			var (
				body DeleteNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "delete", err)
			}
			err = ValidateDeleteNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "delete", err)
			}
			return nil, NewDeleteNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body DeleteUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("passkeys", "delete", err)
			}
			err = ValidateDeleteUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("passkeys", "delete", err)
			}
			return nil, NewDeleteUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("passkeys", "delete", resp.StatusCode, string(body))
		}
	}
}

// unmarshalRegisteredPasskeyResponseBodyToPasskeysRegisteredPasskey builds a
// value of type *passkeys.RegisteredPasskey from a value of type
// *RegisteredPasskeyResponseBody.
func unmarshalRegisteredPasskeyResponseBodyToPasskeysRegisteredPasskey(v *RegisteredPasskeyResponseBody) *passkeys.RegisteredPasskey {
	res := &passkeys.RegisteredPasskey{
		ID:           *v.ID,
		Name:         *v.Name,
		DeviceType:   *v.DeviceType,
		RegisteredAt: *v.RegisteredAt,
		LastUsed:     v.LastUsed,
	}

	return res
}

// marshalPasskeysUpdatePasskeyRequestToUpdatePasskeyRequestRequestBody builds
// a value of type *UpdatePasskeyRequestRequestBody from a value of type
// *passkeys.UpdatePasskeyRequest.
func marshalPasskeysUpdatePasskeyRequestToUpdatePasskeyRequestRequestBody(v *passkeys.UpdatePasskeyRequest) *UpdatePasskeyRequestRequestBody {
	res := &UpdatePasskeyRequestRequestBody{
		Name: v.Name,
	}

	return res
}

// marshalUpdatePasskeyRequestRequestBodyToPasskeysUpdatePasskeyRequest builds
// a value of type *passkeys.UpdatePasskeyRequest from a value of type
// *UpdatePasskeyRequestRequestBody.
func marshalUpdatePasskeyRequestRequestBodyToPasskeysUpdatePasskeyRequest(v *UpdatePasskeyRequestRequestBody) *passkeys.UpdatePasskeyRequest {
	res := &passkeys.UpdatePasskeyRequest{
		Name: v.Name,
	}

	return res
}
