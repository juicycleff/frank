// Code generated by goa v3.20.0, DO NOT EDIT.
//
// users HTTP client CLI support package
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	users "github.com/juicycleff/frank/gen/users"
	goa "goa.design/goa/v3/pkg"
)

// BuildListPayload builds the payload for the users list endpoint from CLI
// flags.
func BuildListPayload(usersListOffset string, usersListLimit string, usersListSearch string, usersListOrganizationID string, usersListJWT string) (*users.ListPayload, error) {
	var err error
	var offset int
	{
		if usersListOffset != "" {
			var v int64
			v, err = strconv.ParseInt(usersListOffset, 10, strconv.IntSize)
			offset = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
			if offset < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("offset", offset, 0, true))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var limit int
	{
		if usersListLimit != "" {
			var v int64
			v, err = strconv.ParseInt(usersListLimit, 10, strconv.IntSize)
			limit = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
			if limit < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
			}
			if limit > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var search *string
	{
		if usersListSearch != "" {
			search = &usersListSearch
		}
	}
	var organizationID *string
	{
		if usersListOrganizationID != "" {
			organizationID = &usersListOrganizationID
		}
	}
	var jwt *string
	{
		if usersListJWT != "" {
			jwt = &usersListJWT
		}
	}
	v := &users.ListPayload{}
	v.Offset = offset
	v.Limit = limit
	v.Search = search
	v.OrganizationID = organizationID
	v.JWT = jwt

	return v, nil
}

// BuildCreatePayload builds the payload for the users create endpoint from CLI
// flags.
func BuildCreatePayload(usersCreateBody string, usersCreateJWT string) (*users.CreatePayload, error) {
	var err error
	var body CreateRequestBody
	{
		err = json.Unmarshal([]byte(usersCreateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"user@example.com\",\n      \"first_name\": \"John\",\n      \"last_name\": \"Doe\",\n      \"locale\": \"At nemo deleniti fugit quas rerum quis.\",\n      \"metadata\": {\n         \"Rerum ducimus.\": \"Harum asperiores.\",\n         \"Velit est non aut cumque dicta.\": \"Totam et et voluptate porro consequuntur nobis.\"\n      },\n      \"organization_id\": \"Sapiente in consequatur id.\",\n      \"password\": \"securepassword\",\n      \"phone_number\": \"Qui nihil debitis nihil voluptatem assumenda.\",\n      \"profile_image_url\": \"Necessitatibus aperiam ut in iure.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if body.Password != nil {
			if utf8.RuneCountInString(*body.Password) < 8 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", *body.Password, utf8.RuneCountInString(*body.Password), 8, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var jwt *string
	{
		if usersCreateJWT != "" {
			jwt = &usersCreateJWT
		}
	}
	v := &users.CreatePayload{
		Email:           body.Email,
		Password:        body.Password,
		PhoneNumber:     body.PhoneNumber,
		FirstName:       body.FirstName,
		LastName:        body.LastName,
		ProfileImageURL: body.ProfileImageURL,
		Locale:          body.Locale,
		OrganizationID:  body.OrganizationID,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	{
		var zero string
		if v.Locale == zero {
			v.Locale = "en"
		}
	}
	v.JWT = jwt

	return v, nil
}

// BuildGetPayload builds the payload for the users get endpoint from CLI flags.
func BuildGetPayload(usersGetID string, usersGetJWT string) (*users.GetPayload, error) {
	var id string
	{
		id = usersGetID
	}
	var jwt *string
	{
		if usersGetJWT != "" {
			jwt = &usersGetJWT
		}
	}
	v := &users.GetPayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildUpdatePayload builds the payload for the users update endpoint from CLI
// flags.
func BuildUpdatePayload(usersUpdateBody string, usersUpdateID string, usersUpdateJWT string) (*users.UpdatePayload, error) {
	var err error
	var body UpdateRequestBody
	{
		err = json.Unmarshal([]byte(usersUpdateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"user\": {\n         \"active\": true,\n         \"first_name\": \"Ab nihil itaque quidem.\",\n         \"last_name\": \"Aspernatur qui qui est.\",\n         \"locale\": \"Unde vel sit nihil consequatur aliquam.\",\n         \"metadata\": {\n            \"Eum aspernatur quisquam.\": \"Sint assumenda.\",\n            \"Perspiciatis consequuntur eos voluptas accusantium aliquam.\": \"In odio suscipit corrupti aut sed ipsum.\"\n         },\n         \"phone_number\": \"In fuga.\",\n         \"primary_organization_id\": \"Repudiandae est inventore fuga neque corrupti sit.\",\n         \"profile_image_url\": \"Eum unde omnis est praesentium quaerat.\"\n      }\n   }'")
		}
		if body.User == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("user", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = usersUpdateID
	}
	var jwt *string
	{
		if usersUpdateJWT != "" {
			jwt = &usersUpdateJWT
		}
	}
	v := &users.UpdatePayload{}
	if body.User != nil {
		v.User = marshalUpdateUserRequestRequestBodyToDesigntypesUpdateUserRequest(body.User)
	}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildDeletePayload builds the payload for the users delete endpoint from CLI
// flags.
func BuildDeletePayload(usersDeleteID string, usersDeleteJWT string) (*users.DeletePayload, error) {
	var id string
	{
		id = usersDeleteID
	}
	var jwt *string
	{
		if usersDeleteJWT != "" {
			jwt = &usersDeleteJWT
		}
	}
	v := &users.DeletePayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildUpdateMePayload builds the payload for the users update_me endpoint
// from CLI flags.
func BuildUpdateMePayload(usersUpdateMeBody string, usersUpdateMeJWT string) (*users.UpdateMePayload, error) {
	var err error
	var body UpdateMeRequestBody
	{
		err = json.Unmarshal([]byte(usersUpdateMeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"active\": false,\n      \"first_name\": \"Totam voluptatem.\",\n      \"last_name\": \"Consequatur perferendis.\",\n      \"locale\": \"Magni aut aperiam enim dolorem.\",\n      \"metadata\": {\n         \"Asperiores aut dignissimos repellat.\": \"Eveniet hic voluptas minus.\",\n         \"Facere labore nobis.\": \"Minima omnis voluptas distinctio veniam enim mollitia.\"\n      },\n      \"phone_number\": \"Doloremque unde numquam pariatur officia molestiae corporis.\",\n      \"primary_organization_id\": \"Aut reiciendis sit.\",\n      \"profile_image_url\": \"Dolores rerum numquam.\"\n   }'")
		}
	}
	var jwt *string
	{
		if usersUpdateMeJWT != "" {
			jwt = &usersUpdateMeJWT
		}
	}
	v := &users.UpdateMePayload{
		PhoneNumber:           body.PhoneNumber,
		FirstName:             body.FirstName,
		LastName:              body.LastName,
		ProfileImageURL:       body.ProfileImageURL,
		Locale:                body.Locale,
		Active:                body.Active,
		PrimaryOrganizationID: body.PrimaryOrganizationID,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	v.JWT = jwt

	return v, nil
}

// BuildUpdatePasswordPayload builds the payload for the users update_password
// endpoint from CLI flags.
func BuildUpdatePasswordPayload(usersUpdatePasswordBody string, usersUpdatePasswordJWT string) (*users.UpdatePasswordPayload, error) {
	var err error
	var body UpdatePasswordRequestBody
	{
		err = json.Unmarshal([]byte(usersUpdatePasswordBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"current_password\": \"oldpassword\",\n      \"new_password\": \"newpassword\"\n   }'")
		}
		if utf8.RuneCountInString(body.NewPassword) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.new_password", body.NewPassword, utf8.RuneCountInString(body.NewPassword), 8, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var jwt *string
	{
		if usersUpdatePasswordJWT != "" {
			jwt = &usersUpdatePasswordJWT
		}
	}
	v := &users.UpdatePasswordPayload{
		CurrentPassword: body.CurrentPassword,
		NewPassword:     body.NewPassword,
	}
	v.JWT = jwt

	return v, nil
}

// BuildGetSessionsPayload builds the payload for the users get_sessions
// endpoint from CLI flags.
func BuildGetSessionsPayload(usersGetSessionsJWT string) (*users.GetSessionsPayload, error) {
	var jwt *string
	{
		if usersGetSessionsJWT != "" {
			jwt = &usersGetSessionsJWT
		}
	}
	v := &users.GetSessionsPayload{}
	v.JWT = jwt

	return v, nil
}

// BuildDeleteSessionPayload builds the payload for the users delete_session
// endpoint from CLI flags.
func BuildDeleteSessionPayload(usersDeleteSessionSessionID string, usersDeleteSessionJWT string) (*users.DeleteSessionPayload, error) {
	var sessionID string
	{
		sessionID = usersDeleteSessionSessionID
	}
	var jwt *string
	{
		if usersDeleteSessionJWT != "" {
			jwt = &usersDeleteSessionJWT
		}
	}
	v := &users.DeleteSessionPayload{}
	v.SessionID = sessionID
	v.JWT = jwt

	return v, nil
}

// BuildGetOrganizationsPayload builds the payload for the users
// get_organizations endpoint from CLI flags.
func BuildGetOrganizationsPayload(usersGetOrganizationsID string, usersGetOrganizationsJWT string) (*users.GetOrganizationsPayload, error) {
	var id string
	{
		id = usersGetOrganizationsID
	}
	var jwt *string
	{
		if usersGetOrganizationsJWT != "" {
			jwt = &usersGetOrganizationsJWT
		}
	}
	v := &users.GetOrganizationsPayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}
