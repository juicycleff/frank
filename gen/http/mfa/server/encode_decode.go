// Code generated by goa v3.20.0, DO NOT EDIT.
//
// mfa HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strings"

	designtypes "github.com/juicycleff/frank/gen/designtypes"
	mfa "github.com/juicycleff/frank/gen/mfa"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeEnrollResponse returns an encoder for responses returned by the mfa
// enroll endpoint.
func EncodeEnrollResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*mfa.EnrollResult)
		enc := encoder(ctx, w)
		body := NewEnrollResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeEnrollRequest returns a decoder for requests sent to the mfa enroll
// endpoint.
func DecodeEnrollRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body EnrollRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateEnrollRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewEnrollPayload(&body, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeEnrollError returns an encoder for errors returned by the enroll mfa
// endpoint.
func EncodeEnrollError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *mfa.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewEnrollBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			var res *mfa.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewEnrollForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *mfa.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewEnrollInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *mfa.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewEnrollNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *mfa.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewEnrollUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeVerifyResponse returns an encoder for responses returned by the mfa
// verify endpoint.
func EncodeVerifyResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*mfa.VerifyResult)
		enc := encoder(ctx, w)
		body := NewVerifyResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeVerifyRequest returns a decoder for requests sent to the mfa verify
// endpoint.
func DecodeVerifyRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body VerifyRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateVerifyRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewVerifyPayload(&body, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeVerifyError returns an encoder for errors returned by the verify mfa
// endpoint.
func EncodeVerifyError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *mfa.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVerifyBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			var res *mfa.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVerifyForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *mfa.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVerifyInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *mfa.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVerifyNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *mfa.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewVerifyUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUnenrollResponse returns an encoder for responses returned by the mfa
// unenroll endpoint.
func EncodeUnenrollResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*mfa.UnenrollResult)
		enc := encoder(ctx, w)
		body := NewUnenrollResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUnenrollRequest returns a decoder for requests sent to the mfa
// unenroll endpoint.
func DecodeUnenrollRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UnenrollRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUnenrollRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewUnenrollPayload(&body, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUnenrollError returns an encoder for errors returned by the unenroll
// mfa endpoint.
func EncodeUnenrollError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *mfa.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUnenrollBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			var res *mfa.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUnenrollForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *mfa.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUnenrollInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *mfa.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUnenrollNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *mfa.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUnenrollUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeMethodsResponse returns an encoder for responses returned by the mfa
// methods endpoint.
func EncodeMethodsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*mfa.MethodsResult)
		enc := encoder(ctx, w)
		body := NewMethodsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeMethodsRequest returns a decoder for requests sent to the mfa methods
// endpoint.
func DecodeMethodsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewMethodsPayload(jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeMethodsError returns an encoder for errors returned by the methods mfa
// endpoint.
func EncodeMethodsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *mfa.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewMethodsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			var res *mfa.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewMethodsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *mfa.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewMethodsInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *mfa.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewMethodsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *mfa.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewMethodsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSendCodeResponse returns an encoder for responses returned by the mfa
// send_code endpoint.
func EncodeSendCodeResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*mfa.SendCodeResult)
		enc := encoder(ctx, w)
		body := NewSendCodeResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSendCodeRequest returns a decoder for requests sent to the mfa
// send_code endpoint.
func DecodeSendCodeRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body SendCodeRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSendCodeRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewSendCodePayload(&body, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeSendCodeError returns an encoder for errors returned by the send_code
// mfa endpoint.
func EncodeSendCodeError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *mfa.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSendCodeBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			var res *mfa.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSendCodeForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *mfa.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSendCodeInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *mfa.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSendCodeNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *mfa.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSendCodeUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// unmarshalMFAEnrollRequestRequestBodyToDesigntypesMFAEnrollRequest builds a
// value of type *designtypes.MFAEnrollRequest from a value of type
// *MFAEnrollRequestRequestBody.
func unmarshalMFAEnrollRequestRequestBodyToDesigntypesMFAEnrollRequest(v *MFAEnrollRequestRequestBody) *designtypes.MFAEnrollRequest {
	res := &designtypes.MFAEnrollRequest{
		Method:      *v.Method,
		PhoneNumber: v.PhoneNumber,
		Email:       v.Email,
	}

	return res
}

// marshalDesigntypesTOTPEnrollResponseToTOTPEnrollResponseResponseBody builds
// a value of type *TOTPEnrollResponseResponseBody from a value of type
// *designtypes.TOTPEnrollResponse.
func marshalDesigntypesTOTPEnrollResponseToTOTPEnrollResponseResponseBody(v *designtypes.TOTPEnrollResponse) *TOTPEnrollResponseResponseBody {
	if v == nil {
		return nil
	}
	res := &TOTPEnrollResponseResponseBody{
		Secret:     v.Secret,
		URI:        v.URI,
		QrCodeData: v.QrCodeData,
	}

	return res
}

// marshalDesigntypesBackupCodesResponseToBackupCodesResponseResponseBody
// builds a value of type *BackupCodesResponseResponseBody from a value of type
// *designtypes.BackupCodesResponse.
func marshalDesigntypesBackupCodesResponseToBackupCodesResponseResponseBody(v *designtypes.BackupCodesResponse) *BackupCodesResponseResponseBody {
	if v == nil {
		return nil
	}
	res := &BackupCodesResponseResponseBody{}
	if v.BackupCodes != nil {
		res.BackupCodes = make([]string, len(v.BackupCodes))
		for i, val := range v.BackupCodes {
			res.BackupCodes[i] = val
		}
	} else {
		res.BackupCodes = []string{}
	}

	return res
}

// unmarshalMFAVerifyRequestRequestBodyToDesigntypesMFAVerifyRequest builds a
// value of type *designtypes.MFAVerifyRequest from a value of type
// *MFAVerifyRequestRequestBody.
func unmarshalMFAVerifyRequestRequestBodyToDesigntypesMFAVerifyRequest(v *MFAVerifyRequestRequestBody) *designtypes.MFAVerifyRequest {
	res := &designtypes.MFAVerifyRequest{
		Method:      *v.Method,
		Code:        *v.Code,
		PhoneNumber: v.PhoneNumber,
	}

	return res
}

// unmarshalMFAUnEnrollRequestRequestBodyToDesigntypesMFAUnEnrollRequest builds
// a value of type *designtypes.MFAUnEnrollRequest from a value of type
// *MFAUnEnrollRequestRequestBody.
func unmarshalMFAUnEnrollRequestRequestBodyToDesigntypesMFAUnEnrollRequest(v *MFAUnEnrollRequestRequestBody) *designtypes.MFAUnEnrollRequest {
	res := &designtypes.MFAUnEnrollRequest{
		Method: *v.Method,
	}

	return res
}

// unmarshalSendMFACodeRequestRequestBodyToDesigntypesSendMFACodeRequest builds
// a value of type *designtypes.SendMFACodeRequest from a value of type
// *SendMFACodeRequestRequestBody.
func unmarshalSendMFACodeRequestRequestBodyToDesigntypesSendMFACodeRequest(v *SendMFACodeRequestRequestBody) *designtypes.SendMFACodeRequest {
	res := &designtypes.SendMFACodeRequest{
		Method: *v.Method,
	}

	return res
}
