// Code generated by goa v3.20.0, DO NOT EDIT.
//
// rbac HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	designtypes "github.com/juicycleff/frank/gen/designtypes"
	rbac "github.com/juicycleff/frank/gen/rbac"
	goahttp "goa.design/goa/v3/http"
)

// BuildListPermissionsRequest instantiates a HTTP request object with method
// and path set to call the "rbac" service "list_permissions" endpoint
func (c *Client) BuildListPermissionsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListPermissionsRbacPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "list_permissions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListPermissionsRequest returns an encoder for requests sent to the
// rbac list_permissions server.
func EncodeListPermissionsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.ListPermissionsPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "list_permissions", "*rbac.ListPermissionsPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("offset", fmt.Sprintf("%v", p.Offset))
		values.Add("limit", fmt.Sprintf("%v", p.Limit))
		if p.Resource != nil {
			values.Add("resource", *p.Resource)
		}
		if p.Action != nil {
			values.Add("action", *p.Action)
		}
		if p.Search != nil {
			values.Add("search", *p.Search)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListPermissionsResponse returns a decoder for responses returned by
// the rbac list_permissions endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListPermissionsResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeListPermissionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListPermissionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			res := NewListPermissionsResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ListPermissionsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			return nil, NewListPermissionsBadRequest(&body)
		case http.StatusConflict:
			var (
				body ListPermissionsConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			return nil, NewListPermissionsConflict(&body)
		case http.StatusForbidden:
			var (
				body ListPermissionsForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			return nil, NewListPermissionsForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body ListPermissionsInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			return nil, NewListPermissionsInternalError(&body)
		case http.StatusNotFound:
			var (
				body ListPermissionsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			return nil, NewListPermissionsNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body ListPermissionsUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_permissions", err)
			}
			err = ValidateListPermissionsUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_permissions", err)
			}
			return nil, NewListPermissionsUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "list_permissions", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePermissionRequest instantiates a HTTP request object with method
// and path set to call the "rbac" service "create_permission" endpoint
func (c *Client) BuildCreatePermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePermissionRbacPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "create_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePermissionRequest returns an encoder for requests sent to the
// rbac create_permission server.
func EncodeCreatePermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.CreatePermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "create_permission", "*rbac.CreatePermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCreatePermissionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("rbac", "create_permission", err)
		}
		return nil
	}
}

// DecodeCreatePermissionResponse returns a decoder for responses returned by
// the rbac create_permission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreatePermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeCreatePermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreatePermissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			res := NewCreatePermissionPermissionResponseCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreatePermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			return nil, NewCreatePermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreatePermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			return nil, NewCreatePermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body CreatePermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			return nil, NewCreatePermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body CreatePermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			return nil, NewCreatePermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body CreatePermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			return nil, NewCreatePermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body CreatePermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_permission", err)
			}
			err = ValidateCreatePermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_permission", err)
			}
			return nil, NewCreatePermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "create_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPermissionRequest instantiates a HTTP request object with method and
// path set to call the "rbac" service "get_permission" endpoint
func (c *Client) BuildGetPermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.GetPermissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "get_permission", "*rbac.GetPermissionPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPermissionRbacPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "get_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPermissionRequest returns an encoder for requests sent to the rbac
// get_permission server.
func EncodeGetPermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.GetPermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "get_permission", "*rbac.GetPermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeGetPermissionResponse returns a decoder for responses returned by the
// rbac get_permission endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetPermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeGetPermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPermissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			res := NewGetPermissionPermissionResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetPermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			return nil, NewGetPermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body GetPermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			return nil, NewGetPermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body GetPermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			return nil, NewGetPermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body GetPermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			return nil, NewGetPermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body GetPermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			return nil, NewGetPermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body GetPermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_permission", err)
			}
			err = ValidateGetPermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_permission", err)
			}
			return nil, NewGetPermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "get_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdatePermissionRequest instantiates a HTTP request object with method
// and path set to call the "rbac" service "update_permission" endpoint
func (c *Client) BuildUpdatePermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.UpdatePermissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "update_permission", "*rbac.UpdatePermissionPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdatePermissionRbacPath(id)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "update_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdatePermissionRequest returns an encoder for requests sent to the
// rbac update_permission server.
func EncodeUpdatePermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.UpdatePermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "update_permission", "*rbac.UpdatePermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdatePermissionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("rbac", "update_permission", err)
		}
		return nil
	}
}

// DecodeUpdatePermissionResponse returns a decoder for responses returned by
// the rbac update_permission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeUpdatePermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeUpdatePermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdatePermissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			res := NewUpdatePermissionPermissionResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdatePermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			return nil, NewUpdatePermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdatePermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			return nil, NewUpdatePermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body UpdatePermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			return nil, NewUpdatePermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body UpdatePermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			return nil, NewUpdatePermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body UpdatePermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			return nil, NewUpdatePermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body UpdatePermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_permission", err)
			}
			err = ValidateUpdatePermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_permission", err)
			}
			return nil, NewUpdatePermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "update_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildDeletePermissionRequest instantiates a HTTP request object with method
// and path set to call the "rbac" service "delete_permission" endpoint
func (c *Client) BuildDeletePermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.DeletePermissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "delete_permission", "*rbac.DeletePermissionPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePermissionRbacPath(id)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "delete_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeletePermissionRequest returns an encoder for requests sent to the
// rbac delete_permission server.
func EncodeDeletePermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.DeletePermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "delete_permission", "*rbac.DeletePermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDeletePermissionResponse returns a decoder for responses returned by
// the rbac delete_permission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeletePermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeDeletePermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeletePermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_permission", err)
			}
			err = ValidateDeletePermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_permission", err)
			}
			return nil, NewDeletePermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body DeletePermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_permission", err)
			}
			err = ValidateDeletePermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_permission", err)
			}
			return nil, NewDeletePermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body DeletePermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_permission", err)
			}
			err = ValidateDeletePermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_permission", err)
			}
			return nil, NewDeletePermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body DeletePermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_permission", err)
			}
			err = ValidateDeletePermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_permission", err)
			}
			return nil, NewDeletePermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body DeletePermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_permission", err)
			}
			err = ValidateDeletePermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_permission", err)
			}
			return nil, NewDeletePermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body DeletePermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_permission", err)
			}
			err = ValidateDeletePermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_permission", err)
			}
			return nil, NewDeletePermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "delete_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildListRolesRequest instantiates a HTTP request object with method and
// path set to call the "rbac" service "list_roles" endpoint
func (c *Client) BuildListRolesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListRolesRbacPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "list_roles", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListRolesRequest returns an encoder for requests sent to the rbac
// list_roles server.
func EncodeListRolesRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.ListRolesPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "list_roles", "*rbac.ListRolesPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("offset", fmt.Sprintf("%v", p.Offset))
		values.Add("limit", fmt.Sprintf("%v", p.Limit))
		if p.OrganizationID != nil {
			values.Add("organization_id", *p.OrganizationID)
		}
		if p.Search != nil {
			values.Add("search", *p.Search)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListRolesResponse returns a decoder for responses returned by the rbac
// list_roles endpoint. restoreBody controls whether the response body should
// be restored after having been read.
// DecodeListRolesResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeListRolesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListRolesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			res := NewListRolesResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ListRolesBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			return nil, NewListRolesBadRequest(&body)
		case http.StatusConflict:
			var (
				body ListRolesConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			return nil, NewListRolesConflict(&body)
		case http.StatusForbidden:
			var (
				body ListRolesForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			return nil, NewListRolesForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body ListRolesInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			return nil, NewListRolesInternalError(&body)
		case http.StatusNotFound:
			var (
				body ListRolesNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			return nil, NewListRolesNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body ListRolesUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_roles", err)
			}
			err = ValidateListRolesUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_roles", err)
			}
			return nil, NewListRolesUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "list_roles", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateRoleRequest instantiates a HTTP request object with method and
// path set to call the "rbac" service "create_role" endpoint
func (c *Client) BuildCreateRoleRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateRoleRbacPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "create_role", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateRoleRequest returns an encoder for requests sent to the rbac
// create_role server.
func EncodeCreateRoleRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.CreateRolePayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "create_role", "*rbac.CreateRolePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCreateRoleRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("rbac", "create_role", err)
		}
		return nil
	}
}

// DecodeCreateRoleResponse returns a decoder for responses returned by the
// rbac create_role endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeCreateRoleResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeCreateRoleResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateRoleResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			res := NewCreateRoleRoleResponseCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateRoleBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			return nil, NewCreateRoleBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateRoleConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			return nil, NewCreateRoleConflict(&body)
		case http.StatusForbidden:
			var (
				body CreateRoleForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			return nil, NewCreateRoleForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body CreateRoleInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			return nil, NewCreateRoleInternalError(&body)
		case http.StatusNotFound:
			var (
				body CreateRoleNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			return nil, NewCreateRoleNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body CreateRoleUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "create_role", err)
			}
			err = ValidateCreateRoleUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "create_role", err)
			}
			return nil, NewCreateRoleUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "create_role", resp.StatusCode, string(body))
		}
	}
}

// BuildGetRoleRequest instantiates a HTTP request object with method and path
// set to call the "rbac" service "get_role" endpoint
func (c *Client) BuildGetRoleRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.GetRolePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "get_role", "*rbac.GetRolePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetRoleRbacPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "get_role", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetRoleRequest returns an encoder for requests sent to the rbac
// get_role server.
func EncodeGetRoleRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.GetRolePayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "get_role", "*rbac.GetRolePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeGetRoleResponse returns a decoder for responses returned by the rbac
// get_role endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeGetRoleResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeGetRoleResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetRoleResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			res := NewGetRoleRoleResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetRoleBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			return nil, NewGetRoleBadRequest(&body)
		case http.StatusConflict:
			var (
				body GetRoleConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			return nil, NewGetRoleConflict(&body)
		case http.StatusForbidden:
			var (
				body GetRoleForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			return nil, NewGetRoleForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body GetRoleInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			return nil, NewGetRoleInternalError(&body)
		case http.StatusNotFound:
			var (
				body GetRoleNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			return nil, NewGetRoleNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body GetRoleUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "get_role", err)
			}
			err = ValidateGetRoleUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "get_role", err)
			}
			return nil, NewGetRoleUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "get_role", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateRoleRequest instantiates a HTTP request object with method and
// path set to call the "rbac" service "update_role" endpoint
func (c *Client) BuildUpdateRoleRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.UpdateRolePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "update_role", "*rbac.UpdateRolePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateRoleRbacPath(id)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "update_role", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateRoleRequest returns an encoder for requests sent to the rbac
// update_role server.
func EncodeUpdateRoleRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.UpdateRolePayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "update_role", "*rbac.UpdateRolePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdateRoleRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("rbac", "update_role", err)
		}
		return nil
	}
}

// DecodeUpdateRoleResponse returns a decoder for responses returned by the
// rbac update_role endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUpdateRoleResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeUpdateRoleResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateRoleResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			res := NewUpdateRoleRoleResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateRoleBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			return nil, NewUpdateRoleBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateRoleConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			return nil, NewUpdateRoleConflict(&body)
		case http.StatusForbidden:
			var (
				body UpdateRoleForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			return nil, NewUpdateRoleForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateRoleInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			return nil, NewUpdateRoleInternalError(&body)
		case http.StatusNotFound:
			var (
				body UpdateRoleNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			return nil, NewUpdateRoleNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body UpdateRoleUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "update_role", err)
			}
			err = ValidateUpdateRoleUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "update_role", err)
			}
			return nil, NewUpdateRoleUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "update_role", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteRoleRequest instantiates a HTTP request object with method and
// path set to call the "rbac" service "delete_role" endpoint
func (c *Client) BuildDeleteRoleRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.DeleteRolePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "delete_role", "*rbac.DeleteRolePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteRoleRbacPath(id)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "delete_role", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteRoleRequest returns an encoder for requests sent to the rbac
// delete_role server.
func EncodeDeleteRoleRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.DeleteRolePayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "delete_role", "*rbac.DeleteRolePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDeleteRoleResponse returns a decoder for responses returned by the
// rbac delete_role endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDeleteRoleResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeDeleteRoleResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteRoleBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_role", err)
			}
			err = ValidateDeleteRoleBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_role", err)
			}
			return nil, NewDeleteRoleBadRequest(&body)
		case http.StatusConflict:
			var (
				body DeleteRoleConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_role", err)
			}
			err = ValidateDeleteRoleConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_role", err)
			}
			return nil, NewDeleteRoleConflict(&body)
		case http.StatusForbidden:
			var (
				body DeleteRoleForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_role", err)
			}
			err = ValidateDeleteRoleForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_role", err)
			}
			return nil, NewDeleteRoleForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteRoleInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_role", err)
			}
			err = ValidateDeleteRoleInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_role", err)
			}
			return nil, NewDeleteRoleInternalError(&body)
		case http.StatusNotFound:
			var (
				body DeleteRoleNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_role", err)
			}
			err = ValidateDeleteRoleNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_role", err)
			}
			return nil, NewDeleteRoleNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body DeleteRoleUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "delete_role", err)
			}
			err = ValidateDeleteRoleUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "delete_role", err)
			}
			return nil, NewDeleteRoleUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "delete_role", resp.StatusCode, string(body))
		}
	}
}

// BuildListRolePermissionsRequest instantiates a HTTP request object with
// method and path set to call the "rbac" service "list_role_permissions"
// endpoint
func (c *Client) BuildListRolePermissionsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.ListRolePermissionsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "list_role_permissions", "*rbac.ListRolePermissionsPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListRolePermissionsRbacPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "list_role_permissions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListRolePermissionsRequest returns an encoder for requests sent to the
// rbac list_role_permissions server.
func EncodeListRolePermissionsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.ListRolePermissionsPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "list_role_permissions", "*rbac.ListRolePermissionsPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeListRolePermissionsResponse returns a decoder for responses returned
// by the rbac list_role_permissions endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListRolePermissionsResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeListRolePermissionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListRolePermissionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			res := NewListRolePermissionsResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ListRolePermissionsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			return nil, NewListRolePermissionsBadRequest(&body)
		case http.StatusConflict:
			var (
				body ListRolePermissionsConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			return nil, NewListRolePermissionsConflict(&body)
		case http.StatusForbidden:
			var (
				body ListRolePermissionsForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			return nil, NewListRolePermissionsForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body ListRolePermissionsInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			return nil, NewListRolePermissionsInternalError(&body)
		case http.StatusNotFound:
			var (
				body ListRolePermissionsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			return nil, NewListRolePermissionsNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body ListRolePermissionsUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "list_role_permissions", err)
			}
			err = ValidateListRolePermissionsUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "list_role_permissions", err)
			}
			return nil, NewListRolePermissionsUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "list_role_permissions", resp.StatusCode, string(body))
		}
	}
}

// BuildAddRolePermissionRequest instantiates a HTTP request object with method
// and path set to call the "rbac" service "add_role_permission" endpoint
func (c *Client) BuildAddRolePermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*rbac.AddRolePermissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "add_role_permission", "*rbac.AddRolePermissionPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AddRolePermissionRbacPath(id)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "add_role_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAddRolePermissionRequest returns an encoder for requests sent to the
// rbac add_role_permission server.
func EncodeAddRolePermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.AddRolePermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "add_role_permission", "*rbac.AddRolePermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewAddRolePermissionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("rbac", "add_role_permission", err)
		}
		return nil
	}
}

// DecodeAddRolePermissionResponse returns a decoder for responses returned by
// the rbac add_role_permission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeAddRolePermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeAddRolePermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AddRolePermissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			res := NewAddRolePermissionResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body AddRolePermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			return nil, NewAddRolePermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body AddRolePermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			return nil, NewAddRolePermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body AddRolePermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			return nil, NewAddRolePermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body AddRolePermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			return nil, NewAddRolePermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body AddRolePermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			return nil, NewAddRolePermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body AddRolePermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "add_role_permission", err)
			}
			err = ValidateAddRolePermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "add_role_permission", err)
			}
			return nil, NewAddRolePermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "add_role_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildRemoveRolePermissionRequest instantiates a HTTP request object with
// method and path set to call the "rbac" service "remove_role_permission"
// endpoint
func (c *Client) BuildRemoveRolePermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		id           string
		permissionID string
	)
	{
		p, ok := v.(*rbac.RemoveRolePermissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("rbac", "remove_role_permission", "*rbac.RemoveRolePermissionPayload", v)
		}
		id = p.ID
		permissionID = p.PermissionID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RemoveRolePermissionRbacPath(id, permissionID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "remove_role_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRemoveRolePermissionRequest returns an encoder for requests sent to
// the rbac remove_role_permission server.
func EncodeRemoveRolePermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.RemoveRolePermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "remove_role_permission", "*rbac.RemoveRolePermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeRemoveRolePermissionResponse returns a decoder for responses returned
// by the rbac remove_role_permission endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeRemoveRolePermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeRemoveRolePermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body RemoveRolePermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "remove_role_permission", err)
			}
			err = ValidateRemoveRolePermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "remove_role_permission", err)
			}
			return nil, NewRemoveRolePermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body RemoveRolePermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "remove_role_permission", err)
			}
			err = ValidateRemoveRolePermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "remove_role_permission", err)
			}
			return nil, NewRemoveRolePermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body RemoveRolePermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "remove_role_permission", err)
			}
			err = ValidateRemoveRolePermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "remove_role_permission", err)
			}
			return nil, NewRemoveRolePermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body RemoveRolePermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "remove_role_permission", err)
			}
			err = ValidateRemoveRolePermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "remove_role_permission", err)
			}
			return nil, NewRemoveRolePermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body RemoveRolePermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "remove_role_permission", err)
			}
			err = ValidateRemoveRolePermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "remove_role_permission", err)
			}
			return nil, NewRemoveRolePermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body RemoveRolePermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "remove_role_permission", err)
			}
			err = ValidateRemoveRolePermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "remove_role_permission", err)
			}
			return nil, NewRemoveRolePermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "remove_role_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildCheckPermissionRequest instantiates a HTTP request object with method
// and path set to call the "rbac" service "check_permission" endpoint
func (c *Client) BuildCheckPermissionRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CheckPermissionRbacPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "check_permission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCheckPermissionRequest returns an encoder for requests sent to the
// rbac check_permission server.
func EncodeCheckPermissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.CheckPermissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "check_permission", "*rbac.CheckPermissionPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("resource", p.Resource)
		values.Add("action", p.Action)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeCheckPermissionResponse returns a decoder for responses returned by
// the rbac check_permission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCheckPermissionResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeCheckPermissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CheckPermissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			res := NewCheckPermissionResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CheckPermissionBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			return nil, NewCheckPermissionBadRequest(&body)
		case http.StatusConflict:
			var (
				body CheckPermissionConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			return nil, NewCheckPermissionConflict(&body)
		case http.StatusForbidden:
			var (
				body CheckPermissionForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			return nil, NewCheckPermissionForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body CheckPermissionInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			return nil, NewCheckPermissionInternalError(&body)
		case http.StatusNotFound:
			var (
				body CheckPermissionNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			return nil, NewCheckPermissionNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body CheckPermissionUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_permission", err)
			}
			err = ValidateCheckPermissionUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_permission", err)
			}
			return nil, NewCheckPermissionUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "check_permission", resp.StatusCode, string(body))
		}
	}
}

// BuildCheckRoleRequest instantiates a HTTP request object with method and
// path set to call the "rbac" service "check_role" endpoint
func (c *Client) BuildCheckRoleRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CheckRoleRbacPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("rbac", "check_role", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCheckRoleRequest returns an encoder for requests sent to the rbac
// check_role server.
func EncodeCheckRoleRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*rbac.CheckRolePayload)
		if !ok {
			return goahttp.ErrInvalidType("rbac", "check_role", "*rbac.CheckRolePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("role", p.Role)
		if p.OrganizationID != nil {
			values.Add("organization_id", *p.OrganizationID)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeCheckRoleResponse returns a decoder for responses returned by the rbac
// check_role endpoint. restoreBody controls whether the response body should
// be restored after having been read.
// DecodeCheckRoleResponse may return the following errors:
//   - "bad_request" (type *rbac.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *rbac.ConflictError): http.StatusConflict
//   - "forbidden" (type *rbac.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *rbac.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *rbac.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *rbac.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeCheckRoleResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CheckRoleResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			res := NewCheckRoleResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CheckRoleBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			return nil, NewCheckRoleBadRequest(&body)
		case http.StatusConflict:
			var (
				body CheckRoleConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			return nil, NewCheckRoleConflict(&body)
		case http.StatusForbidden:
			var (
				body CheckRoleForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			return nil, NewCheckRoleForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body CheckRoleInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			return nil, NewCheckRoleInternalError(&body)
		case http.StatusNotFound:
			var (
				body CheckRoleNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			return nil, NewCheckRoleNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body CheckRoleUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("rbac", "check_role", err)
			}
			err = ValidateCheckRoleUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("rbac", "check_role", err)
			}
			return nil, NewCheckRoleUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("rbac", "check_role", resp.StatusCode, string(body))
		}
	}
}

// unmarshalPermissionResponseResponseBodyToDesigntypesPermissionResponse
// builds a value of type *designtypes.PermissionResponse from a value of type
// *PermissionResponseResponseBody.
func unmarshalPermissionResponseResponseBodyToDesigntypesPermissionResponse(v *PermissionResponseResponseBody) *designtypes.PermissionResponse {
	res := &designtypes.PermissionResponse{
		ID:          *v.ID,
		Name:        *v.Name,
		Description: *v.Description,
		Resource:    *v.Resource,
		Action:      *v.Action,
		Conditions:  v.Conditions,
		System:      *v.System,
		CreatedAt:   *v.CreatedAt,
		UpdatedAt:   v.UpdatedAt,
	}

	return res
}

// unmarshalPaginationResponseBodyToDesigntypesPagination builds a value of
// type *designtypes.Pagination from a value of type *PaginationResponseBody.
func unmarshalPaginationResponseBodyToDesigntypesPagination(v *PaginationResponseBody) *designtypes.Pagination {
	res := &designtypes.Pagination{
		Offset:      *v.Offset,
		Limit:       *v.Limit,
		Total:       *v.Total,
		TotalPages:  *v.TotalPages,
		CurrentPage: *v.CurrentPage,
		HasNext:     *v.HasNext,
		HasPrevious: *v.HasPrevious,
	}

	return res
}

// marshalRbacCreatePermissionRequestToCreatePermissionRequestRequestBody
// builds a value of type *CreatePermissionRequestRequestBody from a value of
// type *rbac.CreatePermissionRequest.
func marshalRbacCreatePermissionRequestToCreatePermissionRequestRequestBody(v *rbac.CreatePermissionRequest) *CreatePermissionRequestRequestBody {
	res := &CreatePermissionRequestRequestBody{
		Name:        v.Name,
		Description: v.Description,
		Resource:    v.Resource,
		Action:      v.Action,
		Conditions:  v.Conditions,
	}

	return res
}

// marshalCreatePermissionRequestRequestBodyToRbacCreatePermissionRequest
// builds a value of type *rbac.CreatePermissionRequest from a value of type
// *CreatePermissionRequestRequestBody.
func marshalCreatePermissionRequestRequestBodyToRbacCreatePermissionRequest(v *CreatePermissionRequestRequestBody) *rbac.CreatePermissionRequest {
	res := &rbac.CreatePermissionRequest{
		Name:        v.Name,
		Description: v.Description,
		Resource:    v.Resource,
		Action:      v.Action,
		Conditions:  v.Conditions,
	}

	return res
}

// marshalRbacUpdatePermissionRequestToUpdatePermissionRequestRequestBody
// builds a value of type *UpdatePermissionRequestRequestBody from a value of
// type *rbac.UpdatePermissionRequest.
func marshalRbacUpdatePermissionRequestToUpdatePermissionRequestRequestBody(v *rbac.UpdatePermissionRequest) *UpdatePermissionRequestRequestBody {
	res := &UpdatePermissionRequestRequestBody{
		Name:        v.Name,
		Description: v.Description,
		Conditions:  v.Conditions,
	}

	return res
}

// marshalUpdatePermissionRequestRequestBodyToRbacUpdatePermissionRequest
// builds a value of type *rbac.UpdatePermissionRequest from a value of type
// *UpdatePermissionRequestRequestBody.
func marshalUpdatePermissionRequestRequestBodyToRbacUpdatePermissionRequest(v *UpdatePermissionRequestRequestBody) *rbac.UpdatePermissionRequest {
	res := &rbac.UpdatePermissionRequest{
		Name:        v.Name,
		Description: v.Description,
		Conditions:  v.Conditions,
	}

	return res
}

// unmarshalRoleResponseResponseBodyToDesigntypesRoleResponse builds a value of
// type *designtypes.RoleResponse from a value of type
// *RoleResponseResponseBody.
func unmarshalRoleResponseResponseBodyToDesigntypesRoleResponse(v *RoleResponseResponseBody) *designtypes.RoleResponse {
	res := &designtypes.RoleResponse{
		ID:             *v.ID,
		Name:           *v.Name,
		Description:    v.Description,
		OrganizationID: v.OrganizationID,
		System:         *v.System,
		IsDefault:      *v.IsDefault,
		CreatedAt:      *v.CreatedAt,
		UpdatedAt:      v.UpdatedAt,
	}
	if v.Permissions != nil {
		res.Permissions = make([]*designtypes.PermissionResponse, len(v.Permissions))
		for i, val := range v.Permissions {
			res.Permissions[i] = unmarshalPermissionResponseResponseBodyToDesigntypesPermissionResponse(val)
		}
	}

	return res
}

// marshalRbacCreateRoleRequestToCreateRoleRequestRequestBody builds a value of
// type *CreateRoleRequestRequestBody from a value of type
// *rbac.CreateRoleRequest.
func marshalRbacCreateRoleRequestToCreateRoleRequestRequestBody(v *rbac.CreateRoleRequest) *CreateRoleRequestRequestBody {
	res := &CreateRoleRequestRequestBody{
		Name:           v.Name,
		Description:    v.Description,
		OrganizationID: v.OrganizationID,
		IsDefault:      v.IsDefault,
	}
	{
		var zero bool
		if res.IsDefault == zero {
			res.IsDefault = false
		}
	}

	return res
}

// marshalCreateRoleRequestRequestBodyToRbacCreateRoleRequest builds a value of
// type *rbac.CreateRoleRequest from a value of type
// *CreateRoleRequestRequestBody.
func marshalCreateRoleRequestRequestBodyToRbacCreateRoleRequest(v *CreateRoleRequestRequestBody) *rbac.CreateRoleRequest {
	res := &rbac.CreateRoleRequest{
		Name:           v.Name,
		Description:    v.Description,
		OrganizationID: v.OrganizationID,
		IsDefault:      v.IsDefault,
	}
	{
		var zero bool
		if res.IsDefault == zero {
			res.IsDefault = false
		}
	}

	return res
}

// marshalRbacUpdateRoleRequestToUpdateRoleRequestRequestBody builds a value of
// type *UpdateRoleRequestRequestBody from a value of type
// *rbac.UpdateRoleRequest.
func marshalRbacUpdateRoleRequestToUpdateRoleRequestRequestBody(v *rbac.UpdateRoleRequest) *UpdateRoleRequestRequestBody {
	res := &UpdateRoleRequestRequestBody{
		Name:        v.Name,
		Description: v.Description,
		IsDefault:   v.IsDefault,
	}

	return res
}

// marshalUpdateRoleRequestRequestBodyToRbacUpdateRoleRequest builds a value of
// type *rbac.UpdateRoleRequest from a value of type
// *UpdateRoleRequestRequestBody.
func marshalUpdateRoleRequestRequestBodyToRbacUpdateRoleRequest(v *UpdateRoleRequestRequestBody) *rbac.UpdateRoleRequest {
	res := &rbac.UpdateRoleRequest{
		Name:        v.Name,
		Description: v.Description,
		IsDefault:   v.IsDefault,
	}

	return res
}

// marshalRbacAddRolePermissionRequestToAddRolePermissionRequestRequestBody
// builds a value of type *AddRolePermissionRequestRequestBody from a value of
// type *rbac.AddRolePermissionRequest.
func marshalRbacAddRolePermissionRequestToAddRolePermissionRequestRequestBody(v *rbac.AddRolePermissionRequest) *AddRolePermissionRequestRequestBody {
	res := &AddRolePermissionRequestRequestBody{
		PermissionID: v.PermissionID,
	}

	return res
}

// marshalAddRolePermissionRequestRequestBodyToRbacAddRolePermissionRequest
// builds a value of type *rbac.AddRolePermissionRequest from a value of type
// *AddRolePermissionRequestRequestBody.
func marshalAddRolePermissionRequestRequestBodyToRbacAddRolePermissionRequest(v *AddRolePermissionRequestRequestBody) *rbac.AddRolePermissionRequest {
	res := &rbac.AddRolePermissionRequest{
		PermissionID: v.PermissionID,
	}

	return res
}
