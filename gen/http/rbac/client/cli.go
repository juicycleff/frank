// Code generated by goa v3.20.0, DO NOT EDIT.
//
// rbac HTTP client CLI support package
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	rbac "github.com/juicycleff/frank/gen/rbac"
	goa "goa.design/goa/v3/pkg"
)

// BuildListPermissionsPayload builds the payload for the rbac list_permissions
// endpoint from CLI flags.
func BuildListPermissionsPayload(rbacListPermissionsOffset string, rbacListPermissionsLimit string, rbacListPermissionsResource string, rbacListPermissionsAction string, rbacListPermissionsSearch string, rbacListPermissionsJWT string) (*rbac.ListPermissionsPayload, error) {
	var err error
	var offset int
	{
		if rbacListPermissionsOffset != "" {
			var v int64
			v, err = strconv.ParseInt(rbacListPermissionsOffset, 10, strconv.IntSize)
			offset = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
			if offset < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("offset", offset, 0, true))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var limit int
	{
		if rbacListPermissionsLimit != "" {
			var v int64
			v, err = strconv.ParseInt(rbacListPermissionsLimit, 10, strconv.IntSize)
			limit = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
			if limit < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
			}
			if limit > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var resource *string
	{
		if rbacListPermissionsResource != "" {
			resource = &rbacListPermissionsResource
		}
	}
	var action *string
	{
		if rbacListPermissionsAction != "" {
			action = &rbacListPermissionsAction
		}
	}
	var search *string
	{
		if rbacListPermissionsSearch != "" {
			search = &rbacListPermissionsSearch
		}
	}
	var jwt *string
	{
		if rbacListPermissionsJWT != "" {
			jwt = &rbacListPermissionsJWT
		}
	}
	v := &rbac.ListPermissionsPayload{}
	v.Offset = offset
	v.Limit = limit
	v.Resource = resource
	v.Action = action
	v.Search = search
	v.JWT = jwt

	return v, nil
}

// BuildCreatePermissionPayload builds the payload for the rbac
// create_permission endpoint from CLI flags.
func BuildCreatePermissionPayload(rbacCreatePermissionBody string, rbacCreatePermissionJWT string) (*rbac.CreatePermissionPayload, error) {
	var err error
	var body CreatePermissionRequestBody
	{
		err = json.Unmarshal([]byte(rbacCreatePermissionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"permission\": {\n         \"action\": \"read\",\n         \"conditions\": \"Cumque molestiae dolore quaerat voluptatibus iure.\",\n         \"description\": \"Allows reading user information\",\n         \"name\": \"users:read\",\n         \"resource\": \"users\"\n      }\n   }'")
		}
		if body.Permission == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("permission", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var jwt *string
	{
		if rbacCreatePermissionJWT != "" {
			jwt = &rbacCreatePermissionJWT
		}
	}
	v := &rbac.CreatePermissionPayload{}
	if body.Permission != nil {
		v.Permission = marshalCreatePermissionRequestRequestBodyToRbacCreatePermissionRequest(body.Permission)
	}
	v.JWT = jwt

	return v, nil
}

// BuildGetPermissionPayload builds the payload for the rbac get_permission
// endpoint from CLI flags.
func BuildGetPermissionPayload(rbacGetPermissionID string, rbacGetPermissionJWT string) (*rbac.GetPermissionPayload, error) {
	var id string
	{
		id = rbacGetPermissionID
	}
	var jwt *string
	{
		if rbacGetPermissionJWT != "" {
			jwt = &rbacGetPermissionJWT
		}
	}
	v := &rbac.GetPermissionPayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildUpdatePermissionPayload builds the payload for the rbac
// update_permission endpoint from CLI flags.
func BuildUpdatePermissionPayload(rbacUpdatePermissionBody string, rbacUpdatePermissionID string, rbacUpdatePermissionJWT string) (*rbac.UpdatePermissionPayload, error) {
	var err error
	var body UpdatePermissionRequestBody
	{
		err = json.Unmarshal([]byte(rbacUpdatePermissionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"permission\": {\n         \"conditions\": \"Necessitatibus suscipit quod aut voluptatem accusamus.\",\n         \"description\": \"Natus nesciunt labore occaecati.\",\n         \"name\": \"Aut sunt ducimus ipsam cum.\"\n      }\n   }'")
		}
		if body.Permission == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("permission", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = rbacUpdatePermissionID
	}
	var jwt *string
	{
		if rbacUpdatePermissionJWT != "" {
			jwt = &rbacUpdatePermissionJWT
		}
	}
	v := &rbac.UpdatePermissionPayload{}
	if body.Permission != nil {
		v.Permission = marshalUpdatePermissionRequestRequestBodyToRbacUpdatePermissionRequest(body.Permission)
	}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildDeletePermissionPayload builds the payload for the rbac
// delete_permission endpoint from CLI flags.
func BuildDeletePermissionPayload(rbacDeletePermissionID string, rbacDeletePermissionJWT string) (*rbac.DeletePermissionPayload, error) {
	var id string
	{
		id = rbacDeletePermissionID
	}
	var jwt *string
	{
		if rbacDeletePermissionJWT != "" {
			jwt = &rbacDeletePermissionJWT
		}
	}
	v := &rbac.DeletePermissionPayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildListRolesPayload builds the payload for the rbac list_roles endpoint
// from CLI flags.
func BuildListRolesPayload(rbacListRolesOffset string, rbacListRolesLimit string, rbacListRolesOrganizationID string, rbacListRolesSearch string, rbacListRolesJWT string) (*rbac.ListRolesPayload, error) {
	var err error
	var offset int
	{
		if rbacListRolesOffset != "" {
			var v int64
			v, err = strconv.ParseInt(rbacListRolesOffset, 10, strconv.IntSize)
			offset = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
			if offset < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("offset", offset, 0, true))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var limit int
	{
		if rbacListRolesLimit != "" {
			var v int64
			v, err = strconv.ParseInt(rbacListRolesLimit, 10, strconv.IntSize)
			limit = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
			if limit < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
			}
			if limit > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var organizationID *string
	{
		if rbacListRolesOrganizationID != "" {
			organizationID = &rbacListRolesOrganizationID
		}
	}
	var search *string
	{
		if rbacListRolesSearch != "" {
			search = &rbacListRolesSearch
		}
	}
	var jwt *string
	{
		if rbacListRolesJWT != "" {
			jwt = &rbacListRolesJWT
		}
	}
	v := &rbac.ListRolesPayload{}
	v.Offset = offset
	v.Limit = limit
	v.OrganizationID = organizationID
	v.Search = search
	v.JWT = jwt

	return v, nil
}

// BuildCreateRolePayload builds the payload for the rbac create_role endpoint
// from CLI flags.
func BuildCreateRolePayload(rbacCreateRoleBody string, rbacCreateRoleJWT string) (*rbac.CreateRolePayload, error) {
	var err error
	var body CreateRoleRequestBody
	{
		err = json.Unmarshal([]byte(rbacCreateRoleBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"role\": {\n         \"description\": \"Administrator role with full access\",\n         \"is_default\": true,\n         \"name\": \"Admin\",\n         \"organization_id\": \"Quasi quisquam et accusamus.\"\n      }\n   }'")
		}
		if body.Role == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("role", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var jwt *string
	{
		if rbacCreateRoleJWT != "" {
			jwt = &rbacCreateRoleJWT
		}
	}
	v := &rbac.CreateRolePayload{}
	if body.Role != nil {
		v.Role = marshalCreateRoleRequestRequestBodyToRbacCreateRoleRequest(body.Role)
	}
	v.JWT = jwt

	return v, nil
}

// BuildGetRolePayload builds the payload for the rbac get_role endpoint from
// CLI flags.
func BuildGetRolePayload(rbacGetRoleID string, rbacGetRoleJWT string) (*rbac.GetRolePayload, error) {
	var id string
	{
		id = rbacGetRoleID
	}
	var jwt *string
	{
		if rbacGetRoleJWT != "" {
			jwt = &rbacGetRoleJWT
		}
	}
	v := &rbac.GetRolePayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildUpdateRolePayload builds the payload for the rbac update_role endpoint
// from CLI flags.
func BuildUpdateRolePayload(rbacUpdateRoleBody string, rbacUpdateRoleID string, rbacUpdateRoleJWT string) (*rbac.UpdateRolePayload, error) {
	var err error
	var body UpdateRoleRequestBody
	{
		err = json.Unmarshal([]byte(rbacUpdateRoleBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"role\": {\n         \"description\": \"Omnis praesentium.\",\n         \"is_default\": false,\n         \"name\": \"Iste sit aut facilis est enim nesciunt.\"\n      }\n   }'")
		}
		if body.Role == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("role", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = rbacUpdateRoleID
	}
	var jwt *string
	{
		if rbacUpdateRoleJWT != "" {
			jwt = &rbacUpdateRoleJWT
		}
	}
	v := &rbac.UpdateRolePayload{}
	if body.Role != nil {
		v.Role = marshalUpdateRoleRequestRequestBodyToRbacUpdateRoleRequest(body.Role)
	}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildDeleteRolePayload builds the payload for the rbac delete_role endpoint
// from CLI flags.
func BuildDeleteRolePayload(rbacDeleteRoleID string, rbacDeleteRoleJWT string) (*rbac.DeleteRolePayload, error) {
	var id string
	{
		id = rbacDeleteRoleID
	}
	var jwt *string
	{
		if rbacDeleteRoleJWT != "" {
			jwt = &rbacDeleteRoleJWT
		}
	}
	v := &rbac.DeleteRolePayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildListRolePermissionsPayload builds the payload for the rbac
// list_role_permissions endpoint from CLI flags.
func BuildListRolePermissionsPayload(rbacListRolePermissionsID string, rbacListRolePermissionsJWT string) (*rbac.ListRolePermissionsPayload, error) {
	var id string
	{
		id = rbacListRolePermissionsID
	}
	var jwt *string
	{
		if rbacListRolePermissionsJWT != "" {
			jwt = &rbacListRolePermissionsJWT
		}
	}
	v := &rbac.ListRolePermissionsPayload{}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildAddRolePermissionPayload builds the payload for the rbac
// add_role_permission endpoint from CLI flags.
func BuildAddRolePermissionPayload(rbacAddRolePermissionBody string, rbacAddRolePermissionID string, rbacAddRolePermissionJWT string) (*rbac.AddRolePermissionPayload, error) {
	var err error
	var body AddRolePermissionRequestBody
	{
		err = json.Unmarshal([]byte(rbacAddRolePermissionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"permission\": {\n         \"permission_id\": \"Aut accusantium ipsum inventore dolores et.\"\n      }\n   }'")
		}
		if body.Permission == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("permission", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = rbacAddRolePermissionID
	}
	var jwt *string
	{
		if rbacAddRolePermissionJWT != "" {
			jwt = &rbacAddRolePermissionJWT
		}
	}
	v := &rbac.AddRolePermissionPayload{}
	if body.Permission != nil {
		v.Permission = marshalAddRolePermissionRequestRequestBodyToRbacAddRolePermissionRequest(body.Permission)
	}
	v.ID = id
	v.JWT = jwt

	return v, nil
}

// BuildRemoveRolePermissionPayload builds the payload for the rbac
// remove_role_permission endpoint from CLI flags.
func BuildRemoveRolePermissionPayload(rbacRemoveRolePermissionID string, rbacRemoveRolePermissionPermissionID string, rbacRemoveRolePermissionJWT string) (*rbac.RemoveRolePermissionPayload, error) {
	var id string
	{
		id = rbacRemoveRolePermissionID
	}
	var permissionID string
	{
		permissionID = rbacRemoveRolePermissionPermissionID
	}
	var jwt *string
	{
		if rbacRemoveRolePermissionJWT != "" {
			jwt = &rbacRemoveRolePermissionJWT
		}
	}
	v := &rbac.RemoveRolePermissionPayload{}
	v.ID = id
	v.PermissionID = permissionID
	v.JWT = jwt

	return v, nil
}

// BuildCheckPermissionPayload builds the payload for the rbac check_permission
// endpoint from CLI flags.
func BuildCheckPermissionPayload(rbacCheckPermissionResource string, rbacCheckPermissionAction string, rbacCheckPermissionJWT string) (*rbac.CheckPermissionPayload, error) {
	var resource string
	{
		resource = rbacCheckPermissionResource
	}
	var action string
	{
		action = rbacCheckPermissionAction
	}
	var jwt *string
	{
		if rbacCheckPermissionJWT != "" {
			jwt = &rbacCheckPermissionJWT
		}
	}
	v := &rbac.CheckPermissionPayload{}
	v.Resource = resource
	v.Action = action
	v.JWT = jwt

	return v, nil
}

// BuildCheckRolePayload builds the payload for the rbac check_role endpoint
// from CLI flags.
func BuildCheckRolePayload(rbacCheckRoleRole string, rbacCheckRoleOrganizationID string, rbacCheckRoleJWT string) (*rbac.CheckRolePayload, error) {
	var role string
	{
		role = rbacCheckRoleRole
	}
	var organizationID *string
	{
		if rbacCheckRoleOrganizationID != "" {
			organizationID = &rbacCheckRoleOrganizationID
		}
	}
	var jwt *string
	{
		if rbacCheckRoleJWT != "" {
			jwt = &rbacCheckRoleJWT
		}
	}
	v := &rbac.CheckRolePayload{}
	v.Role = role
	v.OrganizationID = organizationID
	v.JWT = jwt

	return v, nil
}
