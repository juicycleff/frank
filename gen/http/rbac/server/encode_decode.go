// Code generated by goa v3.20.0, DO NOT EDIT.
//
// rbac HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"
	"strings"

	designtypes "github.com/juicycleff/frank/gen/designtypes"
	rbac "github.com/juicycleff/frank/gen/rbac"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeListPermissionsResponse returns an encoder for responses returned by
// the rbac list_permissions endpoint.
func EncodeListPermissionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*rbac.ListPermissionsResponse)
		enc := encoder(ctx, w)
		body := NewListPermissionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListPermissionsRequest returns a decoder for requests sent to the rbac
// list_permissions endpoint.
func DecodeListPermissionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			offset   int
			limit    int
			resource *string
			action   *string
			search   *string
			jwt      *string
			err      error
		)
		qp := r.URL.Query()
		{
			offsetRaw := qp.Get("offset")
			if offsetRaw != "" {
				v, err2 := strconv.ParseInt(offsetRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("offset", offsetRaw, "integer"))
				}
				offset = int(v)
			}
		}
		if offset < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("offset", offset, 0, true))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw == "" {
				limit = 20
			} else {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				limit = int(v)
			}
		}
		if limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
		}
		if limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
		}
		resourceRaw := qp.Get("resource")
		if resourceRaw != "" {
			resource = &resourceRaw
		}
		actionRaw := qp.Get("action")
		if actionRaw != "" {
			action = &actionRaw
		}
		searchRaw := qp.Get("search")
		if searchRaw != "" {
			search = &searchRaw
		}
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewListPermissionsPayload(offset, limit, resource, action, search, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeListPermissionsError returns an encoder for errors returned by the
// list_permissions rbac endpoint.
func EncodeListPermissionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListPermissionsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListPermissionsConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListPermissionsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListPermissionsInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListPermissionsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListPermissionsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreatePermissionResponse returns an encoder for responses returned by
// the rbac create_permission endpoint.
func EncodeCreatePermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*designtypes.PermissionResponse)
		enc := encoder(ctx, w)
		body := NewCreatePermissionResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreatePermissionRequest returns a decoder for requests sent to the
// rbac create_permission endpoint.
func DecodeCreatePermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreatePermissionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreatePermissionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewCreatePermissionPayload(&body, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreatePermissionError returns an encoder for errors returned by the
// create_permission rbac endpoint.
func EncodeCreatePermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreatePermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreatePermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreatePermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreatePermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreatePermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreatePermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetPermissionResponse returns an encoder for responses returned by the
// rbac get_permission endpoint.
func EncodeGetPermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*designtypes.PermissionResponse)
		enc := encoder(ctx, w)
		body := NewGetPermissionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetPermissionRequest returns a decoder for requests sent to the rbac
// get_permission endpoint.
func DecodeGetPermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewGetPermissionPayload(id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetPermissionError returns an encoder for errors returned by the
// get_permission rbac endpoint.
func EncodeGetPermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetPermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetPermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetPermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetPermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetPermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetPermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdatePermissionResponse returns an encoder for responses returned by
// the rbac update_permission endpoint.
func EncodeUpdatePermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*designtypes.PermissionResponse)
		enc := encoder(ctx, w)
		body := NewUpdatePermissionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdatePermissionRequest returns a decoder for requests sent to the
// rbac update_permission endpoint.
func DecodeUpdatePermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdatePermissionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdatePermissionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewUpdatePermissionPayload(&body, id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdatePermissionError returns an encoder for errors returned by the
// update_permission rbac endpoint.
func EncodeUpdatePermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdatePermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdatePermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdatePermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdatePermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdatePermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdatePermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeletePermissionResponse returns an encoder for responses returned by
// the rbac delete_permission endpoint.
func EncodeDeletePermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeletePermissionRequest returns a decoder for requests sent to the
// rbac delete_permission endpoint.
func DecodeDeletePermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewDeletePermissionPayload(id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeletePermissionError returns an encoder for errors returned by the
// delete_permission rbac endpoint.
func EncodeDeletePermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeletePermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeletePermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeletePermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeletePermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeletePermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeletePermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListRolesResponse returns an encoder for responses returned by the
// rbac list_roles endpoint.
func EncodeListRolesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*rbac.ListRolesResult)
		enc := encoder(ctx, w)
		body := NewListRolesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListRolesRequest returns a decoder for requests sent to the rbac
// list_roles endpoint.
func DecodeListRolesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			offset         int
			limit          int
			organizationID *string
			search         *string
			jwt            *string
			err            error
		)
		qp := r.URL.Query()
		{
			offsetRaw := qp.Get("offset")
			if offsetRaw != "" {
				v, err2 := strconv.ParseInt(offsetRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("offset", offsetRaw, "integer"))
				}
				offset = int(v)
			}
		}
		if offset < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("offset", offset, 0, true))
		}
		{
			limitRaw := qp.Get("limit")
			if limitRaw == "" {
				limit = 20
			} else {
				v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
				}
				limit = int(v)
			}
		}
		if limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
		}
		if limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
		}
		organizationIDRaw := qp.Get("organization_id")
		if organizationIDRaw != "" {
			organizationID = &organizationIDRaw
		}
		searchRaw := qp.Get("search")
		if searchRaw != "" {
			search = &searchRaw
		}
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewListRolesPayload(offset, limit, organizationID, search, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeListRolesError returns an encoder for errors returned by the
// list_roles rbac endpoint.
func EncodeListRolesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolesBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolesConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolesForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolesInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolesNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolesUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateRoleResponse returns an encoder for responses returned by the
// rbac create_role endpoint.
func EncodeCreateRoleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*designtypes.RoleResponse)
		enc := encoder(ctx, w)
		body := NewCreateRoleResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateRoleRequest returns a decoder for requests sent to the rbac
// create_role endpoint.
func DecodeCreateRoleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateRoleRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateRoleRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			jwt *string
		)
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewCreateRolePayload(&body, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateRoleError returns an encoder for errors returned by the
// create_role rbac endpoint.
func EncodeCreateRoleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateRoleBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateRoleConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateRoleForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateRoleInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateRoleNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateRoleUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetRoleResponse returns an encoder for responses returned by the rbac
// get_role endpoint.
func EncodeGetRoleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*designtypes.RoleResponse)
		enc := encoder(ctx, w)
		body := NewGetRoleResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetRoleRequest returns a decoder for requests sent to the rbac
// get_role endpoint.
func DecodeGetRoleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewGetRolePayload(id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetRoleError returns an encoder for errors returned by the get_role
// rbac endpoint.
func EncodeGetRoleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetRoleBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetRoleConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetRoleForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetRoleInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetRoleNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetRoleUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateRoleResponse returns an encoder for responses returned by the
// rbac update_role endpoint.
func EncodeUpdateRoleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*designtypes.RoleResponse)
		enc := encoder(ctx, w)
		body := NewUpdateRoleResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateRoleRequest returns a decoder for requests sent to the rbac
// update_role endpoint.
func DecodeUpdateRoleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateRoleRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateRoleRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewUpdateRolePayload(&body, id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateRoleError returns an encoder for errors returned by the
// update_role rbac endpoint.
func EncodeUpdateRoleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateRoleBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateRoleConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateRoleForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateRoleInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateRoleNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateRoleUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteRoleResponse returns an encoder for responses returned by the
// rbac delete_role endpoint.
func EncodeDeleteRoleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteRoleRequest returns a decoder for requests sent to the rbac
// delete_role endpoint.
func DecodeDeleteRoleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewDeleteRolePayload(id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteRoleError returns an encoder for errors returned by the
// delete_role rbac endpoint.
func EncodeDeleteRoleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteRoleBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteRoleConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteRoleForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteRoleInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteRoleNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteRoleUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListRolePermissionsResponse returns an encoder for responses returned
// by the rbac list_role_permissions endpoint.
func EncodeListRolePermissionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*rbac.ListRolePermissionsResult)
		enc := encoder(ctx, w)
		body := NewListRolePermissionsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListRolePermissionsRequest returns a decoder for requests sent to the
// rbac list_role_permissions endpoint.
func DecodeListRolePermissionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewListRolePermissionsPayload(id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeListRolePermissionsError returns an encoder for errors returned by the
// list_role_permissions rbac endpoint.
func EncodeListRolePermissionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolePermissionsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolePermissionsConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolePermissionsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolePermissionsInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolePermissionsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListRolePermissionsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeAddRolePermissionResponse returns an encoder for responses returned by
// the rbac add_role_permission endpoint.
func EncodeAddRolePermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*rbac.AddRolePermissionResult)
		enc := encoder(ctx, w)
		body := NewAddRolePermissionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeAddRolePermissionRequest returns a decoder for requests sent to the
// rbac add_role_permission endpoint.
func DecodeAddRolePermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body AddRolePermissionRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAddRolePermissionRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			id  string
			jwt *string

			params = mux.Vars(r)
		)
		id = params["id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewAddRolePermissionPayload(&body, id, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeAddRolePermissionError returns an encoder for errors returned by the
// add_role_permission rbac endpoint.
func EncodeAddRolePermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewAddRolePermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewAddRolePermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewAddRolePermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewAddRolePermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewAddRolePermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewAddRolePermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRemoveRolePermissionResponse returns an encoder for responses returned
// by the rbac remove_role_permission endpoint.
func EncodeRemoveRolePermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeRemoveRolePermissionRequest returns a decoder for requests sent to the
// rbac remove_role_permission endpoint.
func DecodeRemoveRolePermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id           string
			permissionID string
			jwt          *string

			params = mux.Vars(r)
		)
		id = params["id"]
		permissionID = params["permission_id"]
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		payload := NewRemoveRolePermissionPayload(id, permissionID, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeRemoveRolePermissionError returns an encoder for errors returned by
// the remove_role_permission rbac endpoint.
func EncodeRemoveRolePermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveRolePermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveRolePermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveRolePermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveRolePermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveRolePermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRemoveRolePermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCheckPermissionResponse returns an encoder for responses returned by
// the rbac check_permission endpoint.
func EncodeCheckPermissionResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*rbac.CheckPermissionResult)
		enc := encoder(ctx, w)
		body := NewCheckPermissionResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCheckPermissionRequest returns a decoder for requests sent to the rbac
// check_permission endpoint.
func DecodeCheckPermissionRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			resource string
			action   string
			jwt      *string
			err      error
		)
		qp := r.URL.Query()
		resource = qp.Get("resource")
		if resource == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("resource", "query string"))
		}
		action = qp.Get("action")
		if action == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("action", "query string"))
		}
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewCheckPermissionPayload(resource, action, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCheckPermissionError returns an encoder for errors returned by the
// check_permission rbac endpoint.
func EncodeCheckPermissionError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckPermissionBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckPermissionConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckPermissionForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckPermissionInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckPermissionNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckPermissionUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCheckRoleResponse returns an encoder for responses returned by the
// rbac check_role endpoint.
func EncodeCheckRoleResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*rbac.CheckRoleResult)
		enc := encoder(ctx, w)
		body := NewCheckRoleResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCheckRoleRequest returns a decoder for requests sent to the rbac
// check_role endpoint.
func DecodeCheckRoleRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			role           string
			organizationID *string
			jwt            *string
			err            error
		)
		qp := r.URL.Query()
		role = qp.Get("role")
		if role == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("role", "query string"))
		}
		organizationIDRaw := qp.Get("organization_id")
		if organizationIDRaw != "" {
			organizationID = &organizationIDRaw
		}
		jwtRaw := r.Header.Get("Authorization")
		if jwtRaw != "" {
			jwt = &jwtRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewCheckRolePayload(role, organizationID, jwt)
		if payload.JWT != nil {
			if strings.Contains(*payload.JWT, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWT, " ", 2)[1]
				payload.JWT = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCheckRoleError returns an encoder for errors returned by the
// check_role rbac endpoint.
func EncodeCheckRoleError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "bad_request":
			var res *rbac.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckRoleBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "conflict":
			var res *rbac.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckRoleConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "forbidden":
			var res *rbac.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckRoleForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "internal_error":
			var res *rbac.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckRoleInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_found":
			var res *rbac.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckRoleNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "unauthorized":
			var res *rbac.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCheckRoleUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalDesigntypesPermissionResponseToPermissionResponseResponseBody builds
// a value of type *PermissionResponseResponseBody from a value of type
// *designtypes.PermissionResponse.
func marshalDesigntypesPermissionResponseToPermissionResponseResponseBody(v *designtypes.PermissionResponse) *PermissionResponseResponseBody {
	res := &PermissionResponseResponseBody{
		ID:          v.ID,
		Name:        v.Name,
		Description: v.Description,
		Resource:    v.Resource,
		Action:      v.Action,
		Conditions:  v.Conditions,
		System:      v.System,
		CreatedAt:   v.CreatedAt,
		UpdatedAt:   v.UpdatedAt,
	}

	return res
}

// marshalDesigntypesPaginationToPaginationResponseBody builds a value of type
// *PaginationResponseBody from a value of type *designtypes.Pagination.
func marshalDesigntypesPaginationToPaginationResponseBody(v *designtypes.Pagination) *PaginationResponseBody {
	res := &PaginationResponseBody{
		Offset:      v.Offset,
		Limit:       v.Limit,
		Total:       v.Total,
		TotalPages:  v.TotalPages,
		CurrentPage: v.CurrentPage,
		HasNext:     v.HasNext,
		HasPrevious: v.HasPrevious,
	}

	return res
}

// unmarshalCreatePermissionRequestRequestBodyToRbacCreatePermissionRequest
// builds a value of type *rbac.CreatePermissionRequest from a value of type
// *CreatePermissionRequestRequestBody.
func unmarshalCreatePermissionRequestRequestBodyToRbacCreatePermissionRequest(v *CreatePermissionRequestRequestBody) *rbac.CreatePermissionRequest {
	res := &rbac.CreatePermissionRequest{
		Name:        *v.Name,
		Description: *v.Description,
		Resource:    *v.Resource,
		Action:      *v.Action,
		Conditions:  v.Conditions,
	}

	return res
}

// unmarshalUpdatePermissionRequestRequestBodyToRbacUpdatePermissionRequest
// builds a value of type *rbac.UpdatePermissionRequest from a value of type
// *UpdatePermissionRequestRequestBody.
func unmarshalUpdatePermissionRequestRequestBodyToRbacUpdatePermissionRequest(v *UpdatePermissionRequestRequestBody) *rbac.UpdatePermissionRequest {
	res := &rbac.UpdatePermissionRequest{
		Name:        v.Name,
		Description: v.Description,
		Conditions:  v.Conditions,
	}

	return res
}

// marshalDesigntypesRoleResponseToRoleResponseResponseBody builds a value of
// type *RoleResponseResponseBody from a value of type
// *designtypes.RoleResponse.
func marshalDesigntypesRoleResponseToRoleResponseResponseBody(v *designtypes.RoleResponse) *RoleResponseResponseBody {
	res := &RoleResponseResponseBody{
		ID:             v.ID,
		Name:           v.Name,
		Description:    v.Description,
		OrganizationID: v.OrganizationID,
		System:         v.System,
		IsDefault:      v.IsDefault,
		CreatedAt:      v.CreatedAt,
		UpdatedAt:      v.UpdatedAt,
	}
	if v.Permissions != nil {
		res.Permissions = make([]*PermissionResponseResponseBody, len(v.Permissions))
		for i, val := range v.Permissions {
			res.Permissions[i] = marshalDesigntypesPermissionResponseToPermissionResponseResponseBody(val)
		}
	}

	return res
}

// unmarshalCreateRoleRequestRequestBodyToRbacCreateRoleRequest builds a value
// of type *rbac.CreateRoleRequest from a value of type
// *CreateRoleRequestRequestBody.
func unmarshalCreateRoleRequestRequestBodyToRbacCreateRoleRequest(v *CreateRoleRequestRequestBody) *rbac.CreateRoleRequest {
	res := &rbac.CreateRoleRequest{
		Name:           *v.Name,
		Description:    v.Description,
		OrganizationID: v.OrganizationID,
	}
	if v.IsDefault != nil {
		res.IsDefault = *v.IsDefault
	}
	if v.IsDefault == nil {
		res.IsDefault = false
	}

	return res
}

// unmarshalUpdateRoleRequestRequestBodyToRbacUpdateRoleRequest builds a value
// of type *rbac.UpdateRoleRequest from a value of type
// *UpdateRoleRequestRequestBody.
func unmarshalUpdateRoleRequestRequestBodyToRbacUpdateRoleRequest(v *UpdateRoleRequestRequestBody) *rbac.UpdateRoleRequest {
	res := &rbac.UpdateRoleRequest{
		Name:        v.Name,
		Description: v.Description,
		IsDefault:   v.IsDefault,
	}

	return res
}

// unmarshalAddRolePermissionRequestRequestBodyToRbacAddRolePermissionRequest
// builds a value of type *rbac.AddRolePermissionRequest from a value of type
// *AddRolePermissionRequestRequestBody.
func unmarshalAddRolePermissionRequestRequestBodyToRbacAddRolePermissionRequest(v *AddRolePermissionRequestRequestBody) *rbac.AddRolePermissionRequest {
	res := &rbac.AddRolePermissionRequest{
		PermissionID: *v.PermissionID,
	}

	return res
}
