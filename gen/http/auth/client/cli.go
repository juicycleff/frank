// Code generated by goa v3.20.0, DO NOT EDIT.
//
// auth HTTP client CLI support package
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	auth "github.com/juicycleff/frank/gen/auth"
	"github.com/juicycleff/frank/user"
	goa "goa.design/goa/v3/pkg"
)

// BuildLoginPayload builds the payload for the auth login endpoint from CLI
// flags.
func BuildLoginPayload(authLoginBody string, authLoginSessionID string) (*auth.LoginPayload, error) {
	var err error
	var body LoginRequestBody
	{
		err = json.Unmarshal([]byte(authLoginBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"captcha_response\": \"Eum fugit est ut sed.\",\n      \"email\": \"user@example.com\",\n      \"organization_id\": \"Consequuntur quia.\",\n      \"password\": \"secure-password\",\n      \"remember_me\": true\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if utf8.RuneCountInString(body.Password) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", body.Password, utf8.RuneCountInString(body.Password), 1, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionID *string
	{
		if authLoginSessionID != "" {
			sessionID = &authLoginSessionID
		}
	}
	v := &auth.LoginPayload{
		Email:           body.Email,
		Password:        body.Password,
		OrganizationID:  body.OrganizationID,
		RememberMe:      body.RememberMe,
		CaptchaResponse: body.CaptchaResponse,
	}
	{
		var zero bool
		if v.RememberMe == zero {
			v.RememberMe = false
		}
	}
	v.SessionID = sessionID

	return v, nil
}

// BuildRegisterPayload builds the payload for the auth register endpoint from
// CLI flags.
func BuildRegisterPayload(authRegisterBody string, authRegisterSessionID string) (*auth.RegisterPayload, error) {
	var err error
	var body RegisterRequestBody
	{
		err = json.Unmarshal([]byte(authRegisterBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"user@example.com\",\n      \"first_name\": \"Et similique.\",\n      \"last_name\": \"Sint magni voluptatibus.\",\n      \"metadata\": {\n         \"Maiores expedita minima placeat.\": \"In laboriosam.\"\n      },\n      \"organization_id\": \"Consectetur omnis et pariatur sit est qui.\",\n      \"password\": \"secure-password\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if utf8.RuneCountInString(body.Password) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", body.Password, utf8.RuneCountInString(body.Password), 8, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionID *string
	{
		if authRegisterSessionID != "" {
			sessionID = &authRegisterSessionID
		}
	}
	v := &auth.RegisterPayload{
		Email:          body.Email,
		Password:       body.Password,
		FirstName:      body.FirstName,
		LastName:       body.LastName,
		OrganizationID: body.OrganizationID,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}
	v.SessionID = sessionID

	return v, nil
}

// BuildLogoutPayload builds the payload for the auth logout endpoint from CLI
// flags.
func BuildLogoutPayload(authLogoutJWT string, authLogoutSessionID string) (*auth.LogoutPayload, error) {
	var jwt *string
	{
		if authLogoutJWT != "" {
			jwt = &authLogoutJWT
		}
	}
	var sessionID *string
	{
		if authLogoutSessionID != "" {
			sessionID = &authLogoutSessionID
		}
	}
	v := &auth.LogoutPayload{}
	v.JWT = jwt
	v.SessionID = sessionID

	return v, nil
}

// BuildRefreshTokenPayload builds the payload for the auth refresh_token
// endpoint from CLI flags.
func BuildRefreshTokenPayload(authRefreshTokenBody string, authRefreshTokenOauth2 string, authRefreshTokenXAPIKey string, authRefreshTokenJWT string, authRefreshTokenSessionID string) (*auth.RefreshTokenPayload, error) {
	var err error
	var body RefreshTokenRequestBody
	{
		err = json.Unmarshal([]byte(authRefreshTokenBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"refresh_token\": \"Eveniet fugit.\"\n   }'")
		}
	}
	var oauth2 *string
	{
		if authRefreshTokenOauth2 != "" {
			oauth2 = &authRefreshTokenOauth2
		}
	}
	var xAPIKey *string
	{
		if authRefreshTokenXAPIKey != "" {
			xAPIKey = &authRefreshTokenXAPIKey
		}
	}
	var jwt *string
	{
		if authRefreshTokenJWT != "" {
			jwt = &authRefreshTokenJWT
		}
	}
	var sessionID *string
	{
		if authRefreshTokenSessionID != "" {
			sessionID = &authRefreshTokenSessionID
		}
	}
	v := &auth.RefreshTokenPayload{
		RefreshToken: body.RefreshToken,
	}
	v.Oauth2 = oauth2
	v.XAPIKey = xAPIKey
	v.JWT = jwt
	v.SessionID = sessionID

	return v, nil
}

// BuildForgotPasswordPayload builds the payload for the auth forgot_password
// endpoint from CLI flags.
func BuildForgotPasswordPayload(authForgotPasswordBody string, authForgotPasswordRedirectURL string, authForgotPasswordOauth2 string, authForgotPasswordXAPIKey string, authForgotPasswordJWT string, authForgotPasswordSessionID string) (*auth.ForgotPasswordPayload, error) {
	var err error
	var body ForgotPasswordRequestBody
	{
		err = json.Unmarshal([]byte(authForgotPasswordBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"user@example.com\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if err != nil {
			return nil, err
		}
	}
	var redirectURL *string
	{
		if authForgotPasswordRedirectURL != "" {
			redirectURL = &authForgotPasswordRedirectURL
		}
	}
	var oauth2 *string
	{
		if authForgotPasswordOauth2 != "" {
			oauth2 = &authForgotPasswordOauth2
		}
	}
	var xAPIKey *string
	{
		if authForgotPasswordXAPIKey != "" {
			xAPIKey = &authForgotPasswordXAPIKey
		}
	}
	var jwt *string
	{
		if authForgotPasswordJWT != "" {
			jwt = &authForgotPasswordJWT
		}
	}
	var sessionID *string
	{
		if authForgotPasswordSessionID != "" {
			sessionID = &authForgotPasswordSessionID
		}
	}
	v := &auth.ForgotPasswordPayload{
		Email: body.Email,
	}
	v.RedirectURL = redirectURL
	v.Oauth2 = oauth2
	v.XAPIKey = xAPIKey
	v.JWT = jwt
	v.SessionID = sessionID

	return v, nil
}

// BuildResetPasswordPayload builds the payload for the auth reset_password
// endpoint from CLI flags.
func BuildResetPasswordPayload(authResetPasswordBody string, authResetPasswordSessionID string) (*auth.ResetPasswordPayload, error) {
	var err error
	var body ResetPasswordRequestBody
	{
		err = json.Unmarshal([]byte(authResetPasswordBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"new_password\": \"new-secure-password\",\n      \"token\": \"Aperiam voluptas dolores ut quis.\"\n   }'")
		}
		if utf8.RuneCountInString(body.NewPassword) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.new_password", body.NewPassword, utf8.RuneCountInString(body.NewPassword), 8, true))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionID *string
	{
		if authResetPasswordSessionID != "" {
			sessionID = &authResetPasswordSessionID
		}
	}
	v := &auth.ResetPasswordPayload{
		Token:       body.Token,
		NewPassword: body.NewPassword,
	}
	v.SessionID = sessionID

	return v, nil
}

// BuildVerifyEmailPayload builds the payload for the auth verify_email
// endpoint from CLI flags.
func BuildVerifyEmailPayload(authVerifyEmailBody string, authVerifyEmailSessionID string) (*auth.VerifyEmailPayload, error) {
	var err error
	var body VerifyEmailRequestBody
	{
		err = json.Unmarshal([]byte(authVerifyEmailBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"user@example.com\",\n      \"method\": \"otp\",\n      \"otp\": \"Veniam et ducimus nobis est enim harum.\",\n      \"token\": \"Voluptates illo.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if !(body.Method == "link" || body.Method == "otp") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.method", body.Method, []any{"link", "otp"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionID *string
	{
		if authVerifyEmailSessionID != "" {
			sessionID = &authVerifyEmailSessionID
		}
	}
	v := &auth.VerifyEmailPayload{
		Token:  body.Token,
		Otp:    body.Otp,
		Email:  body.Email,
		Method: body.Method,
	}
	v.SessionID = sessionID

	return v, nil
}

// BuildSendEmailVerificationPayload builds the payload for the auth
// send_email_verification endpoint from CLI flags.
func BuildSendEmailVerificationPayload(authSendEmailVerificationBody string, authSendEmailVerificationRedirectURL string, authSendEmailVerificationSessionID string) (*auth.SendEmailVerificationPayload, error) {
	var err error
	var body SendEmailVerificationRequestBody
	{
		err = json.Unmarshal([]byte(authSendEmailVerificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"user@example.com\",\n      \"method\": \"link\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if !(body.Method == "link" || body.Method == "otp") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.method", body.Method, []any{"link", "otp"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var redirectURL *string
	{
		if authSendEmailVerificationRedirectURL != "" {
			redirectURL = &authSendEmailVerificationRedirectURL
		}
	}
	var sessionID *string
	{
		if authSendEmailVerificationSessionID != "" {
			sessionID = &authSendEmailVerificationSessionID
		}
	}
	v := &auth.SendEmailVerificationPayload{
		Email:  body.Email,
		Method: body.Method,
	}
	{
		var zero user.VerificationMethod
		if v.Method == zero {
			v.Method = "otp"
		}
	}
	v.RedirectURL = redirectURL
	v.SessionID = sessionID

	return v, nil
}

// BuildCheckEmailVerificationPayload builds the payload for the auth
// check_email_verification endpoint from CLI flags.
func BuildCheckEmailVerificationPayload(authCheckEmailVerificationEmail string, authCheckEmailVerificationOauth2 string, authCheckEmailVerificationJWT string, authCheckEmailVerificationXAPIKey string, authCheckEmailVerificationSessionID string) (*auth.CheckEmailVerificationPayload, error) {
	var err error
	var email string
	{
		email = authCheckEmailVerificationEmail
		err = goa.MergeErrors(err, goa.ValidateFormat("email", email, goa.FormatEmail))
		if err != nil {
			return nil, err
		}
	}
	var oauth2 *string
	{
		if authCheckEmailVerificationOauth2 != "" {
			oauth2 = &authCheckEmailVerificationOauth2
		}
	}
	var jwt *string
	{
		if authCheckEmailVerificationJWT != "" {
			jwt = &authCheckEmailVerificationJWT
		}
	}
	var xAPIKey *string
	{
		if authCheckEmailVerificationXAPIKey != "" {
			xAPIKey = &authCheckEmailVerificationXAPIKey
		}
	}
	var sessionID *string
	{
		if authCheckEmailVerificationSessionID != "" {
			sessionID = &authCheckEmailVerificationSessionID
		}
	}
	v := &auth.CheckEmailVerificationPayload{}
	v.Email = email
	v.Oauth2 = oauth2
	v.JWT = jwt
	v.XAPIKey = xAPIKey
	v.SessionID = sessionID

	return v, nil
}

// BuildMePayload builds the payload for the auth me endpoint from CLI flags.
func BuildMePayload(authMeJWT string, authMeSessionID string) (*auth.MePayload, error) {
	var jwt *string
	{
		if authMeJWT != "" {
			jwt = &authMeJWT
		}
	}
	var sessionID *string
	{
		if authMeSessionID != "" {
			sessionID = &authMeSessionID
		}
	}
	v := &auth.MePayload{}
	v.JWT = jwt
	v.SessionID = sessionID

	return v, nil
}

// BuildCsrfPayload builds the payload for the auth csrf endpoint from CLI
// flags.
func BuildCsrfPayload(authCsrfSessionID string) (*auth.CsrfPayload, error) {
	var sessionID *string
	{
		if authCsrfSessionID != "" {
			sessionID = &authCsrfSessionID
		}
	}
	v := &auth.CsrfPayload{}
	v.SessionID = sessionID

	return v, nil
}
