// Code generated by goa v3.20.0, DO NOT EDIT.
//
// auth HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/juicycleff/frank/design -o .

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	auth "github.com/juicycleff/frank/gen/auth"
	designtypes "github.com/juicycleff/frank/gen/designtypes"
	goahttp "goa.design/goa/v3/http"
)

// BuildLoginRequest instantiates a HTTP request object with method and path
// set to call the "auth" service "login" endpoint
func (c *Client) BuildLoginRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LoginAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "login", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLoginRequest returns an encoder for requests sent to the auth login
// server.
func EncodeLoginRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.LoginPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "login", "*auth.LoginPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		body := NewLoginRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "login", err)
		}
		return nil
	}
}

// DecodeLoginResponse returns a decoder for responses returned by the auth
// login endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeLoginResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeLoginResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LoginResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			var (
				sessionID    *string
				sessionIDRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "frank_sid":
					sessionIDRaw = c.Value
				}
			}
			if sessionIDRaw != "" {
				sessionID = &sessionIDRaw
			}
			res := NewLoginResponseOK(&body, sessionID)
			return res, nil
		case http.StatusBadRequest:
			var (
				body LoginBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			return nil, NewLoginBadRequest(&body)
		case http.StatusConflict:
			var (
				body LoginConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			return nil, NewLoginConflict(&body)
		case http.StatusForbidden:
			var (
				body LoginForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			return nil, NewLoginForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body LoginInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			return nil, NewLoginInternalError(&body)
		case http.StatusNotFound:
			var (
				body LoginNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			return nil, NewLoginNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body LoginUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "login", err)
			}
			err = ValidateLoginUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "login", err)
			}
			return nil, NewLoginUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "login", resp.StatusCode, string(body))
		}
	}
}

// BuildRegisterRequest instantiates a HTTP request object with method and path
// set to call the "auth" service "register" endpoint
func (c *Client) BuildRegisterRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RegisterAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "register", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRegisterRequest returns an encoder for requests sent to the auth
// register server.
func EncodeRegisterRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.RegisterPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "register", "*auth.RegisterPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		body := NewRegisterRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "register", err)
		}
		return nil
	}
}

// DecodeRegisterResponse returns a decoder for responses returned by the auth
// register endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeRegisterResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeRegisterResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body RegisterResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			var (
				sessionID    *string
				sessionIDRaw string

				cookies = resp.Cookies()
			)
			for _, c := range cookies {
				switch c.Name {
				case "frank_sid":
					sessionIDRaw = c.Value
				}
			}
			if sessionIDRaw != "" {
				sessionID = &sessionIDRaw
			}
			res := NewRegisterLoginResponseCreated(&body, sessionID)
			return res, nil
		case http.StatusBadRequest:
			var (
				body RegisterBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			return nil, NewRegisterBadRequest(&body)
		case http.StatusConflict:
			var (
				body RegisterConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			return nil, NewRegisterConflict(&body)
		case http.StatusForbidden:
			var (
				body RegisterForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			return nil, NewRegisterForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body RegisterInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			return nil, NewRegisterInternalError(&body)
		case http.StatusNotFound:
			var (
				body RegisterNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			return nil, NewRegisterNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body RegisterUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "register", err)
			}
			err = ValidateRegisterUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "register", err)
			}
			return nil, NewRegisterUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "register", resp.StatusCode, string(body))
		}
	}
}

// BuildLogoutRequest instantiates a HTTP request object with method and path
// set to call the "auth" service "logout" endpoint
func (c *Client) BuildLogoutRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LogoutAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "logout", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLogoutRequest returns an encoder for requests sent to the auth logout
// server.
func EncodeLogoutRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.LogoutPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "logout", "*auth.LogoutPayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeLogoutResponse returns a decoder for responses returned by the auth
// logout endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeLogoutResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeLogoutResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LogoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			res := NewLogoutResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body LogoutBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			return nil, NewLogoutBadRequest(&body)
		case http.StatusConflict:
			var (
				body LogoutConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			return nil, NewLogoutConflict(&body)
		case http.StatusForbidden:
			var (
				body LogoutForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			return nil, NewLogoutForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body LogoutInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			return nil, NewLogoutInternalError(&body)
		case http.StatusNotFound:
			var (
				body LogoutNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			return nil, NewLogoutNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body LogoutUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "logout", err)
			}
			err = ValidateLogoutUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "logout", err)
			}
			return nil, NewLogoutUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "logout", resp.StatusCode, string(body))
		}
	}
}

// BuildRefreshTokenRequest instantiates a HTTP request object with method and
// path set to call the "auth" service "refresh_token" endpoint
func (c *Client) BuildRefreshTokenRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RefreshTokenAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "refresh_token", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRefreshTokenRequest returns an encoder for requests sent to the auth
// refresh_token server.
func EncodeRefreshTokenRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.RefreshTokenPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "refresh_token", "*auth.RefreshTokenPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		body := NewRefreshTokenRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "refresh_token", err)
		}
		return nil
	}
}

// DecodeRefreshTokenResponse returns a decoder for responses returned by the
// auth refresh_token endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeRefreshTokenResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeRefreshTokenResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RefreshTokenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			res := NewRefreshTokenResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body RefreshTokenBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			return nil, NewRefreshTokenBadRequest(&body)
		case http.StatusConflict:
			var (
				body RefreshTokenConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			return nil, NewRefreshTokenConflict(&body)
		case http.StatusForbidden:
			var (
				body RefreshTokenForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			return nil, NewRefreshTokenForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body RefreshTokenInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			return nil, NewRefreshTokenInternalError(&body)
		case http.StatusNotFound:
			var (
				body RefreshTokenNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			return nil, NewRefreshTokenNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body RefreshTokenUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "refresh_token", err)
			}
			err = ValidateRefreshTokenUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "refresh_token", err)
			}
			return nil, NewRefreshTokenUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "refresh_token", resp.StatusCode, string(body))
		}
	}
}

// BuildForgotPasswordRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "forgot_password" endpoint
func (c *Client) BuildForgotPasswordRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ForgotPasswordAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "forgot_password", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeForgotPasswordRequest returns an encoder for requests sent to the auth
// forgot_password server.
func EncodeForgotPasswordRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.ForgotPasswordPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "forgot_password", "*auth.ForgotPasswordPayload", v)
		}
		if p.Oauth2 != nil {
			head := *p.Oauth2
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XAPIKey != nil {
			head := *p.XAPIKey
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		values := req.URL.Query()
		if p.RedirectURL != nil {
			values.Add("redirect_url", *p.RedirectURL)
		}
		req.URL.RawQuery = values.Encode()
		body := NewForgotPasswordRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "forgot_password", err)
		}
		return nil
	}
}

// DecodeForgotPasswordResponse returns a decoder for responses returned by the
// auth forgot_password endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeForgotPasswordResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeForgotPasswordResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusAccepted:
			var (
				body ForgotPasswordResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			res := NewForgotPasswordResultAccepted(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ForgotPasswordBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			return nil, NewForgotPasswordBadRequest(&body)
		case http.StatusConflict:
			var (
				body ForgotPasswordConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			return nil, NewForgotPasswordConflict(&body)
		case http.StatusForbidden:
			var (
				body ForgotPasswordForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			return nil, NewForgotPasswordForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body ForgotPasswordInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			return nil, NewForgotPasswordInternalError(&body)
		case http.StatusNotFound:
			var (
				body ForgotPasswordNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			return nil, NewForgotPasswordNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body ForgotPasswordUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "forgot_password", err)
			}
			err = ValidateForgotPasswordUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "forgot_password", err)
			}
			return nil, NewForgotPasswordUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "forgot_password", resp.StatusCode, string(body))
		}
	}
}

// BuildResetPasswordRequest instantiates a HTTP request object with method and
// path set to call the "auth" service "reset_password" endpoint
func (c *Client) BuildResetPasswordRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ResetPasswordAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "reset_password", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeResetPasswordRequest returns an encoder for requests sent to the auth
// reset_password server.
func EncodeResetPasswordRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.ResetPasswordPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "reset_password", "*auth.ResetPasswordPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		body := NewResetPasswordRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "reset_password", err)
		}
		return nil
	}
}

// DecodeResetPasswordResponse returns a decoder for responses returned by the
// auth reset_password endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeResetPasswordResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeResetPasswordResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ResetPasswordResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			res := NewResetPasswordResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ResetPasswordBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			return nil, NewResetPasswordBadRequest(&body)
		case http.StatusConflict:
			var (
				body ResetPasswordConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			return nil, NewResetPasswordConflict(&body)
		case http.StatusForbidden:
			var (
				body ResetPasswordForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			return nil, NewResetPasswordForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body ResetPasswordInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			return nil, NewResetPasswordInternalError(&body)
		case http.StatusNotFound:
			var (
				body ResetPasswordNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			return nil, NewResetPasswordNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body ResetPasswordUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "reset_password", err)
			}
			err = ValidateResetPasswordUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "reset_password", err)
			}
			return nil, NewResetPasswordUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "reset_password", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyEmailRequest instantiates a HTTP request object with method and
// path set to call the "auth" service "verify_email" endpoint
func (c *Client) BuildVerifyEmailRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyEmailAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "verify_email", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyEmailRequest returns an encoder for requests sent to the auth
// verify_email server.
func EncodeVerifyEmailRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.VerifyEmailPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "verify_email", "*auth.VerifyEmailPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		body := NewVerifyEmailRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "verify_email", err)
		}
		return nil
	}
}

// DecodeVerifyEmailResponse returns a decoder for responses returned by the
// auth verify_email endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeVerifyEmailResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeVerifyEmailResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyEmailResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			res := NewVerifyEmailResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body VerifyEmailBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			return nil, NewVerifyEmailBadRequest(&body)
		case http.StatusConflict:
			var (
				body VerifyEmailConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			return nil, NewVerifyEmailConflict(&body)
		case http.StatusForbidden:
			var (
				body VerifyEmailForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			return nil, NewVerifyEmailForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body VerifyEmailInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			return nil, NewVerifyEmailInternalError(&body)
		case http.StatusNotFound:
			var (
				body VerifyEmailNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			return nil, NewVerifyEmailNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body VerifyEmailUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "verify_email", err)
			}
			err = ValidateVerifyEmailUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "verify_email", err)
			}
			return nil, NewVerifyEmailUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "verify_email", resp.StatusCode, string(body))
		}
	}
}

// BuildSendEmailVerificationRequest instantiates a HTTP request object with
// method and path set to call the "auth" service "send_email_verification"
// endpoint
func (c *Client) BuildSendEmailVerificationRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SendEmailVerificationAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "send_email_verification", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSendEmailVerificationRequest returns an encoder for requests sent to
// the auth send_email_verification server.
func EncodeSendEmailVerificationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.SendEmailVerificationPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "send_email_verification", "*auth.SendEmailVerificationPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		values := req.URL.Query()
		if p.RedirectURL != nil {
			values.Add("redirect_url", *p.RedirectURL)
		}
		req.URL.RawQuery = values.Encode()
		body := NewSendEmailVerificationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "send_email_verification", err)
		}
		return nil
	}
}

// DecodeSendEmailVerificationResponse returns a decoder for responses returned
// by the auth send_email_verification endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeSendEmailVerificationResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeSendEmailVerificationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SendEmailVerificationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			res := NewSendEmailVerificationResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body SendEmailVerificationBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			return nil, NewSendEmailVerificationBadRequest(&body)
		case http.StatusConflict:
			var (
				body SendEmailVerificationConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			return nil, NewSendEmailVerificationConflict(&body)
		case http.StatusForbidden:
			var (
				body SendEmailVerificationForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			return nil, NewSendEmailVerificationForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body SendEmailVerificationInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			return nil, NewSendEmailVerificationInternalError(&body)
		case http.StatusNotFound:
			var (
				body SendEmailVerificationNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			return nil, NewSendEmailVerificationNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body SendEmailVerificationUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "send_email_verification", err)
			}
			err = ValidateSendEmailVerificationUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "send_email_verification", err)
			}
			return nil, NewSendEmailVerificationUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "send_email_verification", resp.StatusCode, string(body))
		}
	}
}

// BuildCheckEmailVerificationRequest instantiates a HTTP request object with
// method and path set to call the "auth" service "check_email_verification"
// endpoint
func (c *Client) BuildCheckEmailVerificationRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CheckEmailVerificationAuthPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "check_email_verification", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCheckEmailVerificationRequest returns an encoder for requests sent to
// the auth check_email_verification server.
func EncodeCheckEmailVerificationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.CheckEmailVerificationPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "check_email_verification", "*auth.CheckEmailVerificationPayload", v)
		}
		if p.Oauth2 != nil {
			head := *p.Oauth2
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XAPIKey != nil {
			head := *p.XAPIKey
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		values := req.URL.Query()
		values.Add("email", p.Email)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeCheckEmailVerificationResponse returns a decoder for responses
// returned by the auth check_email_verification endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeCheckEmailVerificationResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeCheckEmailVerificationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CheckEmailVerificationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			res := NewCheckEmailVerificationResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CheckEmailVerificationBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			return nil, NewCheckEmailVerificationBadRequest(&body)
		case http.StatusConflict:
			var (
				body CheckEmailVerificationConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			return nil, NewCheckEmailVerificationConflict(&body)
		case http.StatusForbidden:
			var (
				body CheckEmailVerificationForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			return nil, NewCheckEmailVerificationForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body CheckEmailVerificationInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			return nil, NewCheckEmailVerificationInternalError(&body)
		case http.StatusNotFound:
			var (
				body CheckEmailVerificationNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			return nil, NewCheckEmailVerificationNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body CheckEmailVerificationUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "check_email_verification", err)
			}
			err = ValidateCheckEmailVerificationUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "check_email_verification", err)
			}
			return nil, NewCheckEmailVerificationUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "check_email_verification", resp.StatusCode, string(body))
		}
	}
}

// BuildMeRequest instantiates a HTTP request object with method and path set
// to call the "auth" service "me" endpoint
func (c *Client) BuildMeRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: MeAuthPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "me", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeMeRequest returns an encoder for requests sent to the auth me server.
func EncodeMeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.MePayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "me", "*auth.MePayload", v)
		}
		if p.JWT != nil {
			head := *p.JWT
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeMeResponse returns a decoder for responses returned by the auth me
// endpoint. restoreBody controls whether the response body should be restored
// after having been read.
// DecodeMeResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeMeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body MeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			res := NewMeUserOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body MeBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			return nil, NewMeBadRequest(&body)
		case http.StatusConflict:
			var (
				body MeConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			return nil, NewMeConflict(&body)
		case http.StatusForbidden:
			var (
				body MeForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			return nil, NewMeForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body MeInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			return nil, NewMeInternalError(&body)
		case http.StatusNotFound:
			var (
				body MeNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			return nil, NewMeNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body MeUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "me", err)
			}
			err = ValidateMeUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "me", err)
			}
			return nil, NewMeUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "me", resp.StatusCode, string(body))
		}
	}
}

// BuildCsrfRequest instantiates a HTTP request object with method and path set
// to call the "auth" service "csrf" endpoint
func (c *Client) BuildCsrfRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CsrfAuthPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "csrf", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCsrfRequest returns an encoder for requests sent to the auth csrf
// server.
func EncodeCsrfRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*auth.CsrfPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "csrf", "*auth.CsrfPayload", v)
		}
		if p.SessionID != nil {
			v := *p.SessionID
			req.AddCookie(&http.Cookie{
				Name:  "frank_sid",
				Value: v,
			})
		}
		return nil
	}
}

// DecodeCsrfResponse returns a decoder for responses returned by the auth csrf
// endpoint. restoreBody controls whether the response body should be restored
// after having been read.
// DecodeCsrfResponse may return the following errors:
//   - "bad_request" (type *auth.BadRequestError): http.StatusBadRequest
//   - "conflict" (type *auth.ConflictError): http.StatusConflict
//   - "forbidden" (type *auth.ForbiddenError): http.StatusForbidden
//   - "internal_error" (type *auth.InternalServerError): http.StatusInternalServerError
//   - "not_found" (type *auth.NotFoundError): http.StatusNotFound
//   - "unauthorized" (type *auth.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeCsrfResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CsrfResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			res := NewCsrfCSRFTokenResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CsrfBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			return nil, NewCsrfBadRequest(&body)
		case http.StatusConflict:
			var (
				body CsrfConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			return nil, NewCsrfConflict(&body)
		case http.StatusForbidden:
			var (
				body CsrfForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			return nil, NewCsrfForbidden(&body)
		case http.StatusInternalServerError:
			var (
				body CsrfInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			return nil, NewCsrfInternalError(&body)
		case http.StatusNotFound:
			var (
				body CsrfNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			return nil, NewCsrfNotFound(&body)
		case http.StatusUnauthorized:
			var (
				body CsrfUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "csrf", err)
			}
			err = ValidateCsrfUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "csrf", err)
			}
			return nil, NewCsrfUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "csrf", resp.StatusCode, string(body))
		}
	}
}

// unmarshalUserResponseBodyToDesigntypesUser builds a value of type
// *designtypes.User from a value of type *UserResponseBody.
func unmarshalUserResponseBodyToDesigntypesUser(v *UserResponseBody) *designtypes.User {
	res := &designtypes.User{
		Active:          *v.Active,
		EmailVerified:   *v.EmailVerified,
		PhoneVerified:   v.PhoneVerified,
		ProfileImageURL: v.ProfileImageURL,
		FirstName:       v.FirstName,
		LastName:        v.LastName,
		ID:              *v.ID,
		PhoneNumber:     v.PhoneNumber,
		Email:           *v.Email,
	}
	if v.Locale != nil {
		res.Locale = *v.Locale
	}
	if v.Metadata != nil {
		res.Metadata = make(map[string]any, len(v.Metadata))
		for key, val := range v.Metadata {
			tk := key
			tv := val
			res.Metadata[tk] = tv
		}
	}
	if v.Locale == nil {
		res.Locale = "en"
	}

	return res
}
